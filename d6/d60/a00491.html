<!--
    Copyright (c) 2015-2019, RTE (http://www.rte-france.com)
    See AUTHORS.txt
    All rights reserved.
    This Source Code Form is subject to the terms of the Mozilla Public
    License, v. 2.0. If a copy of the MPL was not distributed with this
    file, you can obtain one at http://mozilla.org/MPL/2.0/.
    SPDX-License-Identifier: MPL-2.0
    This file is part of Dynawo, an hybrid C++/Modelica open source time domain
    simulation tool for power systems.
-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Dynawo: DYNFileSystemUtils.h File Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 150px;">
  <td style="padding-left: 0.5em;">
   <div id="projectbrief">Developer documentation for Dynawo
    1.7.0</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('d6/d60/a00491.html','../../');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">DYNFileSystemUtils.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>File system utility : BOOST FileSystem wrapper.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;string&gt;</code><br />
<code>#include &lt;list&gt;</code><br />
<code>#include &lt;map&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &lt;unordered_set&gt;</code><br />
<code>#include &lt;boost/filesystem.hpp&gt;</code><br />
</div>
<p><a href="../../d6/d60/a00491_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d4e/a02595.html">PathHash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash structure for boost::filesystem::path.  <a href="../../d8/d4e/a02595.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/df0/a02599.html">UserDefinedDirectory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure containing a directory and a boolean indicating whether to recursively scan sub-directories of this directory or not.  <a href="../../df/df0/a02599.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a44286b82de94f55c85aab8a224d942a0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d60/a00491.html#a44286b82de94f55c85aab8a224d942a0">searchFile</a> (const std::string &amp;name, const std::string &amp;rootDir, const bool searchInSubDirs)</td></tr>
<tr class="memdesc:a44286b82de94f55c85aab8a224d942a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for a file within a directory.  <a href="#a44286b82de94f55c85aab8a224d942a0">More...</a><br /></td></tr>
<tr class="separator:a44286b82de94f55c85aab8a224d942a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad80cbd7e87aa79e63eb684d0932b4500"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d60/a00491.html#ad80cbd7e87aa79e63eb684d0932b4500">searchFilesAccordingToExtensions</a> (const std::string &amp;directoryToScan, const std::vector&lt; std::string &gt; &amp;fileExtensionsAllowed, const std::vector&lt; std::string &gt; &amp;fileExtensionsForbidden, const bool searchInSubDirs, std::vector&lt; std::string &gt; &amp;filesFound)</td></tr>
<tr class="memdesc:ad80cbd7e87aa79e63eb684d0932b4500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for a files which have a given file extension within a directory.  <a href="#ad80cbd7e87aa79e63eb684d0932b4500">More...</a><br /></td></tr>
<tr class="separator:ad80cbd7e87aa79e63eb684d0932b4500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cba14f1e7c87d1f6a5b39a045d0f883"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d60/a00491.html#a3cba14f1e7c87d1f6a5b39a045d0f883">searchFilesAccordingToExtension</a> (const std::string &amp;directoryToScan, const std::string fileExtensionAllowed, const std::vector&lt; std::string &gt; &amp;fileExtensionsForbidden, const bool searchInSubDirs, std::vector&lt; std::string &gt; &amp;filesFound)</td></tr>
<tr class="memdesc:a3cba14f1e7c87d1f6a5b39a045d0f883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for a files which have a given file extension within a directory.  <a href="#a3cba14f1e7c87d1f6a5b39a045d0f883">More...</a><br /></td></tr>
<tr class="separator:a3cba14f1e7c87d1f6a5b39a045d0f883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bdbe8aa446b03d7ac021432afaa49e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d60/a00491.html#a6bdbe8aa446b03d7ac021432afaa49e9">searchModelsFiles</a> (const std::string &amp;directoryToScan, const std::string &amp;fileExtension, const std::vector&lt; std::string &gt; &amp;fileExtensionsForbidden, const std::unordered_set&lt; boost::filesystem::path, <a class="el" href="../../d8/d4e/a02595.html">PathHash</a> &gt; &amp;pathsToIgnore, const bool searchInSubDirs, const bool packageForcesSubDirsSearch, const bool stopWhenSeePackage, std::map&lt; std::string, std::string &gt; &amp;filesFound)</td></tr>
<tr class="memdesc:a6bdbe8aa446b03d7ac021432afaa49e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for models within a directory.  <a href="#a6bdbe8aa446b03d7ac021432afaa49e9">More...</a><br /></td></tr>
<tr class="separator:a6bdbe8aa446b03d7ac021432afaa49e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b54fa5956dd0082511bcce6710f6cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d60/a00491.html#a54b54fa5956dd0082511bcce6710f6cb">searchModelsFilesRec</a> (const std::string &amp;directoryToScan, const std::string &amp;fileExtension, const std::vector&lt; std::string &gt; &amp;fileExtensionsForbidden, const std::unordered_set&lt; boost::filesystem::path, <a class="el" href="../../d8/d4e/a02595.html">PathHash</a> &gt; &amp;pathsToIgnore, const bool searchInSubDirs, const bool isPackage, const bool packageForcesSubDirsSearch, const bool stopWhenSeePackage, const std::vector&lt; std::string &gt; &amp;namespaces, std::map&lt; std::string, std::string &gt; &amp;filesFound)</td></tr>
<tr class="memdesc:a54b54fa5956dd0082511bcce6710f6cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search recursively for models within a directory.  <a href="#a54b54fa5956dd0082511bcce6710f6cb">More...</a><br /></td></tr>
<tr class="separator:a54b54fa5956dd0082511bcce6710f6cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00566e8b795753ac0e406f27048483e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d60/a00491.html#a00566e8b795753ac0e406f27048483e7">searchModelicaModels</a> (const std::string &amp;directoryToScan, const std::string &amp;fileExtension, const bool searchInSubDirs, std::vector&lt; std::string &gt; &amp;filesFound)</td></tr>
<tr class="memdesc:a00566e8b795753ac0e406f27048483e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for Modelica models within a directory.  <a href="#a00566e8b795753ac0e406f27048483e7">More...</a><br /></td></tr>
<tr class="separator:a00566e8b795753ac0e406f27048483e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e6ee465650c4ba7dab595ab51b6242"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d60/a00491.html#ad7e6ee465650c4ba7dab595ab51b6242">canonical</a> (const std::string &amp;name, const std::string &amp;rootName=&quot;.&quot;)</td></tr>
<tr class="memdesc:ad7e6ee465650c4ba7dab595ab51b6242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate two paths.  <a href="#ad7e6ee465650c4ba7dab595ab51b6242">More...</a><br /></td></tr>
<tr class="separator:ad7e6ee465650c4ba7dab595ab51b6242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabeca097df4bc0136b0a6f7867bf3f4b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d60/a00491.html#aabeca097df4bc0136b0a6f7867bf3f4b">absolute</a> (const std::string &amp;name, const std::string &amp;rootName=&quot;.&quot;)</td></tr>
<tr class="memdesc:aabeca097df4bc0136b0a6f7867bf3f4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate two paths.  <a href="#aabeca097df4bc0136b0a6f7867bf3f4b">More...</a><br /></td></tr>
<tr class="separator:aabeca097df4bc0136b0a6f7867bf3f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f3fe2f158db70c4daa046c4c3ae4af4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d60/a00491.html#a3f3fe2f158db70c4daa046c4c3ae4af4">createAbsolutePath</a> (const std::string &amp;name, const std::string &amp;rootName)</td></tr>
<tr class="memdesc:a3f3fe2f158db70c4daa046c4c3ae4af4"><td class="mdescLeft">&#160;</td><td class="mdescRight">return name if name is absolute, else concatenate name and rootName  <a href="#a3f3fe2f158db70c4daa046c4c3ae4af4">More...</a><br /></td></tr>
<tr class="separator:a3f3fe2f158db70c4daa046c4c3ae4af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae033c59d263164d7f25cf3eb1d1d7700"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d60/a00491.html#ae033c59d263164d7f25cf3eb1d1d7700">exists</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:ae033c59d263164d7f25cf3eb1d1d7700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a given path exists.  <a href="#ae033c59d263164d7f25cf3eb1d1d7700">More...</a><br /></td></tr>
<tr class="separator:ae033c59d263164d7f25cf3eb1d1d7700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4b28b5a694c48f003480bba6786d3b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d60/a00491.html#abd4b28b5a694c48f003480bba6786d3b">remove</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:abd4b28b5a694c48f003480bba6786d3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a given path.  <a href="#abd4b28b5a694c48f003480bba6786d3b">More...</a><br /></td></tr>
<tr class="separator:abd4b28b5a694c48f003480bba6786d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85029b869526ea4ec4c6f8a7d030f954"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d60/a00491.html#a85029b869526ea4ec4c6f8a7d030f954">copy</a> (const std::string &amp;oldPath, const std::string &amp;newPath)</td></tr>
<tr class="memdesc:a85029b869526ea4ec4c6f8a7d030f954"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy a given file  <a href="#a85029b869526ea4ec4c6f8a7d030f954">More...</a><br /></td></tr>
<tr class="separator:a85029b869526ea4ec4c6f8a7d030f954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6040f0952721948ae705eee884df2a34"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d60/a00491.html#a6040f0952721948ae705eee884df2a34">current_path</a> ()</td></tr>
<tr class="memdesc:a6040f0952721948ae705eee884df2a34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the current path WARNING : not thread-safe.  <a href="#a6040f0952721948ae705eee884df2a34">More...</a><br /></td></tr>
<tr class="separator:a6040f0952721948ae705eee884df2a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f4ac0633c0774f37028c6ab24f1a119"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d60/a00491.html#a3f4ac0633c0774f37028c6ab24f1a119">current_path</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:a3f4ac0633c0774f37028c6ab24f1a119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current file path WARNING : not thread-safe.  <a href="#a3f4ac0633c0774f37028c6ab24f1a119">More...</a><br /></td></tr>
<tr class="separator:a3f4ac0633c0774f37028c6ab24f1a119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb384aa8a88b251aadd7502d85045cbb"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d60/a00491.html#acb384aa8a88b251aadd7502d85045cbb">replace_extension</a> (const std::string &amp;path, const std::string &amp;ext)</td></tr>
<tr class="memdesc:acb384aa8a88b251aadd7502d85045cbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">replace the file extension from a file path  <a href="#acb384aa8a88b251aadd7502d85045cbb">More...</a><br /></td></tr>
<tr class="separator:acb384aa8a88b251aadd7502d85045cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab58803882a0a1f0cbff6f148b037cd94"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d60/a00491.html#ab58803882a0a1f0cbff6f148b037cd94">is_directory</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:ab58803882a0a1f0cbff6f148b037cd94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a path points toward a directory.  <a href="#ab58803882a0a1f0cbff6f148b037cd94">More...</a><br /></td></tr>
<tr class="separator:ab58803882a0a1f0cbff6f148b037cd94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47556cbcb28a09c869778a5cee7f091d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d60/a00491.html#a47556cbcb28a09c869778a5cee7f091d">create_directory</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:a47556cbcb28a09c869778a5cee7f091d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create all relevant directories in order to make a path relevant.  <a href="#a47556cbcb28a09c869778a5cee7f091d">More...</a><br /></td></tr>
<tr class="separator:a47556cbcb28a09c869778a5cee7f091d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bdf0b15b50e125e7721eeef066b7fd9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d60/a00491.html#a9bdf0b15b50e125e7721eeef066b7fd9">extension</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:a9bdf0b15b50e125e7721eeef066b7fd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the file extension from a file path.  <a href="#a9bdf0b15b50e125e7721eeef066b7fd9">More...</a><br /></td></tr>
<tr class="separator:a9bdf0b15b50e125e7721eeef066b7fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af625cf21f2cbbcd9ea2025f53c3673f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d60/a00491.html#af625cf21f2cbbcd9ea2025f53c3673f1">extensionFound</a> (const std::string directoryToScan, const std::vector&lt; std::string &gt; &amp;extensionList)</td></tr>
<tr class="memdesc:af625cf21f2cbbcd9ea2025f53c3673f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether given extensions are found in a directory.  <a href="#af625cf21f2cbbcd9ea2025f53c3673f1">More...</a><br /></td></tr>
<tr class="separator:af625cf21f2cbbcd9ea2025f53c3673f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63c7f55f9670f1e410f24fd92f71a3e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d60/a00491.html#af63c7f55f9670f1e410f24fd92f71a3e">extensionEquals</a> (const std::string path, const std::string <a class="el" href="../../d6/d60/a00491.html#a9bdf0b15b50e125e7721eeef066b7fd9">extension</a>)</td></tr>
<tr class="memdesc:af63c7f55f9670f1e410f24fd92f71a3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether file path ends with a given extension.  <a href="#af63c7f55f9670f1e410f24fd92f71a3e">More...</a><br /></td></tr>
<tr class="separator:af63c7f55f9670f1e410f24fd92f71a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad947a704c4df089c75edf9288351fef2"><td class="memItemLeft" align="right" valign="top">std::list&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d60/a00491.html#ad947a704c4df089c75edf9288351fef2">list_directory</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:ad947a704c4df089c75edf9288351fef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the file list in a directory.  <a href="#ad947a704c4df089c75edf9288351fef2">More...</a><br /></td></tr>
<tr class="separator:ad947a704c4df089c75edf9288351fef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af12c2d11f97514a64122ca5613a08a63"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d60/a00491.html#af12c2d11f97514a64122ca5613a08a63">file_name</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:af12c2d11f97514a64122ca5613a08a63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the file name from a file path.  <a href="#af12c2d11f97514a64122ca5613a08a63">More...</a><br /></td></tr>
<tr class="separator:af12c2d11f97514a64122ca5613a08a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31dd5015190f459e117560175eacd734"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d60/a00491.html#a31dd5015190f459e117560175eacd734">remove_file_name</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:a31dd5015190f459e117560175eacd734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the file name from a file path.  <a href="#a31dd5015190f459e117560175eacd734">More...</a><br /></td></tr>
<tr class="separator:a31dd5015190f459e117560175eacd734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6dd445275c825df6ac8bb75189dcafc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d60/a00491.html#ab6dd445275c825df6ac8bb75189dcafc">remove_all_in_directory</a> (const std::string &amp;directory)</td></tr>
<tr class="memdesc:ab6dd445275c825df6ac8bb75189dcafc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete all contents in a directory.  <a href="#ab6dd445275c825df6ac8bb75189dcafc">More...</a><br /></td></tr>
<tr class="separator:ab6dd445275c825df6ac8bb75189dcafc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b57c5dc6e40612e699fef63261c0b6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d60/a00491.html#ae2b57c5dc6e40612e699fef63261c0b6">parentDirectory</a> (const std::string name)</td></tr>
<tr class="memdesc:ae2b57c5dc6e40612e699fef63261c0b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the parent directory from a given path.  <a href="#ae2b57c5dc6e40612e699fef63261c0b6">More...</a><br /></td></tr>
<tr class="separator:ae2b57c5dc6e40612e699fef63261c0b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac817098f6ff0c9cf640222f0157564e6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d60/a00491.html#ac817098f6ff0c9cf640222f0157564e6">lastParentDirectory</a> (const std::string childPath)</td></tr>
<tr class="memdesc:ac817098f6ff0c9cf640222f0157564e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the last directory from a given path.  <a href="#ac817098f6ff0c9cf640222f0157564e6">More...</a><br /></td></tr>
<tr class="separator:ac817098f6ff0c9cf640222f0157564e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf065d3afa72b6dcdea35f8f3b0d7149"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d60/a00491.html#aaf065d3afa72b6dcdea35f8f3b0d7149">isAbsolutePath</a> (const std::string path)</td></tr>
<tr class="memdesc:aaf065d3afa72b6dcdea35f8f3b0d7149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a given path is absolute or relative.  <a href="#aaf065d3afa72b6dcdea35f8f3b0d7149">More...</a><br /></td></tr>
<tr class="separator:aaf065d3afa72b6dcdea35f8f3b0d7149"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>File system utility : BOOST FileSystem wrapper. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="aabeca097df4bc0136b0a6f7867bf3f4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabeca097df4bc0136b0a6f7867bf3f4b">&#9670;&nbsp;</a></span>absolute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string absolute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>rootName</em> = <code>&quot;.&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenate two paths. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>: the path relative to the root path (may be a file name) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rootName</td><td>: the path to the root directory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the concatenated file path (even when the path does not exist) </dd></dl>

</div>
</div>
<a id="ad7e6ee465650c4ba7dab595ab51b6242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7e6ee465650c4ba7dab595ab51b6242">&#9670;&nbsp;</a></span>canonical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string canonical </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>rootName</em> = <code>&quot;.&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenate two paths. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>: the path relative to the root path (may be a file name) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rootName</td><td>: the path to the root directory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the concatenated file path throw an exception when the path does not exist </dd></dl>

</div>
</div>
<a id="a85029b869526ea4ec4c6f8a7d030f954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85029b869526ea4ec4c6f8a7d030f954">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void copy </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>oldPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>newPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>copy a given file </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">oldPath</td><td>: the path to copy </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newPath</td><td>: the copied file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47556cbcb28a09c869778a5cee7f091d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47556cbcb28a09c869778a5cee7f091d">&#9670;&nbsp;</a></span>create_directory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void create_directory </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create all relevant directories in order to make a path relevant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>: the path from which to create directories </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f3fe2f158db70c4daa046c4c3ae4af4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f3fe2f158db70c4daa046c4c3ae4af4">&#9670;&nbsp;</a></span>createAbsolutePath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string createAbsolutePath </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>rootName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return name if name is absolute, else concatenate name and rootName </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>: the path relative to the root path (may be a file name) </td></tr>
    <tr><td class="paramname">rootName</td><td>: the path to the root directory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the concatenated file path (if path is not absolute) </dd></dl>

</div>
</div>
<a id="a6040f0952721948ae705eee884df2a34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6040f0952721948ae705eee884df2a34">&#9670;&nbsp;</a></span>current_path() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string current_path </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the current path WARNING : not thread-safe. </p>
<dl class="section return"><dt>Returns</dt><dd>the current path as a string (equivalent of cd or pwd) </dd></dl>

</div>
</div>
<a id="a3f4ac0633c0774f37028c6ab24f1a119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f4ac0633c0774f37028c6ab24f1a119">&#9670;&nbsp;</a></span>current_path() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void current_path </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the current file path WARNING : not thread-safe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>: the current path as a string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae033c59d263164d7f25cf3eb1d1d7700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae033c59d263164d7f25cf3eb1d1d7700">&#9670;&nbsp;</a></span>exists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool exists </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether a given path exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>: the path to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the path exists Warning : using this function on a canonical path will either return true or throw an exception (when path is not relevant) </dd></dl>

</div>
</div>
<a id="a9bdf0b15b50e125e7721eeef066b7fd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bdf0b15b50e125e7721eeef066b7fd9">&#9670;&nbsp;</a></span>extension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string extension </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the file extension from a file path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>: the path from which to extract the file extension</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the file extension (or an empty string when no extension was found) Warning : extension ("file.txt.tmp") will return ".tmp" </dd></dl>

</div>
</div>
<a id="af63c7f55f9670f1e410f24fd92f71a3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af63c7f55f9670f1e410f24fd92f71a3e">&#9670;&nbsp;</a></span>extensionEquals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool extensionEquals </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>extension</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether file path ends with a given extension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>: the path to compare with the file extension </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">extension</td><td>: given extension to compare with the path </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether they are equals Warning : extensionEquals ("file.TXT.TMP", ".txt.tmp") will return false </dd></dl>

</div>
</div>
<a id="af625cf21f2cbbcd9ea2025f53c3673f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af625cf21f2cbbcd9ea2025f53c3673f1">&#9670;&nbsp;</a></span>extensionFound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool extensionFound </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>directoryToScan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>extensionList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether given extensions are found in a directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">directoryToScan</td><td>: directory to scan </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">extensionList</td><td>: list of extensions to search in the directory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether given extensions are found in directory </dd></dl>

</div>
</div>
<a id="af12c2d11f97514a64122ca5613a08a63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af12c2d11f97514a64122ca5613a08a63">&#9670;&nbsp;</a></span>file_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string file_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the file name from a file path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>: the path from which to extract the file name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the file name (or an empty string when it fails) </dd></dl>

</div>
</div>
<a id="ab58803882a0a1f0cbff6f148b037cd94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab58803882a0a1f0cbff6f148b037cd94">&#9670;&nbsp;</a></span>is_directory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_directory </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether a path points toward a directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>: the path to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the path points toward a directory </dd></dl>

</div>
</div>
<a id="aaf065d3afa72b6dcdea35f8f3b0d7149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf065d3afa72b6dcdea35f8f3b0d7149">&#9670;&nbsp;</a></span>isAbsolutePath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isAbsolutePath </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether a given path is absolute or relative. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>: the path to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the path is absolute </dd></dl>

</div>
</div>
<a id="ac817098f6ff0c9cf640222f0157564e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac817098f6ff0c9cf640222f0157564e6">&#9670;&nbsp;</a></span>lastParentDirectory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string lastParentDirectory </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>childPath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the last directory from a given path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">childPath</td><td>: the path from which to find the last directory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the last directory lastParentDirectory (/users/test/model/alpha.mo) = model lastParentDirectory (/users/test/model) = model </dd></dl>

</div>
</div>
<a id="ad947a704c4df089c75edf9288351fef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad947a704c4df089c75edf9288351fef2">&#9670;&nbsp;</a></span>list_directory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;std::string&gt; list_directory </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the file list in a directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>: the path from which to extract the directories list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the directories list in the path </dd></dl>

</div>
</div>
<a id="ae2b57c5dc6e40612e699fef63261c0b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2b57c5dc6e40612e699fef63261c0b6">&#9670;&nbsp;</a></span>parentDirectory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string parentDirectory </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the parent directory from a given path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>: the path from which to find the parent path</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the parent file path (return the input path when it is not possible to find the parent directory) parentDirectory (/users/test/model/alpha.mo) = /users/test/model </dd></dl>

</div>
</div>
<a id="abd4b28b5a694c48f003480bba6786d3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd4b28b5a694c48f003480bba6786d3b">&#9670;&nbsp;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool remove </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a given path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>: the path to remove</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the path existed (before trying to remove it) </dd></dl>

</div>
</div>
<a id="ab6dd445275c825df6ac8bb75189dcafc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6dd445275c825df6ac8bb75189dcafc">&#9670;&nbsp;</a></span>remove_all_in_directory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void remove_all_in_directory </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>directory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete all contents in a directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">directory</td><td>: the directory where all contents are deleted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a31dd5015190f459e117560175eacd734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31dd5015190f459e117560175eacd734">&#9670;&nbsp;</a></span>remove_file_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string remove_file_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the file name from a file path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>: the path from which to remove the file name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the file path without the file name </dd></dl>

</div>
</div>
<a id="acb384aa8a88b251aadd7502d85045cbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb384aa8a88b251aadd7502d85045cbb">&#9670;&nbsp;</a></span>replace_extension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string replace_extension </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>replace the file extension from a file path </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>: the path for which to change the extension </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ext</td><td>: the new extension without dot (ex: "txt")</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the updated path as a string </dd></dl>

</div>
</div>
<a id="a44286b82de94f55c85aab8a224d942a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44286b82de94f55c85aab8a224d942a0">&#9670;&nbsp;</a></span>searchFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string searchFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>rootDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>searchInSubDirs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for a file within a directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>: the path to the file relative to the root name (or one of the root subdirectories) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rootDir</td><td>: the path to the root directory from which to start looking </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">searchInSubDirs</td><td>: whether to search in subdirectories, or to only search in the root directory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the file path ("" when the file was not found) throw an exception when the rootPath does not exist </dd></dl>

</div>
</div>
<a id="a3cba14f1e7c87d1f6a5b39a045d0f883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cba14f1e7c87d1f6a5b39a045d0f883">&#9670;&nbsp;</a></span>searchFilesAccordingToExtension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void searchFilesAccordingToExtension </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>directoryToScan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>fileExtensionAllowed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>fileExtensionsForbidden</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>searchInSubDirs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>filesFound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for a files which have a given file extension within a directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">directoryToScan</td><td>: the directory to scan </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fileExtensionAllowed</td><td>: the allowed file extension </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fileExtensionsForbidden</td><td>: the forbidden file extensions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">searchInSubDirs</td><td>: whether to search in subdirectories, or to only search in the root directory </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">filesFound</td><td>: the list of relevant files found</td></tr>
  </table>
  </dd>
</dl>
<p>throw an exception when the rootPath does not exist </p>

</div>
</div>
<a id="ad80cbd7e87aa79e63eb684d0932b4500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad80cbd7e87aa79e63eb684d0932b4500">&#9670;&nbsp;</a></span>searchFilesAccordingToExtensions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void searchFilesAccordingToExtensions </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>directoryToScan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>fileExtensionsAllowed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>fileExtensionsForbidden</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>searchInSubDirs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>filesFound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for a files which have a given file extension within a directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">directoryToScan</td><td>: the directory to scan </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fileExtensionsAllowed</td><td>: a list of allowed file extensions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fileExtensionsForbidden</td><td>: a list of forbidden file extensions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">searchInSubDirs</td><td>: whether to search in subdirectories, or to only search in the root directory </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">filesFound</td><td>: the list of relevant absolute files paths found</td></tr>
  </table>
  </dd>
</dl>
<p>throw an exception when the rootPath does not exist </p>

</div>
</div>
<a id="a00566e8b795753ac0e406f27048483e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00566e8b795753ac0e406f27048483e7">&#9670;&nbsp;</a></span>searchModelicaModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void searchModelicaModels </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>directoryToScan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileExtension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>searchInSubDirs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>filesFound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for Modelica models within a directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">directoryToScan</td><td>: the directory to scan </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fileExtension</td><td>: the allowed file extension </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">searchInSubDirs</td><td>: whether to search in subdirectories, or to only search in the root directory </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">filesFound</td><td>: the list of relevant files found</td></tr>
  </table>
  </dd>
</dl>
<p>if a package.mo file is located at the root of the directory, it is not scanned any further (the Modelica compiler will deal with it) otherwise, the directory is scanned for Modelica files the same algorithm is applied to subdirectories when no package.mo was found in the current directory</p>
<p>throw an exception when the rootPath does not exist </p>

</div>
</div>
<a id="a6bdbe8aa446b03d7ac021432afaa49e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bdbe8aa446b03d7ac021432afaa49e9">&#9670;&nbsp;</a></span>searchModelsFiles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void searchModelsFiles </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>directoryToScan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileExtension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>fileExtensionsForbidden</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_set&lt; boost::filesystem::path, <a class="el" href="../../d8/d4e/a02595.html">PathHash</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pathsToIgnore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>searchInSubDirs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>packageForcesSubDirsSearch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>stopWhenSeePackage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::string, std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>filesFound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for models within a directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">directoryToScan</td><td>: the directory to scan </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fileExtension</td><td>: the allowed file extension </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fileExtensionsForbidden</td><td>: the forbidden file extension </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pathsToIgnore</td><td>: paths that shouldn't be explored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">searchInSubDirs</td><td>: whether to search in subdirectories, or to only search in the root directory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">packageForcesSubDirsSearch</td><td>: true if for a package we have to look for models in subdirectories </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stopWhenSeePackage</td><td>: true if for a package we don't want to look for models in subdirectories </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">filesFound</td><td>: map containing the model name and the file path</td></tr>
  </table>
  </dd>
</dl>
<p>call searchModelsFilesRec </p>

</div>
</div>
<a id="a54b54fa5956dd0082511bcce6710f6cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54b54fa5956dd0082511bcce6710f6cb">&#9670;&nbsp;</a></span>searchModelsFilesRec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void searchModelsFilesRec </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>directoryToScan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileExtension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>fileExtensionsForbidden</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_set&lt; boost::filesystem::path, <a class="el" href="../../d8/d4e/a02595.html">PathHash</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pathsToIgnore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>searchInSubDirs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>isPackage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>packageForcesSubDirsSearch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>stopWhenSeePackage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>namespaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::string, std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>filesFound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search recursively for models within a directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">directoryToScan</td><td>: the directory to scan </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fileExtension</td><td>: the allowed file extension </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fileExtensionsForbidden</td><td>: the forbidden file extension </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pathsToIgnore</td><td>: paths that shouldn't be explored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">searchInSubDirs</td><td>: whether to search in subdirectories, or to only search in the root directory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isPackage</td><td>: true if the current directory is a package </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">packageForcesSubDirsSearch</td><td>: true if for a package we have to look for models in subdirectories </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stopWhenSeePackage</td><td>: true if for a package we don't want to look for models in subdirectories </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">namespaces</td><td>: models name to insert in the filesFound map </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">filesFound</td><td>: map containing the model name and the file path</td></tr>
  </table>
  </dd>
</dl>
<p>throw an exception when the rootPath does not exist </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!--
    Copyright (c) 2015-2019, RTE (http://www.rte-france.com)
    See AUTHORS.txt
    All rights reserved.
    This Source Code Form is subject to the terms of the Mozilla Public
    License, v. 2.0. If a copy of the MPL was not distributed with this
    file, you can obtain one at http://mozilla.org/MPL/2.0/.
    SPDX-License-Identifier: MPL-2.0
    This file is part of Dynawo, an hybrid C++/Modelica open source time domain
    simulation tool for power systems.
-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../dir_1784a59e55c9933a90efd2d239600c8f.html">dynawo</a></li><li class="navelem"><a class="el" href="../../dir_22a316840cfeae933077e8f7330b01fd.html">sources</a></li><li class="navelem"><a class="el" href="../../dir_c5eaf1ac1cf936f6800d020d474d243d.html">Common</a></li><li class="navelem"><a class="el" href="../../d6/d60/a00491.html">DYNFileSystemUtils.h</a></li>
    <li class="footer">Generated on Thu Dec 5 2024 16:56:12 for Dynawo by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
