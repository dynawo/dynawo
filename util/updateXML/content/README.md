# updateXML

updateXML is a Python library developed to update existing Dynawo input files generated by a specific version to another following version.

### How to

#### Command to execute

```bash
python update.py --job /path/to/your/file/fic_JOB.xml --origin 1.2.0 --version 1.5.0 -o .
```

### Mandatory options

```bash
--job : Path to the job file to update
```

```bash
--origin : Indicates the Dynawo version used to generate the input jobs
```

```bash
--version : Indicates the Dynawo version of the outputs files
```

```bash
-o : Path to generate the output files
```

### Other option

```bash
--scriptfolders : When used, this option replaces the search for update scripts in the main script folder by an update scripts search in given folders
```

```bash
--log : Add the applied_tickets.log file containing the applied tickets during the updates. The @ticket() decorator needs to be added to the update method of update scripts for the tickets to appear in applied_tickets.log. The applied_tickets.log file is created at the same place as the other outputs.
```

Example :

```bash
python update.py --job /path/to/your/file/fic_JOB.xml --origin 1.2.0 --version 1.5.0 -o . --scriptfolders updatefolder1,updatefolder2,updatefolder3 --log
```

### Functional behaviour

To apply updateXML to all these files with versions in increasing order :

```bash
#updates of v1.3.2
update1.3.2.0.py
update1.3.2.1.py

#updates of v1.4.0
update1.4.0.0.py
update1.4.0.1.py
update1.4.0.2.py

#updates of v1.5.0
update1.5.0.0.py
```

You have to type :

```bash
python update.py --job /path/to/your/file/fic_JOB.xml --origin 1.2.0 --version 1.5.0 -o .
```

This will execute **update.py** which will call its **update()** method, then the **update()** method calls every other **update()** methods contained in the python scripts which have the same name as **update.py** in the increasing order from 1.2.0 version to 1.5.0 version, that is to say : **update.1.3.2.0.py**, **update1.3.2.1.py**, **update1.4.0.0.py**, **update1.4.0.1.py**, **update1.4.0.2.py** then **update.1.5.0.0.py**.

### Implement update scripts

To code an update script **updateMAJOR.MINOR.PATCH.NUMMODIF.py**, just define an update() function in your update script file :

```python
def update(jobs):
    omegarefs = jobs.dyds.get_bbms(lambda bbm: bbm.get_lib_name() == "DYNModelOmegaRef")
    for omegaref in omegarefs:
        omegaref.set_lib_name("DYNModelOmegaRef_NAME_CHANGED")
```

### List of possible modifications

#### Change a library name

```python
my_bbm.set_lib_name("DYNModelOmegaRef_NAME_CHANGED")
```

#### Add a parameter in the parset of a library

```python
my_bbm.parset.add_param("DOUBLE", "load_gamma", "42.5")
```

#### Remove a parameter in the parset of a library

```python
load.parset.remove_param_or_ref("load_alpha")
```

#### Change a parameter name

```python
load.parset.change_param_or_ref_name("load_beta", "load_beta_NAME_CHANGED")
```

#### Change a var name in a connect XML element

```python
load.connects.change_var_name("load_terminal", "load_terminal_NAME_CHANGED")
```

### The @ticket() decorator

If you want, you can add a decorator **@ticket()** on the **update()** function. This decorator contains the ticket number related to the patch script and is used to dump the ticket number applied to Dynawo input files in the **applied_tickets.log** file if the **--log** command line option is used.

```python
from Ticket import ticket

@ticket(870)
def update(jobs):
    omegarefs = jobs.dyds.get_bbms(lambda bbm: bbm.get_lib_name() == "DYNModelOmegaRef")
    for omegaref in omegarefs:
        omegaref.set_lib_name("DYNModelOmegaRef_NAME_CHANGED")
```
