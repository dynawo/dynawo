within Dynawo.Electrical.Controls.Machines.StatorCurrentLimiters.Standard;

/*
* Copyright (c) 2024, RTE (http://www.rte-france.com)
* See AUTHORS.txt
* All rights reserved.
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this
* file, you can obtain one at http://mozilla.org/MPL/2.0/.
* SPDX-License-Identifier: MPL-2.0
*
* This file is part of Dynawo, an hybrid C++/Modelica open source suite
* of simulation tools for power systems.
*/

model Scl1c "IEEE (2016) stator current limiter type SCL1C model"

  //Regulation parameters
  parameter Types.CurrentModulePu IqMinPu "Dead-band for reactive current in pu (base SnRef, UNom)";
  parameter Types.CurrentModulePu ISclLimPu "SCL terminal current pick up level in pu (base SnRef, UNom)";
  parameter Types.PerUnit K "SCL timing characteristic factor";
  parameter Types.PerUnit KiOex "SCL integral gain (overexcited range)";
  parameter Types.PerUnit KiUex "SCL integral gain (underexcited range)";
  parameter Types.PerUnit KpOex "SCL proportional gain (overexcited range)";
  parameter Types.PerUnit KpUex "SCL proportional gain (underexcited range)";
  parameter Boolean Sw1 "Reactive current/reactive power selector";
  parameter Boolean Sw2 "Fixed-time or inverse time selector";
  parameter Types.Time tDScl "Fixed-time delay after pickup in s";
  parameter Types.Time tInv "Inverse time delay after pickup in s";
  parameter Types.Time tIt "Terminal current transducer equivalent time constant in s";
  parameter Types.Time tQScl "Reactive current transducer equivalent time constant in s";
  parameter Types.ReactivePowerPu VSclDb "Dead-band for reactive power or power factor in pu (base SnRef)";
  parameter Types.VoltageModulePu VSclMaxPu "SCL upper integrator limit in pu (base UNom)";
  parameter Types.VoltageModulePu VSclMinPu "SCL lower integrator limit in pu (base UNom)";

  //Input variables
  Modelica.ComplexBlocks.Interfaces.ComplexInput itPu(re(start = it0Pu.re), im(start = it0Pu.im)) "Complex stator current in pu (base SnRef, UNom)" annotation(
    Placement(visible = true, transformation(origin = {-280, -80}, extent = {{-20, -20}, {20, 20}}, rotation = 0), iconTransformation(origin = {120, -40}, extent = {{-20, -20}, {20, 20}}, rotation = 180)));
  Modelica.Blocks.Interfaces.RealInput QGenPu(start = QGen0Pu) "Reactive power generated by the synchronous machine in pu (base SnRef) (generator convention)" annotation(
    Placement(visible = true, transformation(origin = {-280, 120}, extent = {{-20, -20}, {20, 20}}, rotation = 0), iconTransformation(extent = {{-140, -20}, {-100, 20}}, rotation = 0)));
  Modelica.ComplexBlocks.Interfaces.ComplexInput utPu(re(start = ut0Pu.re), im(start = ut0Pu.im)) "Complex stator voltage in pu (base UNom)" annotation(
    Placement(visible = true, transformation(origin = {-280, 80}, extent = {{-20, -20}, {20, 20}}, rotation = 0), iconTransformation(origin = {120, -80}, extent = {{-20, -20}, {20, 20}}, rotation = 180)));

  //Output variables
  Modelica.Blocks.Interfaces.RealOutput USclOelPu(start = 0) "Stator current overexcitation limitation output voltage in pu (base UNom)" annotation(
    Placement(visible = true, transformation(origin = {270, 80}, extent = {{-10, -10}, {10, 10}}, rotation = 0), iconTransformation(origin = {110, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Interfaces.RealOutput USclUelPu(start = 0) "Stator current underexcitation limitation output voltage in pu (base UNom)" annotation(
    Placement(visible = true, transformation(origin = {270, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0), iconTransformation(origin = {110, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));

  Dynawo.NonElectrical.Blocks.Complex.ComplexToPolar complexToPolar annotation(
    Placement(visible = true, transformation(origin = {-230, -80}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Dynawo.NonElectrical.Blocks.Complex.ComplexToPolar complexToPolar1 annotation(
    Placement(visible = true, transformation(origin = {-230, 80}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Math.Division division annotation(
    Placement(visible = true, transformation(origin = {-170, 100}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Continuous.FirstOrder firstOrder(T = tQScl, y_start = QGen0Pu / Modelica.ComplexMath.'abs'(ut0Pu)) annotation(
    Placement(visible = true, transformation(origin = {-130, 100}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Dynawo.NonElectrical.Blocks.Continuous.Power power(N = K, NInteger = true) annotation(
    Placement(visible = true, transformation(origin = {-90, 100}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Math.Add add(k2 = -1) annotation(
    Placement(visible = true, transformation(origin = {-10, 94}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Math.Add add1(k1 = -1, k2 = -1) annotation(
    Placement(visible = true, transformation(origin = {-10, -14}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Sources.Constant const(k = IqMinPu) annotation(
    Placement(visible = true, transformation(origin = {-10, 40}, extent = {{10, -10}, {-10, 10}}, rotation = 0)));
  Modelica.Blocks.Continuous.FirstOrder firstOrder1(T = tIt, y_start = Modelica.ComplexMath.'abs'(it0Pu)) annotation(
    Placement(visible = true, transformation(origin = {-170, -40}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Continuous.FirstOrder firstOrder2(T = tInv, y_start = Modelica.ComplexMath.'abs'(it0Pu)) annotation(
    Placement(visible = true, transformation(origin = {-170, -120}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Dynawo.NonElectrical.Blocks.Continuous.Power power1(N = K, NInteger = true) annotation(
    Placement(visible = true, transformation(origin = {-130, -40}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Sources.Constant const1(k = ISclLimPu) annotation(
    Placement(visible = true, transformation(origin = {-130, -80}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Math.Feedback feedback annotation(
    Placement(visible = true, transformation(origin = {-80, -40}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Math.Feedback feedback1 annotation(
    Placement(visible = true, transformation(origin = {-80, -120}, extent = {{-10, 10}, {10, -10}}, rotation = 0)));
  Modelica.Blocks.Math.Min min1 annotation(
    Placement(visible = true, transformation(origin = {50, 88}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Math.Min min2 annotation(
    Placement(visible = true, transformation(origin = {50, -8}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Logical.Switch switchOel annotation(
    Placement(visible = true, transformation(origin = {110, 80}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Logical.Switch switchUel annotation(
    Placement(visible = true, transformation(origin = {110, 0}, extent = {{-10, 10}, {10, -10}}, rotation = 0)));
  Modelica.Blocks.Sources.BooleanConstant booleanConstant(k = Sw1) annotation(
    Placement(visible = true, transformation(origin = {50, 40}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Dynawo.NonElectrical.Blocks.Continuous.LimitedPI limPIOel(Ki = KiOex, Kp = KpOex, YMax = VSclMaxPu, YMin = VSclMinPu) annotation(
    Placement(visible = true, transformation(origin = {150, 80}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Dynawo.NonElectrical.Blocks.Continuous.LimitedPI limPIUel(Ki = KiUex, Kp = KpUex, YMax = VSclMaxPu, YMin = VSclMinPu) annotation(
    Placement(visible = true, transformation(origin = {150, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Nonlinear.Limiter limiterOel(uMax = 999, uMin = 0) annotation(
    Placement(visible = true, transformation(origin = {190, 80}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Nonlinear.Limiter limiterUel(uMax = 999, uMin = 0) annotation(
    Placement(visible = true, transformation(origin = {190, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Logical.GreaterThreshold greaterThreshold annotation(
    Placement(visible = true, transformation(origin = {50, -80}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Logical.Timer timer annotation(
    Placement(visible = true, transformation(origin = {90, -80}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Math.Gain gain(k = -1) annotation(
    Placement(visible = true, transformation(origin = {230, 80}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));

  //Initial parameters
  parameter Types.ComplexCurrentPu it0Pu "Initial complex stator current in pu (base SnRef, UNom)";
  parameter Types.ReactivePowerPu QGen0Pu "Initial reactive power in pu (base SnRef) (generator convention)";
  parameter Types.ComplexVoltagePu ut0Pu "Initial complex stator voltage in pu (base UNom)";

protected
  Modelica.Blocks.Interfaces.RealOutput ISclErrPu annotation(
    Placement(visible = true, transformation(origin = {270, -40}, extent = {{-10, -10}, {10, 10}}, rotation = 0), iconTransformation(origin = {110, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Interfaces.RealOutput ISclInvPu annotation(
    Placement(visible = true, transformation(origin = {270, -120}, extent = {{-10, -10}, {10, 10}}, rotation = 0), iconTransformation(origin = {110, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));

equation
  if (not Sw2 and timer.y > tDScl) or (Sw2 and ISclInvPu > 0) then
    if QGenPu > VSclDb then
      switchOel.u3 = ISclErrPu;
      switchUel.u3 = 0;
    elseif QGenPu < (-VSclDb) then
      switchOel.u3 = 0;
      switchUel.u3 = ISclErrPu;
    else
      switchOel.u3 = 0;
      switchUel.u3 = 0;
    end if;
  else
    switchOel.u3 = 0;
    switchUel.u3 = 0;
  end if;

  connect(utPu, complexToPolar1.u) annotation(
    Line(points = {{-280, 80}, {-242, 80}}, color = {85, 170, 255}));
  connect(QGenPu, division.u1) annotation(
    Line(points = {{-280, 120}, {-200, 120}, {-200, 106}, {-182, 106}}, color = {0, 0, 127}));
  connect(complexToPolar1.len, division.u2) annotation(
    Line(points = {{-218, 86}, {-200, 86}, {-200, 94}, {-182, 94}}, color = {0, 0, 127}));
  connect(complexToPolar.len, firstOrder1.u) annotation(
    Line(points = {{-218, -74}, {-200, -74}, {-200, -40}, {-182, -40}}, color = {0, 0, 127}));
  connect(complexToPolar.len, firstOrder2.u) annotation(
    Line(points = {{-218, -74}, {-200, -74}, {-200, -120}, {-182, -120}}, color = {0, 0, 127}));
  connect(firstOrder1.y, power1.u) annotation(
    Line(points = {{-159, -40}, {-143, -40}}, color = {0, 0, 127}));
  connect(firstOrder2.y, feedback1.u1) annotation(
    Line(points = {{-159, -120}, {-89, -120}}, color = {0, 0, 127}));
  connect(power1.y, feedback.u1) annotation(
    Line(points = {{-119, -40}, {-89, -40}}, color = {0, 0, 127}));
  connect(const1.y, feedback.u2) annotation(
    Line(points = {{-119, -80}, {-80, -80}, {-80, -48}}, color = {0, 0, 127}));
  connect(const1.y, feedback1.u2) annotation(
    Line(points = {{-119, -80}, {-80, -80}, {-80, -112}}, color = {0, 0, 127}));
  connect(division.y, firstOrder.u) annotation(
    Line(points = {{-159, 100}, {-143, 100}}, color = {0, 0, 127}));
  connect(firstOrder.y, power.u) annotation(
    Line(points = {{-119, 100}, {-103, 100}}, color = {0, 0, 127}));
  connect(power.y, add.u1) annotation(
    Line(points = {{-79, 100}, {-22, 100}}, color = {0, 0, 127}));
  connect(const.y, add.u2) annotation(
    Line(points = {{-21, 40}, {-40, 40}, {-40, 88}, {-22, 88}}, color = {0, 0, 127}));
  connect(const.y, add1.u1) annotation(
    Line(points = {{-21, 40}, {-40, 40}, {-40, -8}, {-22, -8}}, color = {0, 0, 127}));
  connect(power.y, add1.u2) annotation(
    Line(points = {{-79, 100}, {-60, 100}, {-60, -20}, {-22, -20}}, color = {0, 0, 127}));
  connect(itPu, complexToPolar.u) annotation(
    Line(points = {{-280, -80}, {-242, -80}}, color = {85, 170, 255}));
  connect(add.y, min1.u1) annotation(
    Line(points = {{1, 94}, {38, 94}}, color = {0, 0, 127}));
  connect(add1.y, min2.u2) annotation(
    Line(points = {{1, -14}, {38, -14}}, color = {0, 0, 127}));
  connect(feedback.y, min1.u2) annotation(
    Line(points = {{-71, -40}, {20, -40}, {20, 82}, {38, 82}}, color = {0, 0, 127}, pattern = LinePattern.Dash));
  connect(feedback.y, min2.u1) annotation(
    Line(points = {{-71, -40}, {20, -40}, {20, -2}, {38, -2}}, color = {0, 0, 127}, pattern = LinePattern.Dash));
  connect(booleanConstant.y, switchOel.u2) annotation(
    Line(points = {{61, 40}, {80, 40}, {80, 80}, {98, 80}}, color = {255, 0, 255}));
  connect(booleanConstant.y, switchUel.u2) annotation(
    Line(points = {{61, 40}, {80, 40}, {80, 0}, {98, 0}}, color = {255, 0, 255}));
  connect(min1.y, switchOel.u1) annotation(
    Line(points = {{61, 88}, {97, 88}}, color = {0, 0, 127}));
  connect(min2.y, switchUel.u1) annotation(
    Line(points = {{61, -8}, {98, -8}}, color = {0, 0, 127}));
  connect(switchOel.y, limPIOel.u) annotation(
    Line(points = {{121, 80}, {137, 80}}, color = {0, 0, 127}));
  connect(switchUel.y, limPIUel.u) annotation(
    Line(points = {{121, 0}, {137, 0}}, color = {0, 0, 127}));
  connect(limPIOel.y, limiterOel.u) annotation(
    Line(points = {{161, 80}, {177, 80}}, color = {0, 0, 127}));
  connect(limPIUel.y, limiterUel.u) annotation(
    Line(points = {{161, 0}, {177, 0}}, color = {0, 0, 127}));
  connect(feedback.y, ISclErrPu) annotation(
    Line(points = {{-71, -40}, {270, -40}}, color = {0, 0, 127}, pattern = LinePattern.Dash));
  connect(feedback1.y, ISclInvPu) annotation(
    Line(points = {{-71, -120}, {269, -120}}, color = {0, 0, 127}));
  connect(feedback.y, greaterThreshold.u) annotation(
    Line(points = {{-71, -40}, {20, -40}, {20, -80}, {38, -80}}, color = {0, 0, 127}, pattern = LinePattern.Dash));
  connect(greaterThreshold.y, timer.u) annotation(
    Line(points = {{61, -80}, {77, -80}}, color = {255, 0, 255}));
  connect(limiterOel.y, gain.u) annotation(
    Line(points = {{201, 80}, {217, 80}}, color = {0, 0, 127}));
  connect(gain.y, USclOelPu) annotation(
    Line(points = {{241, 80}, {269, 80}}, color = {0, 0, 127}));
  connect(limiterUel.y, USclUelPu) annotation(
    Line(points = {{201, 0}, {269, 0}}, color = {0, 0, 127}));

  annotation(
    preferredView = "diagram",
    Diagram(coordinateSystem(extent = {{-260, -140}, {260, 140}})));
end Scl1c;
