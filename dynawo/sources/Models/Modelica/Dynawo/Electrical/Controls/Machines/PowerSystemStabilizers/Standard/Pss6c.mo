within Dynawo.Electrical.Controls.Machines.PowerSystemStabilizers.Standard;

/*
* Copyright (c) 2024, RTE (http://www.rte-france.com)
* See AUTHORS.txt
* All rights reserved.
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this
* file, you can obtain one at http://mozilla.org/MPL/2.0/.
* SPDX-License-Identifier: MPL-2.0
*
* This file is part of Dynawo, an hybrid C++/Modelica open source suite
* of simulation tools for power systems.
*/

model Pss6c

  //Regulation parameters
  parameter Types.PerUnit KOmega = 1 "Coefficient applied to angular frequency";
  parameter Types.PerUnit KOmegaRef = 0 "Coefficient applied to reference angular frequency";
  parameter Types.PerUnit K0 "Gain of first integrator input";
  parameter Types.PerUnit K1 "Gain of first integrator output";
  parameter Types.PerUnit K2 "Gain of second integrator output";
  parameter Types.PerUnit K3 "Gain of third integrator output";
  parameter Types.PerUnit K4 "Gain of fourth integrator output";
  parameter Types.PerUnit Ki3 "Gain of third integrator";
  parameter Types.PerUnit Ki4 "Gain of fourth integrator";
  parameter Types.PerUnit Ks "Gain of power system stabilizer";
  parameter Types.PerUnit Ks1 "Gain of active power branch";
  parameter Types.PerUnit Ks2 "Gain of angular frequency branch";
  parameter Types.PerUnit MAcc "Gain of angular velocity";
  parameter Types.AngularVelocityPu OmegaMaxPu "Maximum angular velocity in pu (base omegaNom)";
  parameter Types.AngularVelocityPu OmegaMinPu "Minimum angular velocity in pu (base omegaNom)";
  parameter Types.ActivePowerPu PGenMaxPu "Maximum active power in pu (base SNom) (generator convention)";
  parameter Types.ActivePowerPu PGenMinPu "Minimum active power in pu (base SNom) (generator convention)";
  parameter Types.ActivePowerPu PPssOffPu "Lower active power threshold for PSS activation in pu (base SNom) (generator convention)";
  parameter Types.ActivePowerPu PPssOnPu "Higher active power threshold for PSS activation in pu (base SNom) (generator convention)";
  parameter Types.Time t1 "Transducer time constant (active power branch) in s";
  parameter Types.Time t2 "Transducer time constant (angular frequency branch) in s";
  parameter Types.Time t3 "First order time constant (active power branch) in s";
  parameter Types.Time t4 "Derivative time constant (angular frequency branch) in s";
  parameter Types.Time tD "Washout time constant in s";
  parameter Types.Time tI1 "Time constant of first integrator, in s";
  parameter Types.Time tI2 "Time constant of second integrator, in s";
  parameter Types.Time tI3 "Time constant of third integrator, in s";
  parameter Types.Time tI4 "Time constant of fourth integrator, in s";
  parameter Types.VoltageModulePu VPssMaxPu "Maximum output voltage of power system stabilizer in pu (base UNom)";
  parameter Types.VoltageModulePu VPssMinPu "Minimum output voltage of power system stabilizer in pu (base UNom)";

  //Generator parameter
  parameter Types.ApparentPowerModule SNom "Nominal apparent power in MVA";

  //Input variables
  Modelica.Blocks.Interfaces.RealInput omegaPu(start = SystemBase.omega0Pu) "Angular frequency in pu (base omegaNom)" annotation(
    Placement(visible = true, transformation(origin = {-400, -40}, extent = {{-20, -20}, {20, 20}}, rotation = 0), iconTransformation(origin = {-120, 0}, extent = {{-20, -20}, {20, 20}}, rotation = 0)));
  Modelica.Blocks.Interfaces.RealInput omegaRefPu(start = SystemBase.omegaRef0Pu) "Reference angular frequency in pu (base omegaNom)" annotation(
    Placement(visible = true, transformation(origin = {-400, -80}, extent = {{-20, -20}, {20, 20}}, rotation = 0), iconTransformation(origin = {-120, -60}, extent = {{-20, -20}, {20, 20}}, rotation = 0)));
  Modelica.Blocks.Interfaces.RealInput PGenPu(start = PGen0Pu) "Active power generated by the synchronous machine in pu (base SnRef) (generator convention)" annotation(
    Placement(visible = true, transformation(origin = {-400, 60}, extent = {{-20, -20}, {20, 20}}, rotation = 0), iconTransformation(origin = {-120, 60}, extent = {{-20, -20}, {20, 20}}, rotation = 0)));

  //Output variable
  Modelica.Blocks.Interfaces.RealOutput VPssPu(start = 0) "Output voltage of power system stabilizer in pu (base UNom)" annotation(
    Placement(visible = true, transformation(origin = {430, -40}, extent = {{-10, -10}, {10, 10}}, rotation = 0), iconTransformation(origin = {110, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));

  Modelica.Blocks.Math.Gain gain(k = SystemBase.SnRef / SNom) annotation(
    Placement(visible = true, transformation(origin = {-350, 60}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Nonlinear.Limiter limiter(uMax = PGenMaxPu, uMin = PGenMinPu) annotation(
    Placement(visible = true, transformation(origin = {-290, 60}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Nonlinear.Limiter limiter1(uMax = OmegaMaxPu, uMin = OmegaMinPu) annotation(
    Placement(visible = true, transformation(origin = {-290, -60}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Continuous.FirstOrder firstOrder(T = t1, y_start = PGen0Pu * SystemBase.SnRef / SNom) annotation(
    Placement(visible = true, transformation(origin = {-250, 60}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Continuous.FirstOrder firstOrder1(T = t3, k = Ks1, y_start = Ks1 * PGen0Pu * SystemBase.SnRef / SNom) annotation(
    Placement(visible = true, transformation(origin = {-190, 60}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Math.Add3 add3(k2 = -1) annotation(
    Placement(visible = true, transformation(origin = {-130, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Continuous.FirstOrder firstOrder2(T = t2, k = Ks2, y_start = KOmega * SystemBase.omega0Pu + KOmegaRef * SystemBase.omegaRef0Pu) annotation(
    Placement(visible = true, transformation(origin = {-250, -60}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Continuous.Derivative derivative(T = t4, k = MAcc, x_start = KOmega * SystemBase.omega0Pu + KOmegaRef * SystemBase.omegaRef0Pu) annotation(
    Placement(visible = true, transformation(origin = {-190, -60}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Dynawo.NonElectrical.Blocks.Continuous.Washout washout(tW = tD, U0 = (Ks1 - 1) * PGen0Pu * SystemBase.SnRef / SNom) annotation(
    Placement(visible = true, transformation(origin = {-90, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Math.Feedback feedback annotation(
    Placement(visible = true, transformation(origin = {-40, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Continuous.Integrator integrator1(k = 1 / tI1) annotation(
    Placement(visible = true, transformation(origin = {10, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Continuous.Integrator integrator2(k = 1 / tI2) annotation(
    Placement(visible = true, transformation(origin = {70, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Continuous.Integrator integrator3(k = Ki3 / tI3) annotation(
    Placement(visible = true, transformation(origin = {130, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Continuous.Integrator integrator4(k = Ki4 / tI4) annotation(
    Placement(visible = true, transformation(origin = {190, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Math.Sum sum1(k = {K1, K2, K3, K4, K0}, nin = 5) annotation(
    Placement(visible = true, transformation(origin = {250, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Math.Gain gain1(k = Ks) annotation(
    Placement(visible = true, transformation(origin = {290, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Math.Sum sum2(nin = 4) annotation(
    Placement(visible = true, transformation(origin = {10, -60}, extent = {{10, -10}, {-10, 10}}, rotation = 0)));
  Modelica.Blocks.Nonlinear.Limiter limiter2(uMax = VPssMaxPu, uMin = VPssMinPu) annotation(
    Placement(visible = true, transformation(origin = {330, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Logical.Hysteresis hysteresis(uHigh = PPssOnPu, uLow = PPssOffPu, y(start = PGen0Pu * SystemBase.SnRef / SNom > PPssOffPu)) annotation(
    Placement(visible = true, transformation(origin = {-290, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Sources.Constant const(k = 0) annotation(
    Placement(visible = true, transformation(origin = {330, -80}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Logical.Switch switch annotation(
    Placement(visible = true, transformation(origin = {390, -40}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Math.Add add(k1 = KOmega, k2 = KOmegaRef) annotation(
    Placement(visible = true, transformation(origin = {-330, -60}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));

  //Generator initial parameter
  parameter Types.ActivePowerPu PGen0Pu "Initial active power in pu (base SnRef) (generator convention)";

equation
  connect(PGenPu, gain.u) annotation(
    Line(points = {{-400, 60}, {-362, 60}}, color = {0, 0, 127}));
  connect(gain.y, limiter.u) annotation(
    Line(points = {{-339, 60}, {-303, 60}}, color = {0, 0, 127}));
  connect(limiter.y, firstOrder.u) annotation(
    Line(points = {{-279, 60}, {-263, 60}}, color = {0, 0, 127}));
  connect(firstOrder.y, firstOrder1.u) annotation(
    Line(points = {{-239, 60}, {-203, 60}}, color = {0, 0, 127}));
  connect(firstOrder1.y, add3.u1) annotation(
    Line(points = {{-179, 60}, {-160, 60}, {-160, 8}, {-143, 8}}, color = {0, 0, 127}));
  connect(firstOrder.y, add3.u2) annotation(
    Line(points = {{-239, 60}, {-220, 60}, {-220, 0}, {-143, 0}}, color = {0, 0, 127}));
  connect(limiter1.y, firstOrder2.u) annotation(
    Line(points = {{-279, -60}, {-263, -60}}, color = {0, 0, 127}));
  connect(firstOrder2.y, derivative.u) annotation(
    Line(points = {{-239, -60}, {-203, -60}}, color = {0, 0, 127}));
  connect(derivative.y, add3.u3) annotation(
    Line(points = {{-179, -60}, {-160, -60}, {-160, -8}, {-143, -8}}, color = {0, 0, 127}));
  connect(add3.y, washout.u) annotation(
    Line(points = {{-119, 0}, {-103, 0}}, color = {0, 0, 127}));
  connect(washout.y, feedback.u1) annotation(
    Line(points = {{-79, 0}, {-49, 0}}, color = {0, 0, 127}));
  connect(feedback.y, integrator1.u) annotation(
    Line(points = {{-31, 0}, {-3, 0}}, color = {0, 0, 127}));
  connect(integrator1.y, integrator2.u) annotation(
    Line(points = {{21, 0}, {57, 0}}, color = {0, 0, 127}));
  connect(integrator2.y, integrator3.u) annotation(
    Line(points = {{81, 0}, {117, 0}}, color = {0, 0, 127}));
  connect(integrator3.y, integrator4.u) annotation(
    Line(points = {{141, 0}, {177, 0}}, color = {0, 0, 127}));
  connect(feedback.y, sum1.u[5]) annotation(
    Line(points = {{-31, 0}, {-20, 0}, {-20, 60}, {220, 60}, {220, 0}, {238, 0}}, color = {0, 0, 127}));
  connect(integrator1.y, sum1.u[1]) annotation(
    Line(points = {{21, 0}, {40, 0}, {40, 60}, {220, 60}, {220, 0}, {238, 0}}, color = {0, 0, 127}));
  connect(integrator2.y, sum1.u[2]) annotation(
    Line(points = {{81, 0}, {100, 0}, {100, 60}, {220, 60}, {220, 0}, {238, 0}}, color = {0, 0, 127}));
  connect(integrator3.y, sum1.u[3]) annotation(
    Line(points = {{141, 0}, {160, 0}, {160, 60}, {220, 60}, {220, 0}, {238, 0}}, color = {0, 0, 127}));
  connect(integrator4.y, sum1.u[4]) annotation(
    Line(points = {{201, 0}, {238, 0}}, color = {0, 0, 127}));
  connect(integrator1.y, sum2.u[1]) annotation(
    Line(points = {{21, 0}, {40, 0}, {40, -60}, {21, -60}}, color = {0, 0, 127}));
  connect(integrator2.y, sum2.u[2]) annotation(
    Line(points = {{81, 0}, {100, 0}, {100, -60}, {21, -60}}, color = {0, 0, 127}));
  connect(integrator3.y, sum2.u[3]) annotation(
    Line(points = {{141, 0}, {160, 0}, {160, -60}, {21, -60}}, color = {0, 0, 127}));
  connect(integrator4.y, sum2.u[4]) annotation(
    Line(points = {{201, 0}, {220, 0}, {220, -60}, {21, -60}}, color = {0, 0, 127}));
  connect(sum2.y, feedback.u2) annotation(
    Line(points = {{-1, -60}, {-40, -60}, {-40, -8}}, color = {0, 0, 127}));
  connect(sum1.y, gain1.u) annotation(
    Line(points = {{261, 0}, {278, 0}}, color = {0, 0, 127}));
  connect(gain1.y, limiter2.u) annotation(
    Line(points = {{301, 0}, {318, 0}}, color = {0, 0, 127}));
  connect(gain.y, hysteresis.u) annotation(
    Line(points = {{-338, 60}, {-320, 60}, {-320, 0}, {-302, 0}}, color = {0, 0, 127}));
  connect(hysteresis.y, switch.u2) annotation(
    Line(points = {{-279, 0}, {-260, 0}, {-260, -40}, {378, -40}}, color = {255, 0, 255}));
  connect(limiter2.y, switch.u1) annotation(
    Line(points = {{342, 0}, {360, 0}, {360, -32}, {378, -32}}, color = {0, 0, 127}));
  connect(const.y, switch.u3) annotation(
    Line(points = {{342, -80}, {360, -80}, {360, -48}, {378, -48}}, color = {0, 0, 127}));
  connect(switch.y, VPssPu) annotation(
    Line(points = {{402, -40}, {430, -40}}, color = {0, 0, 127}));
  connect(omegaPu, add.u1) annotation(
    Line(points = {{-400, -40}, {-360, -40}, {-360, -54}, {-342, -54}}, color = {0, 0, 127}));
  connect(omegaRefPu, add.u2) annotation(
    Line(points = {{-400, -80}, {-360, -80}, {-360, -66}, {-342, -66}}, color = {0, 0, 127}));
  connect(add.y, limiter1.u) annotation(
    Line(points = {{-318, -60}, {-302, -60}}, color = {0, 0, 127}));

  annotation(
    preferredView = "diagram",
    Diagram(coordinateSystem(extent = {{-380, -200}, {420, 200}})));
end Pss6c;
