within Dynawo.Electrical.Controls.Machines.PowerSystemStabilizers.Standard;

/*
* Copyright (c) 2024, RTE (http://www.rte-france.com)
* See AUTHORS.txt
* All rights reserved.
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this
* file, you can obtain one at http://mozilla.org/MPL/2.0/.
* SPDX-License-Identifier: MPL-2.0
*
* This file is part of Dynawo, an hybrid C++/Modelica open source suite
* of simulation tools for power systems.
*/

model Pss6c "IEEE power system stabilizer type 6C"

  //Regulation parameters
  parameter Types.PerUnit KOmega "Coefficient applied to angular frequency";
  parameter Types.PerUnit KOmegaRef "Coefficient applied to reference angular frequency";
  parameter Types.PerUnit K0 "Gain of first integrator input";
  parameter Types.PerUnit K1 "Gain of first integrator output";
  parameter Types.PerUnit K2 "Gain of second integrator output";
  parameter Types.PerUnit K3 "Gain of third integrator output";
  parameter Types.PerUnit K4 "Gain of fourth integrator output";
  parameter Types.PerUnit Ki3 "Gain of third integrator";
  parameter Types.PerUnit Ki4 "Gain of fourth integrator";
  parameter Types.PerUnit Ks "Gain of power system stabilizer";
  parameter Types.PerUnit Ks1 "Gain of active power branch";
  parameter Types.PerUnit Ks2 "Gain of angular frequency branch";
  parameter Types.PerUnit MAcc "Gain of angular velocity";
  parameter Types.AngularVelocityPu OmegaMaxPu "Maximum angular velocity in pu (base omegaNom)";
  parameter Types.AngularVelocityPu OmegaMinPu "Minimum angular velocity in pu (base omegaNom)";
  parameter Types.ActivePowerPu PGenMaxPu "Maximum active power in pu (base SNom) (generator convention)";
  parameter Types.ActivePowerPu PGenMinPu "Minimum active power in pu (base SNom) (generator convention)";
  parameter Types.ActivePowerPu PPssOffPu "Lower active power threshold for PSS activation in pu (base SNom) (generator convention)";
  parameter Types.ActivePowerPu PPssOnPu "Higher active power threshold for PSS activation in pu (base SNom) (generator convention)";
  parameter Types.Time t1 "Transducer time constant (active power branch) in s";
  parameter Types.Time t2 "Transducer time constant (angular frequency branch) in s";
  parameter Types.Time t3 "First order time constant (active power branch) in s";
  parameter Types.Time t4 "Derivative time constant (angular frequency branch) in s";
  parameter Types.Time tD "Washout time constant in s";
  parameter Types.Time tI1 "Time constant of first integrator, in s";
  parameter Types.Time tI2 "Time constant of second integrator, in s";
  parameter Types.Time tI3 "Time constant of third integrator, in s";
  parameter Types.Time tI4 "Time constant of fourth integrator, in s";
  parameter Types.VoltageModulePu VPssMaxPu "Maximum output voltage of power system stabilizer in pu (base UNom)";
  parameter Types.VoltageModulePu VPssMinPu "Minimum output voltage of power system stabilizer in pu (base UNom)";

  //Generator parameter
  parameter Types.ApparentPowerModule SNom "Nominal apparent power in MVA";

  //Input variables
  Modelica.Blocks.Interfaces.RealInput omegaPu(start = SystemBase.omega0Pu) "Angular frequency in pu (base omegaNom)" annotation(
    Placement(visible = true, transformation(origin = {-420, -40}, extent = {{-20, -20}, {20, 20}}, rotation = 0), iconTransformation(origin = {-120, 0}, extent = {{-20, -20}, {20, 20}}, rotation = 0)));
  Modelica.Blocks.Interfaces.RealInput omegaRefPu(start = SystemBase.omegaRef0Pu) "Reference angular frequency in pu (base omegaNom)" annotation(
    Placement(visible = true, transformation(origin = {-420, -80}, extent = {{-20, -20}, {20, 20}}, rotation = 0), iconTransformation(origin = {-120, -60}, extent = {{-20, -20}, {20, 20}}, rotation = 0)));
  Modelica.Blocks.Interfaces.RealInput PGenPu(start = PGen0Pu) "Active power generated by the synchronous machine in pu (base SnRef) (generator convention)" annotation(
    Placement(visible = true, transformation(origin = {-420, 60}, extent = {{-20, -20}, {20, 20}}, rotation = 0), iconTransformation(origin = {-120, 60}, extent = {{-20, -20}, {20, 20}}, rotation = 0)));

  //Output variable
  Modelica.Blocks.Interfaces.RealOutput VPssPu(start = 0) "Output voltage of power system stabilizer in pu (base UNom)" annotation(
    Placement(visible = true, transformation(origin = {410, -40}, extent = {{-10, -10}, {10, 10}}, rotation = 0), iconTransformation(origin = {110, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));

  Modelica.Blocks.Math.Gain gain(k = SystemBase.SnRef / SNom) annotation(
    Placement(visible = true, transformation(origin = {-370, 60}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Nonlinear.Limiter limiter(homotopyType = Modelica.Blocks.Types.LimiterHomotopy.NoHomotopy, uMax = PGenMaxPu, uMin = PGenMinPu) annotation(
    Placement(visible = true, transformation(origin = {-310, 60}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Nonlinear.Limiter limiter1(homotopyType = Modelica.Blocks.Types.LimiterHomotopy.NoHomotopy, uMax = OmegaMaxPu, uMin = OmegaMinPu) annotation(
    Placement(visible = true, transformation(origin = {-310, -60}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Continuous.FirstOrder firstOrder(T = t1, y_start = PGen0Pu * SystemBase.SnRef / SNom) annotation(
    Placement(visible = true, transformation(origin = {-270, 60}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Continuous.FirstOrder firstOrder1(T = t3, k = Ks1, y_start = Ks1 * PGen0Pu * SystemBase.SnRef / SNom) annotation(
    Placement(visible = true, transformation(origin = {-210, 60}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Math.Add3 add3(k2 = -1) annotation(
    Placement(visible = true, transformation(origin = {-150, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Continuous.FirstOrder firstOrder2(T = t2, k = Ks2, y_start = Ks2 * (KOmega * SystemBase.omega0Pu + KOmegaRef * SystemBase.omegaRef0Pu)) annotation(
    Placement(visible = true, transformation(origin = {-270, -60}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Continuous.Derivative derivative(T = t4, k = MAcc, x_start = Ks2 * (KOmega * SystemBase.omega0Pu + KOmegaRef * SystemBase.omegaRef0Pu)) annotation(
    Placement(visible = true, transformation(origin = {-210, -60}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Dynawo.NonElectrical.Blocks.Continuous.Washout washout(tW = tD, U0 = (Ks1 - 1) * PGen0Pu * SystemBase.SnRef / SNom) annotation(
    Placement(visible = true, transformation(origin = {-110, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Math.Feedback feedback annotation(
    Placement(visible = true, transformation(origin = {-60, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Continuous.Integrator integrator1(k = 1 / tI1) annotation(
    Placement(visible = true, transformation(origin = {-10, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Continuous.Integrator integrator2(k = 1 / tI2) annotation(
    Placement(visible = true, transformation(origin = {50, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Continuous.Integrator integrator3(k = Ki3 / tI3) annotation(
    Placement(visible = true, transformation(origin = {110, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Continuous.Integrator integrator4(k = Ki4 / tI4) annotation(
    Placement(visible = true, transformation(origin = {170, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Math.Sum sum1(k = {K1, K2, K3, K4, K0}, nin = 5) annotation(
    Placement(visible = true, transformation(origin = {230, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Math.Gain gain1(k = Ks) annotation(
    Placement(visible = true, transformation(origin = {270, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Math.Sum sum2(nin = 4) annotation(
    Placement(visible = true, transformation(origin = {-10, -60}, extent = {{10, -10}, {-10, 10}}, rotation = 0)));
  Modelica.Blocks.Nonlinear.Limiter limiter2(homotopyType = Modelica.Blocks.Types.LimiterHomotopy.NoHomotopy, uMax = VPssMaxPu, uMin = VPssMinPu) annotation(
    Placement(visible = true, transformation(origin = {310, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Logical.Hysteresis hysteresis(uHigh = PPssOnPu, uLow = PPssOffPu, y(start = PGen0Pu * SystemBase.SnRef / SNom > PPssOffPu)) annotation(
    Placement(visible = true, transformation(origin = {-310, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Sources.Constant const(k = 0) annotation(
    Placement(visible = true, transformation(origin = {310, -80}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Logical.Switch switch annotation(
    Placement(visible = true, transformation(origin = {370, -40}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Math.Add add(k1 = KOmega, k2 = KOmegaRef) annotation(
    Placement(visible = true, transformation(origin = {-350, -60}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));

  //Generator initial parameter
  parameter Types.ActivePowerPu PGen0Pu "Initial active power in pu (base SnRef) (generator convention)";

equation
  connect(PGenPu, gain.u) annotation(
    Line(points = {{-420, 60}, {-382, 60}}, color = {0, 0, 127}));
  connect(gain.y, limiter.u) annotation(
    Line(points = {{-359, 60}, {-323, 60}}, color = {0, 0, 127}));
  connect(limiter.y, firstOrder.u) annotation(
    Line(points = {{-299, 60}, {-283, 60}}, color = {0, 0, 127}));
  connect(firstOrder.y, firstOrder1.u) annotation(
    Line(points = {{-259, 60}, {-223, 60}}, color = {0, 0, 127}));
  connect(firstOrder1.y, add3.u1) annotation(
    Line(points = {{-199, 60}, {-180, 60}, {-180, 8}, {-163, 8}}, color = {0, 0, 127}));
  connect(firstOrder.y, add3.u2) annotation(
    Line(points = {{-259, 60}, {-240, 60}, {-240, 0}, {-163, 0}}, color = {0, 0, 127}));
  connect(limiter1.y, firstOrder2.u) annotation(
    Line(points = {{-299, -60}, {-283, -60}}, color = {0, 0, 127}));
  connect(firstOrder2.y, derivative.u) annotation(
    Line(points = {{-259, -60}, {-223, -60}}, color = {0, 0, 127}));
  connect(derivative.y, add3.u3) annotation(
    Line(points = {{-199, -60}, {-180, -60}, {-180, -8}, {-163, -8}}, color = {0, 0, 127}));
  connect(add3.y, washout.u) annotation(
    Line(points = {{-139, 0}, {-123, 0}}, color = {0, 0, 127}));
  connect(washout.y, feedback.u1) annotation(
    Line(points = {{-99.2, 0}, {-69.2, 0}}, color = {0, 0, 127}));
  connect(feedback.y, integrator1.u) annotation(
    Line(points = {{-51, 0}, {-23, 0}}, color = {0, 0, 127}));
  connect(integrator1.y, integrator2.u) annotation(
    Line(points = {{1, 0}, {37, 0}}, color = {0, 0, 127}));
  connect(integrator2.y, integrator3.u) annotation(
    Line(points = {{61, 0}, {97, 0}}, color = {0, 0, 127}));
  connect(integrator3.y, integrator4.u) annotation(
    Line(points = {{121, 0}, {157, 0}}, color = {0, 0, 127}));
  connect(feedback.y, sum1.u[5]) annotation(
    Line(points = {{-51, 0}, {-40, 0}, {-40, 60}, {200, 60}, {200, 0}, {218, 0}}, color = {0, 0, 127}));
  connect(integrator1.y, sum1.u[1]) annotation(
    Line(points = {{1, 0}, {20, 0}, {20, 60}, {200, 60}, {200, 0}, {218, 0}}, color = {0, 0, 127}));
  connect(integrator2.y, sum1.u[2]) annotation(
    Line(points = {{61, 0}, {80, 0}, {80, 60}, {200, 60}, {200, 0}, {218, 0}}, color = {0, 0, 127}));
  connect(integrator3.y, sum1.u[3]) annotation(
    Line(points = {{121, 0}, {140, 0}, {140, 60}, {200, 60}, {200, 0}, {218, 0}}, color = {0, 0, 127}));
  connect(integrator4.y, sum1.u[4]) annotation(
    Line(points = {{181, 0}, {218, 0}}, color = {0, 0, 127}));
  connect(integrator1.y, sum2.u[1]) annotation(
    Line(points = {{1, 0}, {20, 0}, {20, -60}, {1, -60}}, color = {0, 0, 127}));
  connect(integrator2.y, sum2.u[2]) annotation(
    Line(points = {{61, 0}, {80, 0}, {80, -60}, {1, -60}}, color = {0, 0, 127}));
  connect(integrator3.y, sum2.u[3]) annotation(
    Line(points = {{121, 0}, {140, 0}, {140, -60}, {1, -60}}, color = {0, 0, 127}));
  connect(integrator4.y, sum2.u[4]) annotation(
    Line(points = {{181, 0}, {200, 0}, {200, -60}, {1, -60}}, color = {0, 0, 127}));
  connect(sum2.y, feedback.u2) annotation(
    Line(points = {{-21, -60}, {-60, -60}, {-60, -8}}, color = {0, 0, 127}));
  connect(sum1.y, gain1.u) annotation(
    Line(points = {{241, 0}, {258, 0}}, color = {0, 0, 127}));
  connect(gain1.y, limiter2.u) annotation(
    Line(points = {{281, 0}, {298, 0}}, color = {0, 0, 127}));
  connect(gain.y, hysteresis.u) annotation(
    Line(points = {{-359, 60}, {-340, 60}, {-340, 0}, {-323, 0}}, color = {0, 0, 127}));
  connect(hysteresis.y, switch.u2) annotation(
    Line(points = {{-299, 0}, {-280, 0}, {-280, -40}, {358, -40}}, color = {255, 0, 255}));
  connect(limiter2.y, switch.u1) annotation(
    Line(points = {{321, 0}, {340, 0}, {340, -32}, {357, -32}}, color = {0, 0, 127}));
  connect(const.y, switch.u3) annotation(
    Line(points = {{321, -80}, {340, -80}, {340, -48}, {357, -48}}, color = {0, 0, 127}));
  connect(switch.y, VPssPu) annotation(
    Line(points = {{381, -40}, {409, -40}}, color = {0, 0, 127}));
  connect(omegaPu, add.u1) annotation(
    Line(points = {{-420, -40}, {-380, -40}, {-380, -54}, {-362, -54}}, color = {0, 0, 127}));
  connect(omegaRefPu, add.u2) annotation(
    Line(points = {{-420, -80}, {-380, -80}, {-380, -66}, {-362, -66}}, color = {0, 0, 127}));
  connect(add.y, limiter1.u) annotation(
    Line(points = {{-339, -60}, {-323, -60}}, color = {0, 0, 127}));

  annotation(
    preferredView = "diagram",
    Diagram(coordinateSystem(extent = {{-400, -200}, {400, 200}})));
end Pss6c;
