within Dynawo.Electrical.Controls.Machines.UnderExcitationLimiters.Standard;

/*
* Copyright (c) 2024, RTE (http://www.rte-france.com)
* See AUTHORS.txt
* All rights reserved.
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this
* file, you can obtain one at http://mozilla.org/MPL/2.0/.
* SPDX-License-Identifier: MPL-2.0
*
* This file is part of Dynawo, an hybrid C++/Modelica open source suite
* of simulation tools for power systems.
*/

model Uel2c "IEEE (2016) overexcitation limiter type UEL2C model"

  //Regulation parameters
  parameter Types.PerUnit K1 "Voltage exponent for active power input to UEL table";
  parameter Types.PerUnit K2 "Voltage exponent for reactive power output of UEL table";
  parameter Types.PerUnit KFb "UEL gain of reference voltage from ST7C";
  parameter Types.PerUnit KFix "UEL fixed gain reduction factor";
  parameter Types.PerUnit Kuf "UEL excitation system stabilizer gain";
  parameter Types.PerUnit Kui "UEL integral gain";
  parameter Types.PerUnit Kul "UEL proportional gain";
  parameter Boolean Sw1 "UEL logic switch for adjustable gain reduction";
  parameter Types.Time tAdj "UEL adjustable gain reduction time constant in s";
  parameter Types.Time tQRef "UEL reactive power reference time constant in s";
  parameter Types.Time tU1 "UEL first lead time constant in s";
  parameter Types.Time tU2 "UEL first lag time constant in s";
  parameter Types.Time tU3 "UEL second lead time constant in s";
  parameter Types.Time tU4 "UEL second lag time constant in s";
  parameter Types.Time tUl "UEL time constant of filter for reference voltage from ST7C, in s";
  parameter Types.Time tUP "UEL active power filter time constant in s";
  parameter Types.Time tUQ "UEL reactive power filter time constant in s";
  parameter Types.Time tUV "UEL voltage filter time constant in s";
  parameter Types.VoltageModulePu VBiasPu "UEL voltage bias in pu (base UNom)";
  parameter Types.VoltageModulePu VUel1MaxPu "UEL maximum output in pu (base UNom)";
  parameter Types.VoltageModulePu VUel1MinPu "UEL minimum output in pu (base UNom)";
  parameter Types.VoltageModulePu VUel2MaxPu "UEL maximum output in pu (base UNom)";
  parameter Types.VoltageModulePu VUel2MinPu "UEL minimum output in pu (base UNom)";
  parameter Types.VoltageModulePu VUiMaxPu "UEL PI control maximum output in pu (base UNom)";
  parameter Types.VoltageModulePu VUiMinPu "UEL PI control minimum output in pu (base UNom)";
  parameter Types.PerUnit XqPu "UEL characteristic reactance in pu (base SnRef, UNom)";

  //Table parameters
  parameter String FPQTableName "Name of table in text file for the reactive power as a function of active power";
  parameter String TablesFile "Text file that contains the table for the fpq function";

  //Input variables
  Modelica.Blocks.Interfaces.RealInput PGenPu(start = PGen0Pu) "Active power generated by the synchronous machine in pu (base SnRef) (generator convention)" annotation(
    Placement(visible = true, transformation(origin = {-440, 40}, extent = {{-20, -20}, {20, 20}}, rotation = 0), iconTransformation(extent = {{-140, 20}, {-100, 60}}, rotation = 0)));
  Modelica.Blocks.Interfaces.RealInput QGenPu(start = QGen0Pu) "Reactive power generated by the synchronous machine in pu (base SnRef) (generator convention)" annotation(
    Placement(visible = true, transformation(origin = {-440, 140}, extent = {{-20, -20}, {20, 20}}, rotation = 0), iconTransformation(extent = {{-140, -20}, {-100, 20}}, rotation = 0)));
  Modelica.ComplexBlocks.Interfaces.ComplexInput utPu(re(start = ut0Pu.re), im(start = ut0Pu.im)) "Complex stator voltage in pu (base UNom)" annotation(
    Placement(visible = true, transformation(origin = {-440, -80}, extent = {{-20, -20}, {20, 20}}, rotation = 0), iconTransformation(origin = {120, -80}, extent = {{-20, -20}, {20, 20}}, rotation = 180)));
  Modelica.Blocks.Interfaces.RealInput VFbPu(start = UsRef0Pu) "Reference voltage from ST7C in pu (base UNom)" annotation(
    Placement(visible = true, transformation(origin = {-440, -160}, extent = {{-20, -20}, {20, 20}}, rotation = 0), iconTransformation(origin = {-120, 100}, extent = {{-20, -20}, {20, 20}}, rotation = 0)));
  Modelica.Blocks.Interfaces.RealInput VfPu(start = (QRef0Pu - QGen0Pu) / Kuf) "Input stabilizer signal" annotation(
    Placement(visible = true, transformation(origin = {-440, 80}, extent = {{-20, -20}, {20, 20}}, rotation = 0), iconTransformation(origin = {-120, 100}, extent = {{-20, -20}, {20, 20}}, rotation = 0)));

  //Output variable
  Modelica.Blocks.Interfaces.RealOutput UUelPu(start = 0) "Underexcitation limitation output voltage in pu (base UNom)" annotation(
    Placement(visible = true, transformation(origin = {430, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0), iconTransformation(origin = {110, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));

  Types.PerUnit kAdj "UEL adjustable gain";
  Types.VoltageModulePu UPu "Voltage amplitude at terminal in pu (base UNom)";

  Modelica.Blocks.Continuous.FirstOrder firstOrder(T = tUV, y_start = U0Pu) annotation(
    Placement(visible = true, transformation(origin = {-350, -74}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Math.MultiSwitch multiSwitch1(expr = firstOrder.y * {1, 1 / VBiasPu}, nu = 2, y_default = 1) annotation(
    Placement(visible = true, transformation(origin = {-230, -80}, extent = {{-10, -10}, {30, 10}}, rotation = 0)));
  Dynawo.NonElectrical.Blocks.Complex.ComplexToPolar complexToPolar annotation(
    Placement(visible = true, transformation(origin = {-390, -80}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Logical.GreaterThreshold greaterThreshold(threshold = 1) annotation(
    Placement(visible = true, transformation(origin = {-290, -40}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Logical.LessEqualThreshold lessEqualThreshold(threshold = VBiasPu) annotation(
    Placement(visible = true, transformation(origin = {-290, -80}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Dynawo.NonElectrical.Blocks.Continuous.Power power(N = K2, NInteger = true) annotation(
    Placement(visible = true, transformation(origin = {-150, -80}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Dynawo.NonElectrical.Blocks.Continuous.Power power1(N = K1, NInteger = true) annotation(
    Placement(visible = true, transformation(origin = {-150, -40}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Math.Division division annotation(
    Placement(visible = true, transformation(origin = {-90, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Continuous.FirstOrder firstOrder1(T = tUP, y_start = PGen0Pu / (VBias0Pu ^ K1)) annotation(
    Placement(visible = true, transformation(origin = {-50, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Tables.CombiTable1Ds combiTable1Ds(fileName = TablesFile, tableName = FPQTableName, tableOnFile = true) annotation(
    Placement(visible = true, transformation(origin = {-10, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Math.Product product1 annotation(
    Placement(visible = true, transformation(origin = {50, -20}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Continuous.FirstOrder firstOrder2(T = tQRef, y_start = QRef0Pu) annotation(
    Placement(visible = true, transformation(origin = {90, -20}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Math.Gain gain(k = Kuf) annotation(
    Placement(visible = true, transformation(origin = {90, 80}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Math.Add3 add3(k1 = -1, k2 = -1) annotation(
    Placement(visible = true, transformation(origin = {150, 80}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Continuous.FirstOrder firstOrder3(T = tUQ, y_start = QGen0Pu) annotation(
    Placement(visible = true, transformation(origin = {90, 140}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Math.Product product2 annotation(
    Placement(visible = true, transformation(origin = {210, 40}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Logical.Switch switch annotation(
    Placement(visible = true, transformation(origin = {150, -100}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Sources.Constant const(k = KFix) annotation(
    Placement(visible = true, transformation(origin = {90, -60}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Dynawo.NonElectrical.Blocks.NonLinear.LimitedFirstOrder limitedFirstOrder(Y0 = KAdj0, YMax = 1, YMin = 0.1, tFilter = tAdj) annotation(
    Placement(visible = true, transformation(origin = {90, -140}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Sources.BooleanConstant booleanConstant(k = Sw1) annotation(
    Placement(visible = true, transformation(origin = {90, -100}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Sources.RealExpression realExpression(y = kAdj) annotation(
    Placement(visible = true, transformation(origin = {50, -140}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Dynawo.NonElectrical.Blocks.Continuous.LimitedPI limitedPI(Ki = Kui, Kp = Kul, Y0 = -KFb * UsRef0Pu, YMax = VUiMaxPu, YMin = VUiMinPu) annotation(
    Placement(visible = true, transformation(origin = {250, 40}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Dynawo.NonElectrical.Blocks.NonLinear.LimitedLeadLag limitedLeadLag(YMax = VUel2MaxPu, YMin = VUel2MinPu, t1 = tU1, t2 = tU2) annotation(
    Placement(visible = true, transformation(origin = {350, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Dynawo.NonElectrical.Blocks.NonLinear.LimitedLeadLag limitedLeadLag1(YMax = VUel1MaxPu, YMin = VUel1MinPu, t1 = tU3, t2 = tU4) annotation(
    Placement(visible = true, transformation(origin = {390, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Math.Add add annotation(
    Placement(visible = true, transformation(origin = {310, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Continuous.FirstOrder firstOrder4(T = tUl, k = KFb, y_start = KFb * UsRef0Pu) annotation(
    Placement(visible = true, transformation(origin = {-50, -160}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));

  //Generator initial parameters
  parameter Types.ActivePowerPu PGen0Pu "Initial active power in pu (base SnRef) (generator convention)";
  parameter Types.ReactivePowerPu QGen0Pu "Initial reactive power in pu (base SnRef) (generator convention)";
  parameter Types.ReactivePowerPu QRef0Pu "Initial reference reactive power in pu (base SnRef) (generator convention)";
  parameter Types.VoltageModulePu U0Pu "Initial voltage amplitude at terminal in pu (base UNom)";
  parameter Types.ComplexVoltagePu ut0Pu "Initial complex stator voltage in pu (base UNom)";

  //Initial parameters (calculated by the initialization model)
  parameter Types.VoltageModulePu UsRef0Pu "Initial reference stator voltage in pu (base UNom)";
  parameter Types.VoltageModulePu VBias0Pu "Initial calculated voltage bias in pu (base UNom)";

  final parameter Types.PerUnit KAdj0 = ((U0Pu ^ 2) / XqPu + QGen0Pu) / sqrt(((U0Pu ^ 2) / XqPu + QGen0Pu) ^ 2 + PGen0Pu ^ 2) "Initial UEL adjustable gain";

equation
  kAdj = ((UPu ^ 2) / XqPu + QGenPu) / sqrt(((UPu ^ 2) / XqPu + QGenPu) ^ 2 + PGenPu ^ 2);
  UPu = complexToPolar.len;

  connect(utPu, complexToPolar.u) annotation(
    Line(points = {{-440, -80}, {-402, -80}}, color = {85, 170, 255}));
  connect(complexToPolar.len, firstOrder.u) annotation(
    Line(points = {{-378, -74}, {-362, -74}}, color = {0, 0, 127}));
  connect(firstOrder.y, lessEqualThreshold.u) annotation(
    Line(points = {{-339, -74}, {-320, -74}, {-320, -80}, {-303, -80}}, color = {0, 0, 127}));
  connect(firstOrder.y, greaterThreshold.u) annotation(
    Line(points = {{-339, -74}, {-320, -74}, {-320, -40}, {-303, -40}}, color = {0, 0, 127}));
  connect(lessEqualThreshold.y, multiSwitch1.u[2]) annotation(
    Line(points = {{-279, -80}, {-241, -80}}, color = {255, 0, 255}));
  connect(greaterThreshold.y, multiSwitch1.u[1]) annotation(
    Line(points = {{-279, -40}, {-260, -40}, {-260, -80}, {-241, -80}}, color = {255, 0, 255}));
  connect(limitedLeadLag.y, limitedLeadLag1.u) annotation(
    Line(points = {{361, 0}, {377, 0}}, color = {0, 0, 127}));
  connect(multiSwitch1.y, power.u) annotation(
    Line(points = {{-199, -80}, {-162, -80}}, color = {0, 0, 127}));
  connect(multiSwitch1.y, power1.u) annotation(
    Line(points = {{-199, -80}, {-180, -80}, {-180, -40}, {-162, -40}}, color = {0, 0, 127}));
  connect(power1.y, division.u2) annotation(
    Line(points = {{-139, -40}, {-120, -40}, {-120, -6}, {-102, -6}}, color = {0, 0, 127}));
  connect(PGenPu, division.u1) annotation(
    Line(points = {{-440, 40}, {-120, 40}, {-120, 6}, {-102, 6}}, color = {0, 0, 127}));
  connect(division.y, firstOrder1.u) annotation(
    Line(points = {{-79, 0}, {-62, 0}}, color = {0, 0, 127}));
  connect(firstOrder1.y, combiTable1Ds.u) annotation(
    Line(points = {{-39, 0}, {-23, 0}}, color = {0, 0, 127}));
  connect(product1.y, firstOrder2.u) annotation(
    Line(points = {{62, -20}, {78, -20}}, color = {0, 0, 127}));
  connect(firstOrder2.y, add3.u3) annotation(
    Line(points = {{102, -20}, {120, -20}, {120, 72}, {138, 72}}, color = {0, 0, 127}));
  connect(gain.y, add3.u2) annotation(
    Line(points = {{102, 80}, {138, 80}}, color = {0, 0, 127}));
  connect(firstOrder3.y, add3.u1) annotation(
    Line(points = {{102, 140}, {120, 140}, {120, 88}, {138, 88}}, color = {0, 0, 127}));
  connect(VfPu, gain.u) annotation(
    Line(points = {{-440, 80}, {78, 80}}, color = {0, 0, 127}));
  connect(QGenPu, firstOrder3.u) annotation(
    Line(points = {{-440, 140}, {78, 140}}, color = {0, 0, 127}));
  connect(add3.y, product2.u1) annotation(
    Line(points = {{162, 80}, {180, 80}, {180, 46}, {198, 46}}, color = {0, 0, 127}));
  connect(switch.y, product2.u2) annotation(
    Line(points = {{162, -100}, {180, -100}, {180, 34}, {198, 34}}, color = {0, 0, 127}));
  connect(const.y, switch.u1) annotation(
    Line(points = {{102, -60}, {120, -60}, {120, -92}, {138, -92}}, color = {0, 0, 127}));
  connect(booleanConstant.y, switch.u2) annotation(
    Line(points = {{102, -100}, {138, -100}}, color = {255, 0, 255}));
  connect(limitedFirstOrder.y, switch.u3) annotation(
    Line(points = {{102, -140}, {120, -140}, {120, -108}, {138, -108}}, color = {0, 0, 127}));
  connect(realExpression.y, limitedFirstOrder.u) annotation(
    Line(points = {{62, -140}, {78, -140}}, color = {0, 0, 127}));
  connect(product2.y, limitedPI.u) annotation(
    Line(points = {{221, 40}, {237, 40}}, color = {0, 0, 127}));
  connect(limitedPI.y, add.u1) annotation(
    Line(points = {{262, 40}, {280, 40}, {280, 6}, {298, 6}}, color = {0, 0, 127}));
  connect(add.y, limitedLeadLag.u) annotation(
    Line(points = {{322, 0}, {338, 0}}, color = {0, 0, 127}));
  connect(limitedLeadLag1.y, UUelPu) annotation(
    Line(points = {{402, 0}, {430, 0}}, color = {0, 0, 127}));
  connect(VFbPu, firstOrder4.u) annotation(
    Line(points = {{-440, -160}, {-62, -160}}, color = {0, 0, 127}));
  connect(firstOrder4.y, add.u2) annotation(
    Line(points = {{-38, -160}, {280, -160}, {280, -6}, {298, -6}}, color = {0, 0, 127}));
  connect(combiTable1Ds.y[1], product1.u1) annotation(
    Line(points = {{1, 0}, {20, 0}, {20, -14}, {38, -14}}, color = {0, 0, 127}));
  connect(power.y, product1.u2) annotation(
    Line(points = {{-138, -80}, {20, -80}, {20, -26}, {38, -26}}, color = {0, 0, 127}));

  annotation(
    preferredView = "diagram",
    Diagram(coordinateSystem(extent = {{-420, -200}, {420, 200}})));
end Uel2c;
