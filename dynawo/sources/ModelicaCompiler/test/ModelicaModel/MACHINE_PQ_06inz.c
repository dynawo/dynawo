//
// Copyright (c) 2015-2019, RTE (http://www.rte-france.com)
// See AUTHORS.txt
// All rights reserved.
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, you can obtain one at http://mozilla.org/MPL/2.0/.
// SPDX-License-Identifier: MPL-2.0
//
// This file is part of Dynawo, an hybrid C++/Modelica open source time domain
// simulation tool for power systems.
//

/* Initialization */
/* Simulation code for MACHINE_PQ generated by the OpenModelica Compiler OMCompiler v1.9.4. */

#include "openmodelica.h"
#include "openmodelica_func.h"
#include "simulation_data.h"
#include "simulation/simulation_info_json.h"
#include "simulation/simulation_runtime.h"
#include "util/omc_error.h"
#include "simulation/solver/model_help.h"
#include "simulation/solver/delay.h"
#include "simulation/solver/linearSystem.h"
#include "simulation/solver/nonlinearSystem.h"
#include "simulation/solver/mixedSystem.h"

#include <string.h>

#include "MACHINE_PQ_functions.h"
#include "MACHINE_PQ_model.h"
#include "MACHINE_PQ_literals.h"




#if defined(HPCOM) && !defined(_OPENMP)
  #error "HPCOM requires OpenMP or the results are wrong"
#endif
#if defined(_OPENMP)
  #include <omp.h>
#else
  /* dummy omp defines */
  #define omp_get_max_threads() 1
#endif
#include "MACHINE_PQ_11mix.h"
#include "MACHINE_PQ_12jac.h"
#if defined(__cplusplus)
extern "C" {
#endif


/*
 equation index: 1
 type: SIMPLE_ASSIGN
 $PRE._MACHINE._switchOffSignal3._value = $_start(MACHINE.switchOffSignal3.value)
 */
void MACHINE_PQ_eqFunction_1(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,1};
  $P$PRE$PMACHINE$PswitchOffSignal3$Pvalue = $P$ATTRIBUTE$PMACHINE$PswitchOffSignal3$Pvalue.start;
  TRACE_POP
}
/*
 equation index: 2
 type: SIMPLE_ASSIGN
 $PRE._MACHINE._switchOffSignal2._value = $_start(MACHINE.switchOffSignal2.value)
 */
void MACHINE_PQ_eqFunction_2(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,2};
  $P$PRE$PMACHINE$PswitchOffSignal2$Pvalue = $P$ATTRIBUTE$PMACHINE$PswitchOffSignal2$Pvalue.start;
  TRACE_POP
}
/*
 equation index: 3
 type: SIMPLE_ASSIGN
 $PRE._MACHINE._qStatus = $_start(MACHINE.qStatus)
 */
void MACHINE_PQ_eqFunction_3(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,3};
  $P$PRE$PMACHINE$PqStatus = $P$ATTRIBUTE$PMACHINE$PqStatus.start;
  TRACE_POP
}
/*
 equation index: 4
 type: SIMPLE_ASSIGN
 $PRE._MACHINE._pStatus = $_start(MACHINE.pStatus)
 */
void MACHINE_PQ_eqFunction_4(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,4};
  $P$PRE$PMACHINE$PpStatus = $P$ATTRIBUTE$PMACHINE$PpStatus.start;
  TRACE_POP
}
/*
 equation index: 5
 type: SIMPLE_ASSIGN
 MACHINE._omegaRefPu._value = $_start(MACHINE.omegaRefPu.value)
 */
void MACHINE_PQ_eqFunction_5(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,5};
  $PMACHINE$PomegaRefPu$Pvalue = $P$ATTRIBUTE$PMACHINE$PomegaRefPu$Pvalue.start;
  TRACE_POP
}
/*
 equation index: 6
 type: SIMPLE_ASSIGN
 MACHINE._terminal._V._im = $_start(MACHINE.terminal.V.im)
 */
void MACHINE_PQ_eqFunction_6(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,6};
  $PMACHINE$Pterminal$PV$Pim = $P$ATTRIBUTE$PMACHINE$Pterminal$PV$Pim.start;
  TRACE_POP
}
/*
 equation index: 7
 type: SIMPLE_ASSIGN
 MACHINE._terminal._V._re = $_start(MACHINE.terminal.V.re)
 */
void MACHINE_PQ_eqFunction_7(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7};
  $PMACHINE$Pterminal$PV$Pre = $P$ATTRIBUTE$PMACHINE$Pterminal$PV$Pre.start;
  TRACE_POP
}
/*
 equation index: 8
 type: SIMPLE_ASSIGN
 $PRE._MACHINE._running._value = $_start(MACHINE.running.value)
 */
void MACHINE_PQ_eqFunction_8(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,8};
  $P$PRE$PMACHINE$Prunning$Pvalue = $P$ATTRIBUTE$PMACHINE$Prunning$Pvalue.start;
  TRACE_POP
}
/*
 equation index: 9
 type: SIMPLE_ASSIGN
 $PRE._MACHINE._switchOffSignal1._value = $_start(MACHINE.switchOffSignal1.value)
 */
void MACHINE_PQ_eqFunction_9(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,9};
  $P$PRE$PMACHINE$PswitchOffSignal1$Pvalue = $P$ATTRIBUTE$PMACHINE$PswitchOffSignal1$Pvalue.start;
  TRACE_POP
}
/*
 equation index: 10
 type: SIMPLE_ASSIGN
 MACHINE._UPu = (MACHINE.terminal.V.re ^ 2.0 + MACHINE.terminal.V.im ^ 2.0) ^ 0.5
 */
void MACHINE_PQ_eqFunction_10(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,10};
  modelica_real tmp0;
  modelica_real tmp1;
  modelica_real tmp2;
  tmp0 = $PMACHINE$Pterminal$PV$Pre;
  tmp1 = $PMACHINE$Pterminal$PV$Pim;
  $PMACHINE$PUPu = sqrt((tmp0 * tmp0) + (tmp1 * tmp1));
  TRACE_POP
}
/*
 equation index: 11
 type: SIMPLE_ASSIGN
 $whenCondition10 = MACHINE.UPu >= 0.0001 + MACHINE.UMaxPu and $PRE.MACHINE.qStatus <> Dynawo.Electrical.Machines.GeneratorPQ.QStatus.absorptionMax
 */
void MACHINE_PQ_eqFunction_11(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,11};
  modelica_boolean tmp3;
  tmp3 = GreaterEq($PMACHINE$PUPu,0.0001 + $PMACHINE$PUMaxPu);
  $P$whenCondition10 = (tmp3 && ((modelica_integer)$P$PRE$PMACHINE$PqStatus != 2));
  TRACE_POP
}
/*
 equation index: 12
 type: SIMPLE_ASSIGN
 $whenCondition9 = MACHINE.UPu <= -0.0001 + MACHINE.UMinPu and $PRE.MACHINE.qStatus <> Dynawo.Electrical.Machines.GeneratorPQ.QStatus.generationMax
 */
void MACHINE_PQ_eqFunction_12(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,12};
  modelica_boolean tmp5;
  tmp5 = LessEq($PMACHINE$PUPu,-0.0001 + $PMACHINE$PUMinPu);
  $P$whenCondition9 = (tmp5 && ((modelica_integer)$P$PRE$PMACHINE$PqStatus != 3));
  TRACE_POP
}
/*
 equation index: 13
 type: SIMPLE_ASSIGN
 $whenCondition8 = MACHINE.UPu < -0.0001 + MACHINE.UMaxPu and $PRE.MACHINE.qStatus == Dynawo.Electrical.Machines.GeneratorPQ.QStatus.absorptionMax or MACHINE.UPu > 0.0001 + MACHINE.UMinPu and $PRE.MACHINE.qStatus == Dynawo.Electrical.Machines.GeneratorPQ.QStatus.generationMax
 */
void MACHINE_PQ_eqFunction_13(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,13};
  modelica_boolean tmp7;
  modelica_boolean tmp9;
  tmp7 = Less($PMACHINE$PUPu,-0.0001 + $PMACHINE$PUMaxPu);
  tmp9 = Greater($PMACHINE$PUPu,0.0001 + $PMACHINE$PUMinPu);
  $P$whenCondition8 = ((tmp7 && ((modelica_integer)$P$PRE$PMACHINE$PqStatus == 2)) || (tmp9 && ((modelica_integer)$P$PRE$PMACHINE$PqStatus == 3)));
  TRACE_POP
}
/*
 equation index: 14
 type: SIMPLE_ASSIGN
 MACHINE._switchOffSignal1._value = $PRE.MACHINE.switchOffSignal1.value
 */
void MACHINE_PQ_eqFunction_14(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,14};
  $PMACHINE$PswitchOffSignal1$Pvalue = $P$PRE$PMACHINE$PswitchOffSignal1$Pvalue;
  TRACE_POP
}
/*
 equation index: 15
 type: SIMPLE_ASSIGN
 MACHINE._switchOffSignal2._value = $PRE.MACHINE.switchOffSignal2.value
 */
void MACHINE_PQ_eqFunction_15(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,15};
  $PMACHINE$PswitchOffSignal2$Pvalue = $P$PRE$PMACHINE$PswitchOffSignal2$Pvalue;
  TRACE_POP
}
/*
 equation index: 16
 type: SIMPLE_ASSIGN
 MACHINE._switchOffSignal3._value = $PRE.MACHINE.switchOffSignal3.value
 */
void MACHINE_PQ_eqFunction_16(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,16};
  $PMACHINE$PswitchOffSignal3$Pvalue = $P$PRE$PMACHINE$PswitchOffSignal3$Pvalue;
  TRACE_POP
}
/*
 equation index: 17
 type: SIMPLE_ASSIGN
 $whenCondition6 = MACHINE.switchOffSignal1.value or MACHINE.switchOffSignal2.value or MACHINE.switchOffSignal3.value and $PRE.MACHINE.running.value
 */
void MACHINE_PQ_eqFunction_17(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,17};
  $P$whenCondition6 = (($PMACHINE$PswitchOffSignal1$Pvalue || $PMACHINE$PswitchOffSignal2$Pvalue) || ($PMACHINE$PswitchOffSignal3$Pvalue && $P$PRE$PMACHINE$Prunning$Pvalue));
  TRACE_POP
}
/*
 equation index: 18
 type: SIMPLE_ASSIGN
 MACHINE._pStatus = $PRE.MACHINE.pStatus
 */
void MACHINE_PQ_eqFunction_18(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,18};
  $PMACHINE$PpStatus = $P$PRE$PMACHINE$PpStatus;
  TRACE_POP
}
/*
 equation index: 19
 type: SIMPLE_ASSIGN
 MACHINE._running._value = $PRE.MACHINE.running.value
 */
void MACHINE_PQ_eqFunction_19(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,19};
  $PMACHINE$Prunning$Pvalue = $P$PRE$PMACHINE$Prunning$Pvalue;
  TRACE_POP
}
/*
 equation index: 20
 type: SIMPLE_ASSIGN
 $whenCondition7 = not MACHINE.running.value
 */
void MACHINE_PQ_eqFunction_20(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,20};
  $P$whenCondition7 = (!$PMACHINE$Prunning$Pvalue);
  TRACE_POP
}
/*
 equation index: 21
 type: SIMPLE_ASSIGN
 MACHINE._PGenRawPu = if MACHINE.running.value then MACHINE.PGen0Pu + MACHINE.AlphaPu * (1.0 - MACHINE.omegaRefPu.value) else 0.0
 */
void MACHINE_PQ_eqFunction_21(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,21};
  modelica_boolean tmp11;
  modelica_real tmp12;
  tmp11 = (modelica_boolean)$PMACHINE$Prunning$Pvalue;
  if(tmp11)
  {
    tmp12 = $PMACHINE$PPGen0Pu + ($PMACHINE$PAlphaPu) * (1.0 - $PMACHINE$PomegaRefPu$Pvalue);
  }
  else
  {
    tmp12 = 0.0;
  }
  $PMACHINE$PPGenRawPu = tmp12;
  TRACE_POP
}
/*
 equation index: 22
 type: SIMPLE_ASSIGN
 $whenCondition2 = MACHINE.PGenRawPu < MACHINE.PMaxPu and $PRE.MACHINE.pStatus == Dynawo.Electrical.Machines.GeneratorPQ.PStatus.limitPMax
 */
void MACHINE_PQ_eqFunction_22(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,22};
  modelica_boolean tmp13;
  tmp13 = Less($PMACHINE$PPGenRawPu,$PMACHINE$PPMaxPu);
  $P$whenCondition2 = (tmp13 && ((modelica_integer)$P$PRE$PMACHINE$PpStatus == 3));
  TRACE_POP
}
/*
 equation index: 23
 type: SIMPLE_ASSIGN
 $whenCondition3 = MACHINE.PGenRawPu > MACHINE.PMinPu and $PRE.MACHINE.pStatus == Dynawo.Electrical.Machines.GeneratorPQ.PStatus.limitPMin
 */
void MACHINE_PQ_eqFunction_23(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,23};
  modelica_boolean tmp15;
  tmp15 = Greater($PMACHINE$PPGenRawPu,$PMACHINE$PPMinPu);
  $P$whenCondition3 = (tmp15 && ((modelica_integer)$P$PRE$PMACHINE$PpStatus == 2));
  TRACE_POP
}
/*
 equation index: 24
 type: SIMPLE_ASSIGN
 $whenCondition4 = MACHINE.PGenRawPu <= MACHINE.PMinPu and $PRE.MACHINE.pStatus <> Dynawo.Electrical.Machines.GeneratorPQ.PStatus.limitPMin
 */
void MACHINE_PQ_eqFunction_24(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,24};
  modelica_boolean tmp17;
  tmp17 = LessEq($PMACHINE$PPGenRawPu,$PMACHINE$PPMinPu);
  $P$whenCondition4 = (tmp17 && ((modelica_integer)$P$PRE$PMACHINE$PpStatus != 2));
  TRACE_POP
}
/*
 equation index: 25
 type: SIMPLE_ASSIGN
 $whenCondition5 = MACHINE.PGenRawPu >= MACHINE.PMaxPu and $PRE.MACHINE.pStatus <> Dynawo.Electrical.Machines.GeneratorPQ.PStatus.limitPMax
 */
void MACHINE_PQ_eqFunction_25(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,25};
  modelica_boolean tmp19;
  tmp19 = GreaterEq($PMACHINE$PPGenRawPu,$PMACHINE$PPMaxPu);
  $P$whenCondition5 = (tmp19 && ((modelica_integer)$P$PRE$PMACHINE$PpStatus != 3));
  TRACE_POP
}
/*
 equation index: 26
 type: SIMPLE_ASSIGN
 MACHINE._PGenPu = if MACHINE.running.value then if MACHINE.pStatus == Dynawo.Electrical.Machines.GeneratorPQ.PStatus.limitPMax then MACHINE.PMaxPu else if MACHINE.pStatus == Dynawo.Electrical.Machines.GeneratorPQ.PStatus.limitPMin then MACHINE.PMinPu else MACHINE.PGenRawPu else 0.0
 */
void MACHINE_PQ_eqFunction_26(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,26};
  modelica_boolean tmp23;
  modelica_real tmp24;
  modelica_boolean tmp25;
  modelica_real tmp26;
  modelica_boolean tmp27;
  modelica_real tmp28;
  tmp27 = (modelica_boolean)$PMACHINE$Prunning$Pvalue;
  if(tmp27)
  {
    tmp25 = (modelica_boolean)((modelica_integer)$PMACHINE$PpStatus == 3);
    if(tmp25)
    {
      tmp26 = $PMACHINE$PPMaxPu;
    }
    else
    {
      tmp23 = (modelica_boolean)((modelica_integer)$PMACHINE$PpStatus == 2);
      if(tmp23)
      {
        tmp24 = $PMACHINE$PPMinPu;
      }
      else
      {
        tmp24 = $PMACHINE$PPGenRawPu;
      }
      tmp26 = tmp24;
    }
    tmp28 = tmp26;
  }
  else
  {
    tmp28 = 0.0;
  }
  $PMACHINE$PPGenPu = tmp28;
  TRACE_POP
}
/*
 equation index: 27
 type: SIMPLE_ASSIGN
 MACHINE._SGenPu._re = MACHINE.PGenPu
 */
void MACHINE_PQ_eqFunction_27(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,27};
  $PMACHINE$PSGenPu$Pre = $PMACHINE$PPGenPu;
  TRACE_POP
}
/*
 equation index: 28
 type: SIMPLE_ASSIGN
 MACHINE._QGenPu = if MACHINE.running.value then if $PRE.MACHINE.qStatus == Dynawo.Electrical.Machines.GeneratorPQ.QStatus.absorptionMax then MACHINE.QMaxPu else if $PRE.MACHINE.qStatus == Dynawo.Electrical.Machines.GeneratorPQ.QStatus.generationMax then MACHINE.QMinPu else MACHINE.QGen0Pu else 0.0
 */
void MACHINE_PQ_eqFunction_28(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,28};
  modelica_boolean tmp31;
  modelica_real tmp32;
  modelica_boolean tmp33;
  modelica_real tmp34;
  modelica_boolean tmp35;
  modelica_real tmp36;
  tmp35 = (modelica_boolean)$PMACHINE$Prunning$Pvalue;
  if(tmp35)
  {
    tmp33 = (modelica_boolean)((modelica_integer)$P$PRE$PMACHINE$PqStatus == 2);
    if(tmp33)
    {
      tmp34 = $PMACHINE$PQMaxPu;
    }
    else
    {
      tmp31 = (modelica_boolean)((modelica_integer)$P$PRE$PMACHINE$PqStatus == 3);
      if(tmp31)
      {
        tmp32 = $PMACHINE$PQMinPu;
      }
      else
      {
        tmp32 = $PMACHINE$PQGen0Pu;
      }
      tmp34 = tmp32;
    }
    tmp36 = tmp34;
  }
  else
  {
    tmp36 = 0.0;
  }
  $PMACHINE$PQGenPu = tmp36;
  TRACE_POP
}
/*
 equation index: 29
 type: SIMPLE_ASSIGN
 MACHINE._SGenPu._im = MACHINE.QGenPu
 */
void MACHINE_PQ_eqFunction_29(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,29};
  $PMACHINE$PSGenPu$Pim = $PMACHINE$PQGenPu;
  TRACE_POP
}
/*
 equation index: 30
 type: LINEAR
 
 <var>MACHINE._terminal._i._im</var>
 <var>MACHINE._terminal._i._re</var>
 <row>
   <cell>-MACHINE.SGenPu.im</cell>
   <cell>-MACHINE.SGenPu.re</cell>
 </row>
 <matrix>
   <cell row="0" col="0">
     <residual>-MACHINE.terminal.V.re</residual>
   </cell><cell row="0" col="1">
     <residual>MACHINE.terminal.V.im</residual>
   </cell><cell row="1" col="0">
     <residual>MACHINE.terminal.V.im</residual>
   </cell><cell row="1" col="1">
     <residual>MACHINE.terminal.V.re</residual>
   </cell>
 </matrix>
 */
void MACHINE_PQ_eqFunction_30(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,30};
  /* Linear equation system */
  data->simulationInfo->linearSystemData[0].x[0] = _$PMACHINE$Pterminal$Pi$Pim(1);
  data->simulationInfo->linearSystemData[0].x[1] = _$PMACHINE$Pterminal$Pi$Pre(1);
  solve_linear_system(data, threadData, 0);
  $PMACHINE$Pterminal$Pi$Pim = data->simulationInfo->linearSystemData[0].x[0];
  $PMACHINE$Pterminal$Pi$Pre = data->simulationInfo->linearSystemData[0].x[1];
  TRACE_POP
}
/*
 equation index: 31
 type: SIMPLE_ASSIGN
 MACHINE._qStatus = $PRE.MACHINE.qStatus
 */
void MACHINE_PQ_eqFunction_31(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,31};
  $PMACHINE$PqStatus = $P$PRE$PMACHINE$PqStatus;
  TRACE_POP
}
/*
 equation index: 32
 type: SIMPLE_ASSIGN
 der(MACHINE._omegaRefPu._value) = 0.0
 */
void MACHINE_PQ_eqFunction_32(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,32};
  $P$DER$PMACHINE$PomegaRefPu$Pvalue = 0.0;
  TRACE_POP
}
/*
 equation index: 33
 type: SIMPLE_ASSIGN
 der(MACHINE._terminal._V._im) = 0.0
 */
void MACHINE_PQ_eqFunction_33(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,33};
  $P$DER$PMACHINE$Pterminal$PV$Pim = 0.0;
  TRACE_POP
}
/*
 equation index: 34
 type: SIMPLE_ASSIGN
 der(MACHINE._terminal._V._re) = 0.0
 */
void MACHINE_PQ_eqFunction_34(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,34};
  $P$DER$PMACHINE$Pterminal$PV$Pre = 0.0;
  TRACE_POP
}
/*
 equation index: 35
 type: SIMPLE_ASSIGN
 $whenCondition1 = time > 999999.0
 */
void MACHINE_PQ_eqFunction_35(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,35};
  modelica_boolean tmp37;
  tmp37 = Greater(data->localData[0]->timeValue,999999.0);
  $P$whenCondition1 = tmp37;
  TRACE_POP
}
/*
 equation index: 36
 type: SIMPLE_ASSIGN
 $PRE._MACHINE._state = $_start(MACHINE.state)
 */
void MACHINE_PQ_eqFunction_36(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,36};
  $P$PRE$PMACHINE$Pstate = $P$ATTRIBUTE$PMACHINE$Pstate.start;
  TRACE_POP
}
/*
 equation index: 37
 type: SIMPLE_ASSIGN
 MACHINE._state = $PRE.MACHINE.state
 */
void MACHINE_PQ_eqFunction_37(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,37};
  $PMACHINE$Pstate = $P$PRE$PMACHINE$Pstate;
  TRACE_POP
}


int MACHINE_PQ_functionInitialEquations(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  
  data->simulationInfo->discreteCall = 1;
  MACHINE_PQ_eqFunction_1(data, threadData);

  MACHINE_PQ_eqFunction_2(data, threadData);

  MACHINE_PQ_eqFunction_3(data, threadData);

  MACHINE_PQ_eqFunction_4(data, threadData);

  MACHINE_PQ_eqFunction_5(data, threadData);

  MACHINE_PQ_eqFunction_6(data, threadData);

  MACHINE_PQ_eqFunction_7(data, threadData);

  MACHINE_PQ_eqFunction_8(data, threadData);

  MACHINE_PQ_eqFunction_9(data, threadData);

  MACHINE_PQ_eqFunction_10(data, threadData);

  MACHINE_PQ_eqFunction_11(data, threadData);

  MACHINE_PQ_eqFunction_12(data, threadData);

  MACHINE_PQ_eqFunction_13(data, threadData);

  MACHINE_PQ_eqFunction_14(data, threadData);

  MACHINE_PQ_eqFunction_15(data, threadData);

  MACHINE_PQ_eqFunction_16(data, threadData);

  MACHINE_PQ_eqFunction_17(data, threadData);

  MACHINE_PQ_eqFunction_18(data, threadData);

  MACHINE_PQ_eqFunction_19(data, threadData);

  MACHINE_PQ_eqFunction_20(data, threadData);

  MACHINE_PQ_eqFunction_21(data, threadData);

  MACHINE_PQ_eqFunction_22(data, threadData);

  MACHINE_PQ_eqFunction_23(data, threadData);

  MACHINE_PQ_eqFunction_24(data, threadData);

  MACHINE_PQ_eqFunction_25(data, threadData);

  MACHINE_PQ_eqFunction_26(data, threadData);

  MACHINE_PQ_eqFunction_27(data, threadData);

  MACHINE_PQ_eqFunction_28(data, threadData);

  MACHINE_PQ_eqFunction_29(data, threadData);

  MACHINE_PQ_eqFunction_30(data, threadData);

  MACHINE_PQ_eqFunction_31(data, threadData);

  MACHINE_PQ_eqFunction_32(data, threadData);

  MACHINE_PQ_eqFunction_33(data, threadData);

  MACHINE_PQ_eqFunction_34(data, threadData);

  MACHINE_PQ_eqFunction_35(data, threadData);

  MACHINE_PQ_eqFunction_36(data, threadData);

  MACHINE_PQ_eqFunction_37(data, threadData);
  data->simulationInfo->discreteCall = 0;
  
  TRACE_POP
  return 0;
}


int MACHINE_PQ_functionInitialEquations_lambda0(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  
  data->simulationInfo->discreteCall = 1;
  data->simulationInfo->discreteCall = 0;
  
  TRACE_POP
  return 0;
}
int MACHINE_PQ_functionRemovedInitialEquations(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int *equationIndexes = NULL;
  double res = 0.0;

  
  TRACE_POP
  return 0;
}

/* funtion initialize mixed systems */
void MACHINE_PQ_initialMixedSystem(int nMixedSystems, MIXED_SYSTEM_DATA* mixedSystemData)
{
  /* initial mixed systems */
  /* initial_lambda0 mixed systems */
  /* parameter mixed systems */
  /* model mixed systems */
  /* jacobians mixed systems */
}

#if defined(__cplusplus)
}
#endif

