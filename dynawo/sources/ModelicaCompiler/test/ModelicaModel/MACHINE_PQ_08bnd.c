//
// Copyright (c) 2015-2019, RTE (http://www.rte-france.com)
// See AUTHORS.txt
// All rights reserved.
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, you can obtain one at http://mozilla.org/MPL/2.0/.
// SPDX-License-Identifier: MPL-2.0
//
// This file is part of Dynawo, an hybrid C++/Modelica open source time domain
// simulation tool for power systems.
//

/* update bound parameters and variable attributes (start, nominal, min, max) */
/* Simulation code for MACHINE_PQ generated by the OpenModelica Compiler OMCompiler v1.9.4. */

#include "openmodelica.h"
#include "openmodelica_func.h"
#include "simulation_data.h"
#include "simulation/simulation_info_json.h"
#include "simulation/simulation_runtime.h"
#include "util/omc_error.h"
#include "simulation/solver/model_help.h"
#include "simulation/solver/delay.h"
#include "simulation/solver/linearSystem.h"
#include "simulation/solver/nonlinearSystem.h"
#include "simulation/solver/mixedSystem.h"

#include <string.h>

#include "MACHINE_PQ_functions.h"
#include "MACHINE_PQ_model.h"
#include "MACHINE_PQ_literals.h"




#if defined(HPCOM) && !defined(_OPENMP)
  #error "HPCOM requires OpenMP or the results are wrong"
#endif
#if defined(_OPENMP)
  #include <omp.h>
#else
  /* dummy omp defines */
  #define omp_get_max_threads() 1
#endif
#if defined(__cplusplus)
extern "C" {
#endif


/*
 equation index: 78
 type: SIMPLE_ASSIGN
 MACHINE._PGenRawPu = MACHINE.PGen0Pu
 */
void MACHINE_PQ_eqFunction_78(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,78};
  $PMACHINE$PPGenRawPu = $PMACHINE$PPGen0Pu;
  TRACE_POP
}
/*
 equation index: 79
 type: SIMPLE_ASSIGN
 MACHINE._UPu = MACHINE.U0Pu
 */
void MACHINE_PQ_eqFunction_79(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,79};
  $PMACHINE$PUPu = $PMACHINE$PU0Pu;
  TRACE_POP
}
/*
 equation index: 80
 type: SIMPLE_ASSIGN
 MACHINE._QGenPu = MACHINE.QGen0Pu
 */
void MACHINE_PQ_eqFunction_80(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,80};
  $PMACHINE$PQGenPu = $PMACHINE$PQGen0Pu;
  TRACE_POP
}
/*
 equation index: 81
 type: SIMPLE_ASSIGN
 MACHINE._PGenPu = MACHINE.PGen0Pu
 */
void MACHINE_PQ_eqFunction_81(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,81};
  $PMACHINE$PPGenPu = $PMACHINE$PPGen0Pu;
  TRACE_POP
}
/*
 equation index: 82
 type: SIMPLE_ASSIGN
 MACHINE._SGenPu._im = MACHINE.QGen0Pu
 */
void MACHINE_PQ_eqFunction_82(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,82};
  $PMACHINE$PSGenPu$Pim = $PMACHINE$PQGen0Pu;
  TRACE_POP
}
/*
 equation index: 83
 type: SIMPLE_ASSIGN
 MACHINE._SGenPu._re = MACHINE.PGen0Pu
 */
void MACHINE_PQ_eqFunction_83(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,83};
  $PMACHINE$PSGenPu$Pre = $PMACHINE$PPGen0Pu;
  TRACE_POP
}
/*
 equation index: 84
 type: SIMPLE_ASSIGN
 MACHINE._terminal._i._im = MACHINE.i0Pu.im
 */
void MACHINE_PQ_eqFunction_84(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,84};
  $PMACHINE$Pterminal$Pi$Pim = $PMACHINE$Pi0Pu$Pim;
  TRACE_POP
}
/*
 equation index: 85
 type: SIMPLE_ASSIGN
 MACHINE._terminal._i._re = MACHINE.i0Pu.re
 */
void MACHINE_PQ_eqFunction_85(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,85};
  $PMACHINE$Pterminal$Pi$Pre = $PMACHINE$Pi0Pu$Pre;
  TRACE_POP
}
/*
 equation index: 86
 type: SIMPLE_ASSIGN
 MACHINE._terminal._V._im = MACHINE.u0Pu.im
 */
void MACHINE_PQ_eqFunction_86(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,86};
  $PMACHINE$Pterminal$PV$Pim = $PMACHINE$Pu0Pu$Pim;
  TRACE_POP
}
/*
 equation index: 87
 type: SIMPLE_ASSIGN
 MACHINE._terminal._V._re = MACHINE.u0Pu.re
 */
void MACHINE_PQ_eqFunction_87(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,87};
  $PMACHINE$Pterminal$PV$Pre = $PMACHINE$Pu0Pu$Pre;
  TRACE_POP
}
int MACHINE_PQ_updateBoundVariableAttributes(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  
  /* min ******************************************************** */
  
  infoStreamPrint(LOG_INIT, 1, "updating min-values");
  if (ACTIVE_STREAM(LOG_INIT)) messageClose(LOG_INIT);
  
  /* max ******************************************************** */
  
  infoStreamPrint(LOG_INIT, 1, "updating max-values");
  if (ACTIVE_STREAM(LOG_INIT)) messageClose(LOG_INIT);
  
  /* nominal **************************************************** */
  
  infoStreamPrint(LOG_INIT, 1, "updating nominal-values");
  if (ACTIVE_STREAM(LOG_INIT)) messageClose(LOG_INIT);
  
  /* start ****************************************************** */
  MACHINE_PQ_eqFunction_78(data, threadData);

  MACHINE_PQ_eqFunction_79(data, threadData);

  MACHINE_PQ_eqFunction_80(data, threadData);

  MACHINE_PQ_eqFunction_81(data, threadData);

  MACHINE_PQ_eqFunction_82(data, threadData);

  MACHINE_PQ_eqFunction_83(data, threadData);

  MACHINE_PQ_eqFunction_84(data, threadData);

  MACHINE_PQ_eqFunction_85(data, threadData);

  MACHINE_PQ_eqFunction_86(data, threadData);

  MACHINE_PQ_eqFunction_87(data, threadData);
  
  infoStreamPrint(LOG_INIT, 1, "updating start-values");
  $P$ATTRIBUTE$PMACHINE$PPGenRawPu.start = $PMACHINE$PPGenRawPu;
    infoStreamPrint(LOG_INIT, 0, "%s(start=%g)", $PMACHINE$PPGenRawPu__varInfo.name, (modelica_real)  $P$ATTRIBUTE$PMACHINE$PPGenRawPu.start);
  $P$ATTRIBUTE$PMACHINE$PUPu.start = $PMACHINE$PUPu;
    infoStreamPrint(LOG_INIT, 0, "%s(start=%g)", $PMACHINE$PUPu__varInfo.name, (modelica_real)  $P$ATTRIBUTE$PMACHINE$PUPu.start);
  $P$ATTRIBUTE$PMACHINE$PQGenPu.start = $PMACHINE$PQGenPu;
    infoStreamPrint(LOG_INIT, 0, "%s(start=%g)", $PMACHINE$PQGenPu__varInfo.name, (modelica_real)  $P$ATTRIBUTE$PMACHINE$PQGenPu.start);
  $P$ATTRIBUTE$PMACHINE$PPGenPu.start = $PMACHINE$PPGenPu;
    infoStreamPrint(LOG_INIT, 0, "%s(start=%g)", $PMACHINE$PPGenPu__varInfo.name, (modelica_real)  $P$ATTRIBUTE$PMACHINE$PPGenPu.start);
  $P$ATTRIBUTE$PMACHINE$PSGenPu$Pim.start = $PMACHINE$PSGenPu$Pim;
    infoStreamPrint(LOG_INIT, 0, "%s(start=%g)", $PMACHINE$PSGenPu$Pim__varInfo.name, (modelica_real)  $P$ATTRIBUTE$PMACHINE$PSGenPu$Pim.start);
  $P$ATTRIBUTE$PMACHINE$PSGenPu$Pre.start = $PMACHINE$PSGenPu$Pre;
    infoStreamPrint(LOG_INIT, 0, "%s(start=%g)", $PMACHINE$PSGenPu$Pre__varInfo.name, (modelica_real)  $P$ATTRIBUTE$PMACHINE$PSGenPu$Pre.start);
  $P$ATTRIBUTE$PMACHINE$Pterminal$Pi$Pim.start = $PMACHINE$Pterminal$Pi$Pim;
    infoStreamPrint(LOG_INIT, 0, "%s(start=%g)", $PMACHINE$Pterminal$Pi$Pim__varInfo.name, (modelica_real)  $P$ATTRIBUTE$PMACHINE$Pterminal$Pi$Pim.start);
  $P$ATTRIBUTE$PMACHINE$Pterminal$Pi$Pre.start = $PMACHINE$Pterminal$Pi$Pre;
    infoStreamPrint(LOG_INIT, 0, "%s(start=%g)", $PMACHINE$Pterminal$Pi$Pre__varInfo.name, (modelica_real)  $P$ATTRIBUTE$PMACHINE$Pterminal$Pi$Pre.start);
  $P$ATTRIBUTE$PMACHINE$Pterminal$PV$Pim.start = $PMACHINE$Pterminal$PV$Pim;
    infoStreamPrint(LOG_INIT, 0, "%s(start=%g)", $PMACHINE$Pterminal$PV$Pim__varInfo.name, (modelica_real)  $P$ATTRIBUTE$PMACHINE$Pterminal$PV$Pim.start);
  $P$ATTRIBUTE$PMACHINE$Pterminal$PV$Pre.start = $PMACHINE$Pterminal$PV$Pre;
    infoStreamPrint(LOG_INIT, 0, "%s(start=%g)", $PMACHINE$Pterminal$PV$Pre__varInfo.name, (modelica_real)  $P$ATTRIBUTE$PMACHINE$Pterminal$PV$Pre.start);
  if (ACTIVE_STREAM(LOG_INIT)) messageClose(LOG_INIT);
  
  TRACE_POP
  return 0;
}


/*
 equation index: 88
 type: ALGORITHM
 
   assert(MACHINE.NbSwitchOffSignals >= 1 and MACHINE.NbSwitchOffSignals <= 3, "Variable MACHINE.NbSwitchOffSignals out of [min, max] interval: MACHINE.NbSwitchOffSignals >= 1 and MACHINE.NbSwitchOffSignals <= 3 has value: " + String(MACHINE.NbSwitchOffSignals, "d"));
 */
void MACHINE_PQ_eqFunction_88(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,88};
  modelica_boolean tmp0;
  modelica_boolean tmp1;
  static const MMC_DEFSTRINGLIT(tmp2,143,"Variable MACHINE.NbSwitchOffSignals out of [min, max] interval: MACHINE.NbSwitchOffSignals >= 1 and MACHINE.NbSwitchOffSignals <= 3 has value: ");
  modelica_string tmp3;
  static int tmp4 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp4)
  {
    tmp0 = GreaterEq((modelica_integer)$PMACHINE$PNbSwitchOffSignals,((modelica_integer) 1));
    tmp1 = LessEq((modelica_integer)$PMACHINE$PNbSwitchOffSignals,((modelica_integer) 3));
    if(!(tmp0 && tmp1))
    {
      tmp3 = modelica_integer_to_modelica_string_format((modelica_integer)$PMACHINE$PNbSwitchOffSignals, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp2),tmp3);
      {
        FILE_INFO info = {"/home/rosiereflo/Projects/devBranch/dynawo/dynawo/install/gcc7/master/Release/dynawo/ddb/Dynawo/Electrical/Controls/Basics/SwitchOff.mo",30,5,30,122,0};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\nMACHINE.NbSwitchOffSignals >= 1 and MACHINE.NbSwitchOffSignals <= 3", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp4 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 89
 type: ALGORITHM
 
   assert(MACHINE.State0 >= Dynawo.Electrical.Constants.state.OPEN and MACHINE.State0 <= Dynawo.Electrical.Constants.state.UNDEFINED, "Variable MACHINE.State0 out of [min, max] interval: MACHINE.State0 >= Dynawo.Electrical.Constants.state.OPEN and MACHINE.State0 <= Dynawo.Electrical.Constants.state.UNDEFINED has value: " + String(MACHINE.State0, "d"));
 */
void MACHINE_PQ_eqFunction_89(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,89};
  modelica_boolean tmp5;
  modelica_boolean tmp6;
  static const MMC_DEFSTRINGLIT(tmp7,186,"Variable MACHINE.State0 out of [min, max] interval: MACHINE.State0 >= Dynawo.Electrical.Constants.state.OPEN and MACHINE.State0 <= Dynawo.Electrical.Constants.state.UNDEFINED has value: ");
  modelica_string tmp8;
  static int tmp9 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp9)
  {
    tmp5 = GreaterEq((modelica_integer)$PMACHINE$PState0,1);
    tmp6 = LessEq((modelica_integer)$PMACHINE$PState0,6);
    if(!(tmp5 && tmp6))
    {
      tmp8 = modelica_integer_to_modelica_string_format((modelica_integer)$PMACHINE$PState0, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp7),tmp8);
      {
        FILE_INFO info = {"/home/rosiereflo/Projects/devBranch/dynawo/dynawo/install/gcc7/master/Release/dynawo/ddb/Dynawo/Electrical/Controls/Basics/SwitchOff.mo",64,5,64,97,0};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\nMACHINE.State0 >= Dynawo.Electrical.Constants.state.OPEN and MACHINE.State0 <= Dynawo.Electrical.Constants.state.UNDEFINED", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp9 = 1;
    }
  }
  TRACE_POP
}
int MACHINE_PQ_updateBoundParameters(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  MACHINE_PQ_eqFunction_88(data, threadData);

  MACHINE_PQ_eqFunction_89(data, threadData);
  
  TRACE_POP
  return 0;
}

#if defined(__cplusplus)
}
#endif

