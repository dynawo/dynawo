//
// Copyright (c) 2015-2019, RTE (http://www.rte-france.com)
// See AUTHORS.txt
// All rights reserved.
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, you can obtain one at http://mozilla.org/MPL/2.0/.
// SPDX-License-Identifier: MPL-2.0
//
// This file is part of Dynawo, an hybrid C++/Modelica open source time domain
// simulation tool for power systems.
//

/* Initialization */
/* Simulation code for MACHINE_PQ_INIT generated by the OpenModelica Compiler OMCompiler v1.9.4. */

#include "openmodelica.h"
#include "openmodelica_func.h"
#include "simulation_data.h"
#include "simulation/simulation_info_json.h"
#include "simulation/simulation_runtime.h"
#include "util/omc_error.h"
#include "simulation/solver/model_help.h"
#include "simulation/solver/delay.h"
#include "simulation/solver/linearSystem.h"
#include "simulation/solver/nonlinearSystem.h"
#include "simulation/solver/mixedSystem.h"

#include <string.h>

#include "MACHINE_PQ_INIT_functions.h"
#include "MACHINE_PQ_INIT_model.h"
#include "MACHINE_PQ_INIT_literals.h"




#if defined(HPCOM) && !defined(_OPENMP)
  #error "HPCOM requires OpenMP or the results are wrong"
#endif
#if defined(_OPENMP)
  #include <omp.h>
#else
  /* dummy omp defines */
  #define omp_get_max_threads() 1
#endif
#include "MACHINE_PQ_INIT_11mix.h"
#include "MACHINE_PQ_INIT_12jac.h"
#if defined(__cplusplus)
extern "C" {
#endif


/*
 equation index: 1
 type: SIMPLE_ASSIGN
 MACHINE._u0Pu._im = MACHINE.U0Pu * sin(MACHINE.UPhase0)
 */
void MACHINE_PQ_INIT_eqFunction_1(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,1};
  $PMACHINE$Pu0Pu$Pim = ($PMACHINE$PU0Pu) * (sin($PMACHINE$PUPhase0));
  TRACE_POP
}
/*
 equation index: 2
 type: SIMPLE_ASSIGN
 MACHINE._u0Pu._re = MACHINE.U0Pu * cos(MACHINE.UPhase0)
 */
void MACHINE_PQ_INIT_eqFunction_2(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,2};
  $PMACHINE$Pu0Pu$Pre = ($PMACHINE$PU0Pu) * (cos($PMACHINE$PUPhase0));
  TRACE_POP
}
/*
 equation index: 3
 type: SIMPLE_ASSIGN
 MACHINE._s0Pu._re = MACHINE.P0Pu
 */
void MACHINE_PQ_INIT_eqFunction_3(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,3};
  $PMACHINE$Ps0Pu$Pre = $PMACHINE$PP0Pu;
  TRACE_POP
}
/*
 equation index: 4
 type: SIMPLE_ASSIGN
 MACHINE._s0Pu._im = MACHINE.Q0Pu
 */
void MACHINE_PQ_INIT_eqFunction_4(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,4};
  $PMACHINE$Ps0Pu$Pim = $PMACHINE$PQ0Pu;
  TRACE_POP
}
/*
 equation index: 5
 type: LINEAR
 
 <var>MACHINE._i0Pu._re</var>
 <var>MACHINE._i0Pu._im</var>
 <row>
   <cell>-MACHINE.s0Pu.re</cell>
   <cell>-MACHINE.s0Pu.im</cell>
 </row>
 <matrix>
   <cell row="0" col="0">
     <residual>-MACHINE.u0Pu.re</residual>
   </cell><cell row="0" col="1">
     <residual>-MACHINE.u0Pu.im</residual>
   </cell><cell row="1" col="0">
     <residual>-MACHINE.u0Pu.im</residual>
   </cell><cell row="1" col="1">
     <residual>MACHINE.u0Pu.re</residual>
   </cell>
 </matrix>
 */
void MACHINE_PQ_INIT_eqFunction_5(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,5};
  /* Linear equation system */
  data->simulationInfo->linearSystemData[0].x[0] = _$PMACHINE$Pi0Pu$Pre(1);
  data->simulationInfo->linearSystemData[0].x[1] = _$PMACHINE$Pi0Pu$Pim(1);
  solve_linear_system(data, threadData, 0);
  $PMACHINE$Pi0Pu$Pre = data->simulationInfo->linearSystemData[0].x[0];
  $PMACHINE$Pi0Pu$Pim = data->simulationInfo->linearSystemData[0].x[1];
  TRACE_POP
}
/*
 equation index: 6
 type: SIMPLE_ASSIGN
 MACHINE._PGen0Pu = -MACHINE.P0Pu
 */
void MACHINE_PQ_INIT_eqFunction_6(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,6};
  $PMACHINE$PPGen0Pu = (-$PMACHINE$PP0Pu);
  TRACE_POP
}
/*
 equation index: 7
 type: SIMPLE_ASSIGN
 MACHINE._QGen0Pu = -MACHINE.Q0Pu
 */
void MACHINE_PQ_INIT_eqFunction_7(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7};
  $PMACHINE$PQGen0Pu = (-$PMACHINE$PQ0Pu);
  TRACE_POP
}


int MACHINE_PQ_INIT_functionInitialEquations(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  
  data->simulationInfo->discreteCall = 1;
  MACHINE_PQ_INIT_eqFunction_1(data, threadData);

  MACHINE_PQ_INIT_eqFunction_2(data, threadData);

  MACHINE_PQ_INIT_eqFunction_3(data, threadData);

  MACHINE_PQ_INIT_eqFunction_4(data, threadData);

  MACHINE_PQ_INIT_eqFunction_5(data, threadData);

  MACHINE_PQ_INIT_eqFunction_6(data, threadData);

  MACHINE_PQ_INIT_eqFunction_7(data, threadData);
  data->simulationInfo->discreteCall = 0;
  
  TRACE_POP
  return 0;
}


int MACHINE_PQ_INIT_functionInitialEquations_lambda0(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  
  data->simulationInfo->discreteCall = 1;
  data->simulationInfo->discreteCall = 0;
  
  TRACE_POP
  return 0;
}
int MACHINE_PQ_INIT_functionRemovedInitialEquations(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int *equationIndexes = NULL;
  double res = 0.0;

  
  TRACE_POP
  return 0;
}

/* funtion initialize mixed systems */
void MACHINE_PQ_INIT_initialMixedSystem(int nMixedSystems, MIXED_SYSTEM_DATA* mixedSystemData)
{
  /* initial mixed systems */
  /* initial_lambda0 mixed systems */
  /* parameter mixed systems */
  /* model mixed systems */
  /* jacobians mixed systems */
}

#if defined(__cplusplus)
}
#endif

