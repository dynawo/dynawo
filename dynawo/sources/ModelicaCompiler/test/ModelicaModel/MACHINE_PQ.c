//
// Copyright (c) 2015-2019, RTE (http://www.rte-france.com)
// See AUTHORS.txt
// All rights reserved.
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, you can obtain one at http://mozilla.org/MPL/2.0/.
// SPDX-License-Identifier: MPL-2.0
//
// This file is part of Dynawo, an hybrid C++/Modelica open source time domain
// simulation tool for power systems.
//

/* Main Simulation File */
/* Simulation code for MACHINE_PQ generated by the OpenModelica Compiler OMCompiler v1.9.4. */

#include "openmodelica.h"
#include "openmodelica_func.h"
#include "simulation_data.h"
#include "simulation/simulation_info_json.h"
#include "simulation/simulation_runtime.h"
#include "util/omc_error.h"
#include "simulation/solver/model_help.h"
#include "simulation/solver/delay.h"
#include "simulation/solver/linearSystem.h"
#include "simulation/solver/nonlinearSystem.h"
#include "simulation/solver/mixedSystem.h"

#include <string.h>

#include "MACHINE_PQ_functions.h"
#include "MACHINE_PQ_model.h"
#include "MACHINE_PQ_literals.h"




#if defined(HPCOM) && !defined(_OPENMP)
  #error "HPCOM requires OpenMP or the results are wrong"
#endif
#if defined(_OPENMP)
  #include <omp.h>
#else
  /* dummy omp defines */
  #define omp_get_max_threads() 1
#endif

#define prefixedName_performSimulation MACHINE_PQ_performSimulation
#define prefixedName_updateContinuousSystem MACHINE_PQ_updateContinuousSystem
#include <simulation/solver/perform_simulation.c>

#define prefixedName_performQSSSimulation MACHINE_PQ_performQSSSimulation
#include <simulation/solver/perform_qss_simulation.c>

/* dummy VARINFO and FILEINFO */
const FILE_INFO dummyFILE_INFO = omc_dummyFileInfo;
const VAR_INFO dummyVAR_INFO = omc_dummyVarInfo;
#if defined(__cplusplus)
extern "C" {
#endif

int MACHINE_PQ_input_function(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH

  
  TRACE_POP
  return 0;
}

int MACHINE_PQ_input_function_init(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH

  
  TRACE_POP
  return 0;
}

int MACHINE_PQ_input_function_updateStartValues(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH

  
  TRACE_POP
  return 0;
}

int MACHINE_PQ_inputNames(DATA *data, char ** names){
  TRACE_PUSH

  
  TRACE_POP
  return 0;
}

int MACHINE_PQ_output_function(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH

  
  TRACE_POP
  return 0;
}


/*
 equation index: 38
 type: SIMPLE_ASSIGN
 $whenCondition1 = time > 999999.0
 */
void MACHINE_PQ_eqFunction_38(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,38};
  modelica_boolean tmp28;
  RELATIONHYSTERESIS(tmp28, data->localData[0]->timeValue, 999999.0, 0, Greater);
  $P$whenCondition1 = tmp28;
  TRACE_POP
}
/*
 equation index: 39
 type: WHEN
 
 when {$whenCondition1} then
   MACHINE._switchOffSignal3._value = false;
 end when;
 */
void MACHINE_PQ_eqFunction_39(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,39};
  if(($P$whenCondition1 && !$P$PRE$P$whenCondition1 /* edge */))
  {
    $PMACHINE$PswitchOffSignal3$Pvalue = 0;
  }
  TRACE_POP
}
/*
 equation index: 40
 type: WHEN
 
 when {$whenCondition1} then
   MACHINE._switchOffSignal2._value = false;
 end when;
 */
void MACHINE_PQ_eqFunction_40(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,40};
  if(($P$whenCondition1 && !$P$PRE$P$whenCondition1 /* edge */))
  {
    $PMACHINE$PswitchOffSignal2$Pvalue = 0;
  }
  TRACE_POP
}
/*
 equation index: 41
 type: WHEN
 
 when {$whenCondition1} then
   MACHINE._switchOffSignal1._value = false;
 end when;
 */
void MACHINE_PQ_eqFunction_41(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,41};
  if(($P$whenCondition1 && !$P$PRE$P$whenCondition1 /* edge */))
  {
    $PMACHINE$PswitchOffSignal1$Pvalue = 0;
  }
  TRACE_POP
}
/*
 equation index: 42
 type: SIMPLE_ASSIGN
 $whenCondition6 = MACHINE.switchOffSignal1.value or MACHINE.switchOffSignal2.value or MACHINE.switchOffSignal3.value and pre(MACHINE.running.value)
 */
void MACHINE_PQ_eqFunction_42(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,42};
  $P$whenCondition6 = (($PMACHINE$PswitchOffSignal1$Pvalue || $PMACHINE$PswitchOffSignal2$Pvalue) || ($PMACHINE$PswitchOffSignal3$Pvalue && $P$PRE$PMACHINE$Prunning$Pvalue));
  TRACE_POP
}
/*
 equation index: 43
 type: WHEN
 
 when {$whenCondition6} then
   MACHINE._running._value = false;
 end when;
 */
void MACHINE_PQ_eqFunction_43(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,43};
  if(($P$whenCondition6 && !$P$PRE$P$whenCondition6 /* edge */))
  {
    $PMACHINE$Prunning$Pvalue = 0;
  }
  TRACE_POP
}
/*
 equation index: 44
 type: SIMPLE_ASSIGN
 $whenCondition7 = not MACHINE.running.value
 */
void MACHINE_PQ_eqFunction_44(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,44};
  $P$whenCondition7 = (!$PMACHINE$Prunning$Pvalue);
  TRACE_POP
}
/*
 equation index: 45
 type: WHEN
 
 when {$whenCondition7} then
   MACHINE._state = Dynawo.Electrical.Constants.state.OPEN;
 end when;
 */
void MACHINE_PQ_eqFunction_45(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,45};
  if(($P$whenCondition7 && !$P$PRE$P$whenCondition7 /* edge */))
  {
    $PMACHINE$Pstate = 1;
  }
  TRACE_POP
}
/*
 equation index: 46
 type: SIMPLE_ASSIGN
 der(MACHINE._terminal._V._re) = 0.0
 */
void MACHINE_PQ_eqFunction_46(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,46};
  $P$DER$PMACHINE$Pterminal$PV$Pre = 0.0;
  TRACE_POP
}
/*
 equation index: 47
 type: SIMPLE_ASSIGN
 der(MACHINE._terminal._V._im) = 0.0
 */
void MACHINE_PQ_eqFunction_47(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,47};
  $P$DER$PMACHINE$Pterminal$PV$Pim = 0.0;
  TRACE_POP
}
/*
 equation index: 48
 type: SIMPLE_ASSIGN
 der(MACHINE._omegaRefPu._value) = 0.0
 */
void MACHINE_PQ_eqFunction_48(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,48};
  $P$DER$PMACHINE$PomegaRefPu$Pvalue = 0.0;
  TRACE_POP
}
/*
 equation index: 49
 type: SIMPLE_ASSIGN
 MACHINE._PGenRawPu = if MACHINE.running.value then MACHINE.PGen0Pu + MACHINE.AlphaPu * (1.0 - MACHINE.omegaRefPu.value) else 0.0
 */
void MACHINE_PQ_eqFunction_49(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,49};
  modelica_boolean tmp29;
  modelica_real tmp30;
  tmp29 = (modelica_boolean)$PMACHINE$Prunning$Pvalue;
  if(tmp29)
  {
    tmp30 = $PMACHINE$PPGen0Pu + ($PMACHINE$PAlphaPu) * (1.0 - $PMACHINE$PomegaRefPu$Pvalue);
  }
  else
  {
    tmp30 = 0.0;
  }
  $PMACHINE$PPGenRawPu = tmp30;
  TRACE_POP
}
/*
 equation index: 50
 type: SIMPLE_ASSIGN
 $whenCondition5 = MACHINE.PGenRawPu >= MACHINE.PMaxPu and pre(MACHINE.pStatus) <> Dynawo.Electrical.Machines.GeneratorPQ.PStatus.limitPMax
 */
void MACHINE_PQ_eqFunction_50(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,50};
  modelica_boolean tmp31;
  RELATIONHYSTERESIS(tmp31, $PMACHINE$PPGenRawPu, $PMACHINE$PPMaxPu, 1, GreaterEq);
  $P$whenCondition5 = (tmp31 && ($P$PRE$PMACHINE$PpStatus != 3));
  TRACE_POP
}
/*
 equation index: 51
 type: SIMPLE_ASSIGN
 $whenCondition4 = MACHINE.PGenRawPu <= MACHINE.PMinPu and pre(MACHINE.pStatus) <> Dynawo.Electrical.Machines.GeneratorPQ.PStatus.limitPMin
 */
void MACHINE_PQ_eqFunction_51(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,51};
  modelica_boolean tmp33;
  RELATIONHYSTERESIS(tmp33, $PMACHINE$PPGenRawPu, $PMACHINE$PPMinPu, 2, LessEq);
  $P$whenCondition4 = (tmp33 && ($P$PRE$PMACHINE$PpStatus != 2));
  TRACE_POP
}
/*
 equation index: 52
 type: SIMPLE_ASSIGN
 $whenCondition3 = MACHINE.PGenRawPu > MACHINE.PMinPu and pre(MACHINE.pStatus) == Dynawo.Electrical.Machines.GeneratorPQ.PStatus.limitPMin
 */
void MACHINE_PQ_eqFunction_52(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,52};
  modelica_boolean tmp35;
  RELATIONHYSTERESIS(tmp35, $PMACHINE$PPGenRawPu, $PMACHINE$PPMinPu, 3, Greater);
  $P$whenCondition3 = (tmp35 && ($P$PRE$PMACHINE$PpStatus == 2));
  TRACE_POP
}
/*
 equation index: 53
 type: SIMPLE_ASSIGN
 $whenCondition2 = MACHINE.PGenRawPu < MACHINE.PMaxPu and pre(MACHINE.pStatus) == Dynawo.Electrical.Machines.GeneratorPQ.PStatus.limitPMax
 */
void MACHINE_PQ_eqFunction_53(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,53};
  modelica_boolean tmp37;
  RELATIONHYSTERESIS(tmp37, $PMACHINE$PPGenRawPu, $PMACHINE$PPMaxPu, 4, Less);
  $P$whenCondition2 = (tmp37 && ($P$PRE$PMACHINE$PpStatus == 3));
  TRACE_POP
}
/*
 equation index: 54
 type: WHEN
 
 when {$whenCondition5} then
   MACHINE._pStatus = Dynawo.Electrical.Machines.GeneratorPQ.PStatus.limitPMax;
 end when;
 */
void MACHINE_PQ_eqFunction_54(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,54};
  if(($P$whenCondition5 && !$P$PRE$P$whenCondition5 /* edge */))
  {
    $PMACHINE$PpStatus = 3;
  }
  else if(($P$whenCondition4 && !$P$PRE$P$whenCondition4 /* edge */))
  {
    $PMACHINE$PpStatus = 2;
  }
  else if(($P$whenCondition3 && !$P$PRE$P$whenCondition3 /* edge */))
  {
    $PMACHINE$PpStatus = 1;
  }
  else if(($P$whenCondition2 && !$P$PRE$P$whenCondition2 /* edge */))
  {
    $PMACHINE$PpStatus = 1;
  }
  TRACE_POP
}
/*
 equation index: 58
 type: SIMPLE_ASSIGN
 MACHINE._PGenPu = if MACHINE.running.value then if MACHINE.pStatus == Dynawo.Electrical.Machines.GeneratorPQ.PStatus.limitPMax then MACHINE.PMaxPu else if MACHINE.pStatus == Dynawo.Electrical.Machines.GeneratorPQ.PStatus.limitPMin then MACHINE.PMinPu else MACHINE.PGenRawPu else 0.0
 */
void MACHINE_PQ_eqFunction_58(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,58};
  modelica_boolean tmp41;
  modelica_real tmp42;
  modelica_boolean tmp43;
  modelica_real tmp44;
  modelica_boolean tmp45;
  modelica_real tmp46;
  tmp45 = (modelica_boolean)$PMACHINE$Prunning$Pvalue;
  if(tmp45)
  {
    tmp43 = (modelica_boolean)((modelica_integer)$PMACHINE$PpStatus == 3);
    if(tmp43)
    {
      tmp44 = $PMACHINE$PPMaxPu;
    }
    else
    {
      tmp41 = (modelica_boolean)((modelica_integer)$PMACHINE$PpStatus == 2);
      if(tmp41)
      {
        tmp42 = $PMACHINE$PPMinPu;
      }
      else
      {
        tmp42 = $PMACHINE$PPGenRawPu;
      }
      tmp44 = tmp42;
    }
    tmp46 = tmp44;
  }
  else
  {
    tmp46 = 0.0;
  }
  $PMACHINE$PPGenPu = tmp46;
  TRACE_POP
}
/*
 equation index: 59
 type: SIMPLE_ASSIGN
 MACHINE._UPu = (MACHINE.terminal.V.re ^ 2.0 + MACHINE.terminal.V.im ^ 2.0) ^ 0.5
 */
void MACHINE_PQ_eqFunction_59(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,59};
  modelica_real tmp47;
  modelica_real tmp48;
  modelica_real tmp49;
  tmp47 = $PMACHINE$Pterminal$PV$Pre;
  tmp48 = $PMACHINE$Pterminal$PV$Pim;
  $PMACHINE$PUPu = sqrt((tmp47 * tmp47) + (tmp48 * tmp48));
  TRACE_POP
}
/*
 equation index: 60
 type: SIMPLE_ASSIGN
 $whenCondition10 = MACHINE.UPu >= 0.0001 + MACHINE.UMaxPu and pre(MACHINE.qStatus) <> Dynawo.Electrical.Machines.GeneratorPQ.QStatus.absorptionMax
 */
void MACHINE_PQ_eqFunction_60(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,60};
  modelica_boolean tmp50;
  RELATIONHYSTERESIS(tmp50, $PMACHINE$PUPu, 0.0001 + $PMACHINE$PUMaxPu, 5, GreaterEq);
  $P$whenCondition10 = (tmp50 && ($P$PRE$PMACHINE$PqStatus != 2));
  TRACE_POP
}
/*
 equation index: 61
 type: SIMPLE_ASSIGN
 $whenCondition9 = MACHINE.UPu <= -0.0001 + MACHINE.UMinPu and pre(MACHINE.qStatus) <> Dynawo.Electrical.Machines.GeneratorPQ.QStatus.generationMax
 */
void MACHINE_PQ_eqFunction_61(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,61};
  modelica_boolean tmp52;
  RELATIONHYSTERESIS(tmp52, $PMACHINE$PUPu, -0.0001 + $PMACHINE$PUMinPu, 6, LessEq);
  $P$whenCondition9 = (tmp52 && ($P$PRE$PMACHINE$PqStatus != 3));
  TRACE_POP
}
/*
 equation index: 62
 type: SIMPLE_ASSIGN
 $whenCondition8 = MACHINE.UPu < -0.0001 + MACHINE.UMaxPu and pre(MACHINE.qStatus) == Dynawo.Electrical.Machines.GeneratorPQ.QStatus.absorptionMax or MACHINE.UPu > 0.0001 + MACHINE.UMinPu and pre(MACHINE.qStatus) == Dynawo.Electrical.Machines.GeneratorPQ.QStatus.generationMax
 */
void MACHINE_PQ_eqFunction_62(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,62};
  modelica_boolean tmp54;
  modelica_boolean tmp56;
  RELATIONHYSTERESIS(tmp54, $PMACHINE$PUPu, -0.0001 + $PMACHINE$PUMaxPu, 7, Less);
  RELATIONHYSTERESIS(tmp56, $PMACHINE$PUPu, 0.0001 + $PMACHINE$PUMinPu, 8, Greater);
  $P$whenCondition8 = ((tmp54 && ($P$PRE$PMACHINE$PqStatus == 2)) || (tmp56 && ($P$PRE$PMACHINE$PqStatus == 3)));
  TRACE_POP
}
/*
 equation index: 63
 type: WHEN
 
 when {$whenCondition10} then
   MACHINE._qStatus = Dynawo.Electrical.Machines.GeneratorPQ.QStatus.absorptionMax;
 end when;
 */
void MACHINE_PQ_eqFunction_63(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,63};
  if(($P$whenCondition10 && !$P$PRE$P$whenCondition10 /* edge */))
  {
    $PMACHINE$PqStatus = 2;
  }
  else if(($P$whenCondition9 && !$P$PRE$P$whenCondition9 /* edge */))
  {
    $PMACHINE$PqStatus = 3;
  }
  else if(($P$whenCondition8 && !$P$PRE$P$whenCondition8 /* edge */))
  {
    $PMACHINE$PqStatus = 1;
  }
  TRACE_POP
}
/*
 equation index: 66
 type: SIMPLE_ASSIGN
 MACHINE._SGenPu._re = MACHINE.PGenPu
 */
void MACHINE_PQ_eqFunction_66(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,66};
  $PMACHINE$PSGenPu$Pre = $PMACHINE$PPGenPu;
  TRACE_POP
}
/*
 equation index: 67
 type: SIMPLE_ASSIGN
 MACHINE._QGenPu = if MACHINE.running.value then if pre(MACHINE.qStatus) == Dynawo.Electrical.Machines.GeneratorPQ.QStatus.absorptionMax then MACHINE.QMaxPu else if pre(MACHINE.qStatus) == Dynawo.Electrical.Machines.GeneratorPQ.QStatus.generationMax then MACHINE.QMinPu else MACHINE.QGen0Pu else 0.0
 */
void MACHINE_PQ_eqFunction_67(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,67};
  modelica_boolean tmp60;
  modelica_real tmp61;
  modelica_boolean tmp62;
  modelica_real tmp63;
  modelica_boolean tmp64;
  modelica_real tmp65;
  tmp64 = (modelica_boolean)$PMACHINE$Prunning$Pvalue;
  if(tmp64)
  {
    tmp62 = (modelica_boolean)($P$PRE$PMACHINE$PqStatus == 2);
    if(tmp62)
    {
      tmp63 = $PMACHINE$PQMaxPu;
    }
    else
    {
      tmp60 = (modelica_boolean)($P$PRE$PMACHINE$PqStatus == 3);
      if(tmp60)
      {
        tmp61 = $PMACHINE$PQMinPu;
      }
      else
      {
        tmp61 = $PMACHINE$PQGen0Pu;
      }
      tmp63 = tmp61;
    }
    tmp65 = tmp63;
  }
  else
  {
    tmp65 = 0.0;
  }
  $PMACHINE$PQGenPu = tmp65;
  TRACE_POP
}
/*
 equation index: 68
 type: SIMPLE_ASSIGN
 MACHINE._SGenPu._im = MACHINE.QGenPu
 */
void MACHINE_PQ_eqFunction_68(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,68};
  $PMACHINE$PSGenPu$Pim = $PMACHINE$PQGenPu;
  TRACE_POP
}
/*
 equation index: 69
 type: LINEAR
 
 <var>MACHINE._terminal._i._im</var>
 <var>MACHINE._terminal._i._re</var>
 <row>
   <cell>-MACHINE.SGenPu.im</cell>
   <cell>-MACHINE.SGenPu.re</cell>
 </row>
 <matrix>
   <cell row="0" col="0">
     <residual>-MACHINE.terminal.V.re</residual>
   </cell><cell row="0" col="1">
     <residual>MACHINE.terminal.V.im</residual>
   </cell><cell row="1" col="0">
     <residual>MACHINE.terminal.V.im</residual>
   </cell><cell row="1" col="1">
     <residual>MACHINE.terminal.V.re</residual>
   </cell>
 </matrix>
 */
void MACHINE_PQ_eqFunction_69(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,69};
  /* Linear equation system */
  data->simulationInfo->linearSystemData[1].x[0] = _$PMACHINE$Pterminal$Pi$Pim(1);
  data->simulationInfo->linearSystemData[1].x[1] = _$PMACHINE$Pterminal$Pi$Pre(1);
  solve_linear_system(data, threadData, 1);
  $PMACHINE$Pterminal$Pi$Pim = data->simulationInfo->linearSystemData[1].x[0];
  $PMACHINE$Pterminal$Pi$Pre = data->simulationInfo->linearSystemData[1].x[1];
  TRACE_POP
}
/*
 equation index: 75
 type: WHEN
 
 when {$whenCondition10} then
   noReturnCall(Dynawo.NonElectrical.Logs.Timeline.logEvent1(58))%>);
 end when;
 */
void MACHINE_PQ_eqFunction_75(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,75};
  if(($P$whenCondition10 && !$P$PRE$P$whenCondition10 /* edge */))
  {
    omc_Dynawo_NonElectrical_Logs_Timeline_logEvent1(threadData, ((modelica_integer) 58));
  }
  else if(($P$whenCondition9 && !$P$PRE$P$whenCondition9 /* edge */))
  {
    omc_Dynawo_NonElectrical_Logs_Timeline_logEvent1(threadData, ((modelica_integer) 29));
  }
  else if(($P$whenCondition8 && !$P$PRE$P$whenCondition8 /* edge */))
  {
    omc_Dynawo_NonElectrical_Logs_Timeline_logEvent1(threadData, ((modelica_integer) 48));
  }
  TRACE_POP
}
/*
 equation index: 74
 type: WHEN
 
 when {$whenCondition7} then
   noReturnCall(Dynawo.NonElectrical.Logs.Timeline.logEvent1(54))%>);
 end when;
 */
void MACHINE_PQ_eqFunction_74(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,74};
  if(($P$whenCondition7 && !$P$PRE$P$whenCondition7 /* edge */))
  {
    omc_Dynawo_NonElectrical_Logs_Timeline_logEvent1(threadData, ((modelica_integer) 54));
  }
  TRACE_POP
}
/*
 equation index: 70
 type: WHEN
 
 when {$whenCondition5} then
   noReturnCall(Dynawo.NonElectrical.Logs.Timeline.logEvent1(23))%>);
 end when;
 */
void MACHINE_PQ_eqFunction_70(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,70};
  if(($P$whenCondition5 && !$P$PRE$P$whenCondition5 /* edge */))
  {
    omc_Dynawo_NonElectrical_Logs_Timeline_logEvent1(threadData, ((modelica_integer) 23));
  }
  else if(($P$whenCondition4 && !$P$PRE$P$whenCondition4 /* edge */))
  {
    omc_Dynawo_NonElectrical_Logs_Timeline_logEvent1(threadData, ((modelica_integer) 15));
  }
  else if(($P$whenCondition3 && !$P$PRE$P$whenCondition3 /* edge */))
  {
    omc_Dynawo_NonElectrical_Logs_Timeline_logEvent1(threadData, ((modelica_integer) 68));
  }
  else if(($P$whenCondition2 && !$P$PRE$P$whenCondition2 /* edge */))
  {
    omc_Dynawo_NonElectrical_Logs_Timeline_logEvent1(threadData, ((modelica_integer) 10));
  }
  TRACE_POP
}


int MACHINE_PQ_functionDAE(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  int equationIndexes[1] = {0};
  
  data->simulationInfo->needToIterate = 0;
  data->simulationInfo->discreteCall = 1;
  MACHINE_PQ_eqFunction_38(data, threadData);

  MACHINE_PQ_eqFunction_39(data, threadData);

  MACHINE_PQ_eqFunction_40(data, threadData);

  MACHINE_PQ_eqFunction_41(data, threadData);

  MACHINE_PQ_eqFunction_42(data, threadData);

  MACHINE_PQ_eqFunction_43(data, threadData);

  MACHINE_PQ_eqFunction_44(data, threadData);

  MACHINE_PQ_eqFunction_45(data, threadData);

  MACHINE_PQ_eqFunction_46(data, threadData);

  MACHINE_PQ_eqFunction_47(data, threadData);

  MACHINE_PQ_eqFunction_48(data, threadData);

  MACHINE_PQ_eqFunction_49(data, threadData);

  MACHINE_PQ_eqFunction_50(data, threadData);

  MACHINE_PQ_eqFunction_51(data, threadData);

  MACHINE_PQ_eqFunction_52(data, threadData);

  MACHINE_PQ_eqFunction_53(data, threadData);

  MACHINE_PQ_eqFunction_54(data, threadData);

  MACHINE_PQ_eqFunction_58(data, threadData);

  MACHINE_PQ_eqFunction_59(data, threadData);

  MACHINE_PQ_eqFunction_60(data, threadData);

  MACHINE_PQ_eqFunction_61(data, threadData);

  MACHINE_PQ_eqFunction_62(data, threadData);

  MACHINE_PQ_eqFunction_63(data, threadData);

  MACHINE_PQ_eqFunction_66(data, threadData);

  MACHINE_PQ_eqFunction_67(data, threadData);

  MACHINE_PQ_eqFunction_68(data, threadData);

  MACHINE_PQ_eqFunction_69(data, threadData);

  MACHINE_PQ_eqFunction_75(data, threadData);

  MACHINE_PQ_eqFunction_74(data, threadData);

  MACHINE_PQ_eqFunction_70(data, threadData);
  data->simulationInfo->discreteCall = 0;
  
  TRACE_POP
  return 0;
}

int MACHINE_PQ_symEulerUpdate(DATA *data, modelica_real dt)
{
  TRACE_PUSH
  #ifdef $P__OMC_DT
    $P__OMC_DT = dt;
  #else
    return -1;
  #endif
  
  TRACE_POP
  return 0;
}



/* forwarded equations */
extern void MACHINE_PQ_eqFunction_46(DATA* data, threadData_t *threadData);
extern void MACHINE_PQ_eqFunction_47(DATA* data, threadData_t *threadData);
extern void MACHINE_PQ_eqFunction_48(DATA* data, threadData_t *threadData);

static void functionODE_system0(DATA *data, threadData_t *threadData)
{
  MACHINE_PQ_eqFunction_46(data, threadData);

  MACHINE_PQ_eqFunction_47(data, threadData);

  MACHINE_PQ_eqFunction_48(data, threadData);
}

int MACHINE_PQ_functionODE(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH

  
  data->simulationInfo->callStatistics.functionODE++;
  
  functionODE_system0(data, threadData);

  
  TRACE_POP
  return 0;
}

#ifdef FMU_EXPERIMENTAL
#endif
/* forward the main in the simulation runtime */
extern int _main_SimulationRuntime(int argc, char**argv, DATA *data, threadData_t *threadData);

#include "MACHINE_PQ_12jac.h"
#include "MACHINE_PQ_13opt.h"

struct OpenModelicaGeneratedFunctionCallbacks MACHINE_PQ_callback = {
   (int (*)(DATA *, threadData_t *, void *)) MACHINE_PQ_performSimulation,
   (int (*)(DATA *, threadData_t *, void *)) MACHINE_PQ_performQSSSimulation,
   MACHINE_PQ_updateContinuousSystem,
   MACHINE_PQ_callExternalObjectConstructors,
   MACHINE_PQ_callExternalObjectDestructors,
   MACHINE_PQ_initialNonLinearSystem,
   MACHINE_PQ_initialLinearSystem,
   MACHINE_PQ_initialMixedSystem,
   MACHINE_PQ_initializeStateSets,
   MACHINE_PQ_functionODE,
   MACHINE_PQ_functionAlgebraics,
   MACHINE_PQ_functionDAE,
   MACHINE_PQ_input_function,
   MACHINE_PQ_input_function_init,
   MACHINE_PQ_input_function_updateStartValues,
   MACHINE_PQ_output_function,
   MACHINE_PQ_function_storeDelayed,
   MACHINE_PQ_updateBoundVariableAttributes,
   0 /* useHomotopy */,
   MACHINE_PQ_functionInitialEquations,
   MACHINE_PQ_functionInitialEquations_lambda0,
   MACHINE_PQ_functionRemovedInitialEquations,
   MACHINE_PQ_updateBoundParameters,
   MACHINE_PQ_checkForAsserts,
   MACHINE_PQ_function_ZeroCrossingsEquations,
   MACHINE_PQ_function_ZeroCrossings,
   MACHINE_PQ_function_updateRelations,
   MACHINE_PQ_checkForDiscreteChanges,
   MACHINE_PQ_zeroCrossingDescription,
   MACHINE_PQ_relationDescription,
   MACHINE_PQ_function_initSample,
   MACHINE_PQ_INDEX_JAC_A,
   MACHINE_PQ_INDEX_JAC_B,
   MACHINE_PQ_INDEX_JAC_C,
   MACHINE_PQ_INDEX_JAC_D,
   MACHINE_PQ_initialAnalyticJacobianA,
   MACHINE_PQ_initialAnalyticJacobianB,
   MACHINE_PQ_initialAnalyticJacobianC,
   MACHINE_PQ_initialAnalyticJacobianD,
   MACHINE_PQ_functionJacA_column,
   MACHINE_PQ_functionJacB_column,
   MACHINE_PQ_functionJacC_column,
   MACHINE_PQ_functionJacD_column,
   MACHINE_PQ_linear_model_frame,
   MACHINE_PQ_mayer,
   MACHINE_PQ_lagrange,
   MACHINE_PQ_pickUpBoundsForInputsInOptimization,
   MACHINE_PQ_setInputData,
   MACHINE_PQ_getTimeGrid,
   MACHINE_PQ_symEulerUpdate,
   MACHINE_PQ_function_initSynchronous,
   MACHINE_PQ_function_updateSynchronous,
   MACHINE_PQ_function_equationsSynchronous,
   NULL
   #ifdef FMU_EXPERIMENTAL
   ,MACHINE_PQ_functionODE_Partial
   ,MACHINE_PQ_functionFMIJacobian
   #endif
   ,MACHINE_PQ_inputNames


};

void MACHINE_PQ_setupDataStruc(DATA *data, threadData_t *threadData)
{
  assertStreamPrint(threadData,0!=data, "Error while initialize Data");
  data->callback = &MACHINE_PQ_callback;
  data->modelData->modelName = "MACHINE_PQ";
  data->modelData->modelFilePrefix = "MACHINE_PQ";
  data->modelData->resultFileName = NULL;
  data->modelData->modelDir = "/home/rosiereflo/Projects/devBranch/dynawo/dynawo/build/gcc7/master/Release/dynawo/sources/Models/Modelica/PreassembledModels";
  data->modelData->modelGUID = "{8c4e810f-3df3-4a00-8276-176fa3c9f9e0}";
  #if defined(OPENMODELICA_XML_FROM_FILE_AT_RUNTIME)
  data->modelData->initXMLData = NULL;
  data->modelData->modelDataXml.infoXMLData = NULL;
  #else
  data->modelData->initXMLData =
  #include "MACHINE_PQ_init.c"
  ;
  data->modelData->modelDataXml.infoXMLData =
  #include "MACHINE_PQ_info.c"
  ;
  #endif
  
  data->modelData->nStates = 3;
  data->modelData->nVariablesReal = 3+8+0 + 0;
  data->modelData->nDiscreteReal = 0;
  data->modelData->nVariablesInteger = 3;
  data->modelData->nVariablesBoolean = 14;
  data->modelData->nVariablesString = 0;
  data->modelData->nParametersReal = 14;
  data->modelData->nParametersInteger = 2;
  data->modelData->nParametersBoolean = 0;
  data->modelData->nParametersString = 0;
  data->modelData->nInputVars = 0;
  data->modelData->nOutputVars = 0;
  
  data->modelData->nAliasReal = 0;
  data->modelData->nAliasInteger = 0;
  data->modelData->nAliasBoolean = 0;
  data->modelData->nAliasString = 0;
  
  data->modelData->nZeroCrossings = 8;
  data->modelData->nSamples = 0;
  data->modelData->nRelations = 9;
  data->modelData->nMathEvents = 0;
  data->modelData->nExtObjs = 0;
  data->modelData->modelDataXml.fileName = "MACHINE_PQ_info.json";
  data->modelData->modelDataXml.modelInfoXmlLength = 0;
  data->modelData->modelDataXml.nFunctions = 8;
  data->modelData->modelDataXml.nProfileBlocks = 0;
  data->modelData->modelDataXml.nEquations = 93;
  data->modelData->nMixedSystems = 0;
  data->modelData->nLinearSystems = 2;
  data->modelData->nNonLinearSystems = 0;
  data->modelData->nStateSets = 0;
  data->modelData->nJacobians = 4;
  data->modelData->nOptimizeConstraints = 0;
  data->modelData->nOptimizeFinalConstraints = 0;
  
  data->modelData->nDelayExpressions = 0;
  
  data->modelData->nClocks = 0;
  data->modelData->nSubClocks = 0;
  
}

#ifdef __cplusplus
}
#endif

static int rml_execution_failed()
{
  fflush(NULL);
  fprintf(stderr, "Execution failed!\n");
  fflush(NULL);
  return 1;
}

#if defined(threadData)
#undef threadData
#endif
/* call the simulation runtime main from our main! */
int main(int argc, char**argv)
{
  int res;
  DATA data;
  MODEL_DATA modelData;
  SIMULATION_INFO simInfo;
  data.modelData = &modelData;
  data.simulationInfo = &simInfo;
  measure_time_flag = 0;
  MMC_INIT();omc_alloc_interface.init();
  {
    MMC_TRY_TOP()
  
    MMC_TRY_STACK()
  
    MACHINE_PQ_setupDataStruc(&data, threadData);
    res = _main_SimulationRuntime(argc, argv, &data, threadData);
    
    MMC_ELSE()
    rml_execution_failed();
    fprintf(stderr, "Stack overflow detected and was not caught.\nSend us a bug report at https://trac.openmodelica.org/OpenModelica/newticket\n    Include the following trace:\n");
    printStacktraceMessages();
    fflush(NULL);
    return 1;
    MMC_CATCH_STACK()
    
    MMC_CATCH_TOP(return rml_execution_failed());
  }

  fflush(NULL);
  EXIT(res);
  return res;
}

