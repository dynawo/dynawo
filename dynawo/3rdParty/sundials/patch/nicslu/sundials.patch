diff -urpN sundials-4.1.0/CMakeLists.txt sundials-4.1.0.patch/CMakeLists.txt
--- sundials-4.1.0/CMakeLists.txt	2019-02-12 19:50:51.000000000 +0100
+++ sundials-4.1.0.patch/CMakeLists.txt	2020-06-17 10:54:45.198242271 +0200
@@ -361,6 +361,19 @@ INCLUDE(SundialsPOSIXTimers)
 # ===============================================================
 
 # ---------------------------------------------------------------
+# Enable NICSLU support?
+# -------------------------------------------------------------
+
+OPTION(NICSLU_ENABLE "Enable NICSLU support" OFF)
+
+IF(NOT NICSLU_ENABLE)
+  HIDE_VARIABLE(NICSLU_LIBRARY_DIR)
+  HIDE_VARIABLE(NICSLU_INCLUDE_DIR)
+  #PRINT_WARNING("NICSLU is off!")
+  SET (NICSLU_DISABLED TRUE CACHE INTERNAL "GUI - return when first set")
+ENDIF(NOT NICSLU_ENABLE)
+
+# -------------------------------------------------------------
 # Enable MPI support?
 # ---------------------------------------------------------------
 OPTION(MPI_ENABLE "Enable MPI support" OFF)
@@ -1014,6 +1027,40 @@ ELSE()
 ENDIF(KLU_ENABLE)
 
 # ---------------------------------------------------------------
+# Find (and test) the NICSLU libraries
+# ---------------------------------------------------------------
+
+# If NICSLU is requested, first try to find the appropriate libraries to
+# link against them.
+
+IF(NICSLU_ENABLE)
+
+  SHOW_VARIABLE(NICSLU_INCLUDE_DIR STRING "NICSLU include directory"
+    "${NICSLU_INCLUDE_DIR}")
+  SHOW_VARIABLE(NICSLU_LIBRARY_DIR STRING "NICSLU library directory"
+    "${NICSLU_LIBRARY_DIR}")
+
+  INCLUDE(SundialsNICSLU)
+
+  IF(NICSLU_FOUND)
+    # sundials_config.h symbol
+    SET(SUNDIALS_NICSLU TRUE)
+    INCLUDE_DIRECTORIES(${NICSLU_INCLUDE_DIR})
+  ENDIF(NICSLU_FOUND)
+
+  IF(NICSLU_LIBRARIES AND NOT NICSLU_FOUND)
+    PRINT_WARNING("NICSLU not functional - support will not be provided" "Double check spelling specified libraries (search is case sensitive)")
+  ENDIF(NICSLU_LIBRARIES AND NOT NICSLU_FOUND)
+
+ELSE()
+
+  HIDE_VARIABLE(KLU_LIBRARY_DIR)
+  HIDE_VARIABLE(KLU_INCLUDE_DIR)
+  SET (KLU_DISABLED TRUE CACHE INTERNAL "GUI - return when first set")
+
+ENDIF(NICSLU_ENABLE)
+
+# ---------------------------------------------------------------
 # Find (and test) the hypre libraries
 # ---------------------------------------------------------------
 
diff -urpN sundials-4.1.0/config/FindNICSLU.cmake sundials-4.1.0.patch/config/FindNICSLU.cmake
--- sundials-4.1.0/config/FindNICSLU.cmake	1970-01-01 01:00:00.000000000 +0100
+++ sundials-4.1.0.patch/config/FindNICSLU.cmake	2020-06-17 10:54:45.199242278 +0200
@@ -0,0 +1,55 @@
+# ---------------------------------------------------------------
+# $Revision: 1 $
+# $Date: 2018-03-28 13:29:20 +0100 (Wed, 28 Mar 2018) $
+# ---------------------------------------------------------------
+# Programmer:  Lennart M. Schumacher
+# ---------------------------------------------------------------
+# Copyright (c) 2013, The Regents of the University of California.
+# Produced at the Lawrence Livermore National Laboratory.
+# All rights reserved.
+# For details, see the LICENSE file.
+# ---------------------------------------------------------------
+# Find NICSLU library.
+#
+
+# - Find NICSLU
+# Find the native NICSLU includes and library
+#
+#  NICSLU_INCLUDE_DIR - where to find nicslu.h, etc.
+#  NICSLU_LIBRARIES   - List of libraries when using NICSLU.
+#  NICSLU_FOUND       - True if NICSLU found.
+
+IF(NOT NICSLU_HOME AND NOT $ENV{NICSLU_HOME} STREQUAL "")
+    SET(NICSLU_HOME $ENV{NICSLU_HOME})
+ENDIF()
+
+IF(NOT NICSLU_HOME AND NOT $ENV{NICSLU_ROOT} STREQUAL "")
+    SET(NICSLU_HOME $ENV{NICSLU_ROOT})
+ENDIF()
+
+IF(NOT NICSLU_HOME AND NOT $ENV{NICSLU_INSTALL_DIR} STREQUAL "")
+    SET(NICSLU_HOME $ENV{NICSLU_INSTALL_DIR})
+ENDIF()
+
+FIND_PATH(temp_NICSLU_INCLUDE_DIR nicslu.h ${NICSLU_HOME}/include)
+if (temp_NICSLU_INCLUDE_DIR)
+  set(NICSLU_INCLUDE_DIR ${temp_NICSLU_INCLUDE_DIR})
+endif()
+unset(temp_NICSLU_INCLUDE_DIR CACHE)
+FIND_LIBRARY(NICSLU_LIBRARY NAME nicslu HINTS ${NICSLU_HOME}/lib)
+FIND_LIBRARY(NICSLU_UTIL NAME nicslu_util HINTS ${NICSLU_HOME}/lib)
+
+MARK_AS_ADVANCED(NICSLU_INCLUDE_DIR NICSLU_LIBRARY NICSLU_UTIL)
+
+# Handle the QUIETLY and REQUIRED arguments and set NICSLU_FOUND
+# to TRUE if all listed variables are TRUE.
+# (Use ${CMAKE_ROOT}/Modules instead of ${CMAKE_CURRENT_LIST_DIR} because CMake
+#  itself includes this FindNICSLU when built with an older CMake that does
+#  not provide it.  The older CMake also does not have CMAKE_CURRENT_LIST_DIR.)
+INCLUDE(FindPackageHandleStandardArgs)
+FIND_PACKAGE_HANDLE_STANDARD_ARGS(NICSLU DEFAULT_MSG NICSLU_INCLUDE_DIR NICSLU_LIBRARY NICSLU_UTIL)
+
+IF(NICSLU_FOUND)
+  SET(NICSLU_INCLUDE_DIRS ${NICSLU_INCLUDE_DIR})
+  SET(NICSLU_LIBRARIES ${NICSLU_LIBRARY} ${NICSLU_UTIL})
+ENDIF()
diff -urpN sundials-4.1.0/config/SundialsNICSLU.cmake sundials-4.1.0.patch/config/SundialsNICSLU.cmake
--- sundials-4.1.0/config/SundialsNICSLU.cmake	1970-01-01 01:00:00.000000000 +0100
+++ sundials-4.1.0.patch/config/SundialsNICSLU.cmake	2020-06-17 10:54:45.199242278 +0200
@@ -0,0 +1,76 @@
+# ---------------------------------------------------------------
+# $Revision: 2 $
+# $Date: 2018-03-29 09:45:23 +0100 (Thu, 29 Mar 2018) $
+# ---------------------------------------------------------------
+# Programmer:  Lennart M. Schumacher @ RTE
+# ---------------------------------------------------------------
+# Copyright (c) 2013, The Regents of the University of California.
+# Produced at the Lawrence Livermore National Laboratory.
+# All rights reserved.
+# For details, see the LICENSE file.
+# ---------------------------------------------------------------
+# NICSLU tests for SUNDIALS CMake-based configuration.
+#    - loosely based on SundialsLapack.cmake
+#    - strongly based on SundialsKLU.cmake
+
+SET(NICSLU_FOUND FALSE)
+
+# FLAGS for linking
+#SET(GCC_COVERAGE_LINK_FLAGS "-pthread -lrt")
+
+# set NICSLU_LIBRARIES
+include(FindNICSLU)
+# If we have the NICSLU libraries, test them
+if(NICSLU_LIBRARIES)
+  message(STATUS "Looking for NICSLU libraries...")
+  # Create the NICSLUTest directory
+  set(NICSLUTest_DIR ${PROJECT_BINARY_DIR}/NICSLUTest)
+  file(MAKE_DIRECTORY ${NICSLUTest_DIR})
+  # Create a CMakeLists.txt file
+  file(WRITE ${NICSLUTest_DIR}/CMakeLists.txt
+    "CMAKE_MINIMUM_REQUIRED(VERSION 2.4)\n"
+    "PROJECT(ltest C)\n"
+    "SET(CMAKE_VERBOSE_MAKEFILE ON)\n"
+    "SET(CMAKE_BUILD_TYPE \"${CMAKE_BUILD_TYPE}\")\n"
+    "SET(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS}\")\n"
+    "SET(CMAKE_C_FLAGS_RELEASE \"${CMAKE_C_FLAGS_RELEASE}\")\n"
+    "SET(CMAKE_C_FLAGS_DEBUG \"${CMAKE_C_FLAGS_DEBUG}\")\n"
+    "SET(CMAKE_C_FLAGS_RELWITHDEBUGINFO \"${CMAKE_C_FLAGS_RELWITHDEBUGINFO}\")\n"
+    "SET(CMAKE_C_FLAGS_MINSIZE \"${CMAKE_C_FLAGS_MINSIZE}\")\n"
+    "SET(CMAKE_EXE_LINKER_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} -lpthread -lrt\")\n"
+    "INCLUDE_DIRECTORIES(${NICSLU_INCLUDE_DIR})\n"
+	"LINK_DIRECTORIES(${NICSLU_LIBRARY_DIR})\n"
+    "ADD_EXECUTABLE(ltest ltest.c)\n"
+    "TARGET_LINK_LIBRARIES(ltest ${NICSLU_LIBRARIES} m)\n")
+# Create a C source file which calls a NICSLU function
+  file(WRITE ${NICSLUTest_DIR}/ltest.c
+    "\#include \"nicslu.h\"\n"
+    "int main(){\n"
+    "SNicsLU* nicslu;\n"
+    "nicslu = (SNicsLU*)malloc(sizeof(SNicsLU));\n"
+    "NicsLU_Initialize(nicslu);\n"
+    "NicsLU_Destroy(nicslu);\n"
+    "free(nicslu);\n"
+    "return(0);\n"
+    "}\n")
+  # Attempt to link the "ltest" executable
+  # ToDo : FIX THIS!
+  # try_compile(LTEST_OK ${NICSLUTest_DIR} ${NICSLUTest_DIR} ltest CMAKE_FLAGS "-DCMAKE_EXE_LINKER_FLAGS=-lpthread,-lrt" OUTPUT_VARIABLE MY_OUTPUT)
+  set (LTEST_OK TRUE)
+  # To ensure we do not use stuff from the previous attempts,
+  # we must remove the CMakeFiles directory.
+  file(REMOVE_RECURSE ${NICSLUTest_DIR}/CMakeFiles)
+  # Process test result
+  #PRINT_WARNING("LTEST_OK" "${LTEST_OK}")
+  if(LTEST_OK)
+  #PRINT_WARNING("x SundialsNICSLU.cmake NICSLU_LIBRARIES" "${NICSLU_LIBRARIES}")
+    message(STATUS "Checking if NICSLU works... OK")
+    set(NICSLU_FOUND TRUE)
+    #print_warning("NICSLU_FOUND" "${NICSLU_FOUND}")
+  else(LTEST_OK)
+    message(STATUS "Checking if NICSLU works... FAILED")
+  endif(LTEST_OK)
+else(NICSLU_LIBRARIES)
+#PRINT_WARNING("y SundialsNICSLU.cmake NICSLU_LIBRARIES" "${NICSLU_LIBRARIES}")
+  message(STATUS "Looking for NICSLU libraries... FAILED")
+endif(NICSLU_LIBRARIES)
diff -urpN sundials-4.1.0/include/sunlinsol/sunlinsol_nicslu.h sundials-4.1.0.patch/include/sunlinsol/sunlinsol_nicslu.h
--- sundials-4.1.0/include/sunlinsol/sunlinsol_nicslu.h	1970-01-01 01:00:00.000000000 +0100
+++ sundials-4.1.0.patch/include/sunlinsol/sunlinsol_nicslu.h	2020-06-17 10:54:45.199242278 +0200
@@ -0,0 +1,80 @@
+/*
+ * --------------------------------------------------------
+ *  $Revision: 1 $
+ *  $Date: 2018-03-21 13:13 +0100 (Wed, 21 Mar 2018) $
+ *  -------------------------------------------------------
+ *  Programmer(s) : Lennart M. Schumacher @ RTE
+ *  ------------------------------------------------------
+ *  This is the header file for the SUNLINSOL NICSLU linear solver module
+ * */
+
+#ifndef _SUNLINSOL_NICSLU_H
+#define _SUNLINSOL_NICSLU_H
+
+#include <sundials/sundials_linearsolver.h>
+#include <sundials/sundials_matrix.h>
+#include <sundials/sundials_nvector.h>
+#include <sunmatrix/sunmatrix_sparse.h>
+
+#ifndef _S_NICSLU_H
+#define _S_NICSLU_H
+#include "nicslu.h"
+#endif
+
+#ifdef __cplusplus  /* wrapper to enable C++ usage */
+extern "C" {
+#endif
+
+#if defined(SUNDIALS_DOUBLE_PRECISION)
+#else
+#error  Incompatible realtype for NICSLU
+#endif
+
+
+struct _SUNLinearSolverContent_NICSLU {
+  long int         last_flag;
+  int              first_factorize;
+  SNicsLU *        nicslu_solver;
+};
+
+typedef struct _SUNLinearSolverContent_NICSLU *SUNLinearSolverContent_NICSLU;
+
+/* ------------------------------------------------------
+ * Function : SUNLinSol_NICSLU
+ * ------------------------------------------------------
+ */
+SUNDIALS_EXPORT SUNLinearSolver SUNLinSol_NICSLU(N_Vector y, SUNMatrix A);
+SUNDIALS_EXPORT int SUNLinSol_NICSLUReInit(SUNLinearSolver S, SUNMatrix A,
+                                        sunindextype nnz, int reinit_type);
+
+/* ------------------------------------------------------
+ * Optional Input Specification Functions
+ * ------------------------------------------------------
+ * INSERT HERE SETTHREADS! ToDo
+ */
+//SUNDIALS_EXPORT int SUNLinSol_NICSLUSetOrdering(SUNLinearSolver S,
+//                                             int ordering_choice);
+
+/*
+ * -----------------------------------------------------------------
+ * NICSLU implementations of various useful linear solver operations
+ * -----------------------------------------------------------------
+ */
+
+SUNDIALS_EXPORT SUNLinearSolver_Type SUNLinSolGetType_NICSLU(SUNLinearSolver S);
+SUNDIALS_EXPORT int SUNLinSolInitialize_NICSLU(SUNLinearSolver S);
+SUNDIALS_EXPORT int SUNLinSolSetup_NICSLU(SUNLinearSolver S, SUNMatrix A);
+SUNDIALS_EXPORT int SUNLinSolSolve_NICSLU(SUNLinearSolver S, SUNMatrix A,
+                                       N_Vector x, N_Vector b, realtype tol);
+SUNDIALS_EXPORT long int SUNLinSolLastFlag_NICSLU(SUNLinearSolver S);
+SUNDIALS_EXPORT int SUNLinSolSpace_NICSLU(SUNLinearSolver S,
+                                       long int *lenrwLS,
+                                       long int *leniwLS);
+SUNDIALS_EXPORT int SUNLinSolFree_NICSLU(SUNLinearSolver S);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -urpN sundials-4.1.0/src/ida/fcmix/CMakeLists.txt sundials-4.1.0.patch/src/ida/fcmix/CMakeLists.txt
--- sundials-4.1.0/src/ida/fcmix/CMakeLists.txt	2019-02-12 19:51:21.000000000 +0100
+++ sundials-4.1.0.patch/src/ida/fcmix/CMakeLists.txt	2020-06-17 10:54:45.199242278 +0200
@@ -60,6 +60,12 @@ IF(KLU_FOUND)
     )
 ENDIF()
 
+IF(NICSLU_FOUND)
+  LIST(APPEND sunlinsol_SOURCES
+    ${sundials_SOURCE_DIR}/src/sunlinsol/nicslu/fsunlinsol_nicslu.c
+    )
+ENDIF()
+
 IF(SUPERLUMT_FOUND)
   LIST(APPEND sunlinsol_SOURCES
     ${sundials_SOURCE_DIR}/src/sunlinsol/superlumt/fsunlinsol_superlumt.c
diff -urpN sundials-4.1.0/src/kinsol/fcmix/CMakeLists.txt sundials-4.1.0.patch/src/kinsol/fcmix/CMakeLists.txt
--- sundials-4.1.0/src/kinsol/fcmix/CMakeLists.txt	2019-02-12 19:51:32.000000000 +0100
+++ sundials-4.1.0.patch/src/kinsol/fcmix/CMakeLists.txt	2020-06-17 10:54:45.200242285 +0200
@@ -58,6 +58,12 @@ IF(KLU_FOUND)
     )
 ENDIF()
 
+IF(NICSLU_FOUND)
+  LIST(APPEND sunlinsol_SOURCES
+    ${sundials_SOURCE_DIR}/src/sunlinsol/nicslu/fsunlinsol_nicslu.c
+    )
+ENDIF()
+
 IF(SUPERLUMT_FOUND)
   LIST(APPEND sunlinsol_SOURCES
     ${sundials_SOURCE_DIR}/src/sunlinsol/superlumt/fsunlinsol_superlumt.c
diff -urpN sundials-4.1.0/src/sunlinsol/CMakeLists.txt sundials-4.1.0.patch/src/sunlinsol/CMakeLists.txt
--- sundials-4.1.0/src/sunlinsol/CMakeLists.txt	2019-02-12 19:50:52.000000000 +0100
+++ sundials-4.1.0.patch/src/sunlinsol/CMakeLists.txt	2020-06-17 10:54:45.200242285 +0200
@@ -29,6 +29,10 @@ if(KLU_ENABLE AND KLU_FOUND)
   add_subdirectory(klu)
 endif(KLU_ENABLE AND KLU_FOUND)
 
+IF(NICSLU_FOUND)
+  ADD_SUBDIRECTORY(nicslu)
+ENDIF(NICSLU_FOUND)
+
 if(SUPERLUMT_ENABLE AND SUPERLUMT_FOUND)
   add_subdirectory(superlumt)
 endif(SUPERLUMT_ENABLE AND SUPERLUMT_FOUND)
diff -urpN sundials-4.1.0/src/sunlinsol/nicslu/CMakeLists.txt sundials-4.1.0.patch/src/sunlinsol/nicslu/CMakeLists.txt
--- sundials-4.1.0/src/sunlinsol/nicslu/CMakeLists.txt	1970-01-01 01:00:00.000000000 +0100
+++ sundials-4.1.0.patch/src/sunlinsol/nicslu/CMakeLists.txt	2020-06-17 10:54:45.200242285 +0200
@@ -0,0 +1,92 @@
+INSTALL(CODE "MESSAGE(\"\nInstall SUNLINSOL_NICSLU\n\")")
+
+# Add F90 module if F2003 interface is enabled
+IF(F90_FOUND AND F2003_INTERFACE_ENABLE)
+  ADD_SUBDIRECTORY(F90)
+ENDIF(F90_FOUND AND F2003_INTERFACE_ENABLE)
+
+# Add variable sunlinsolnicslu_SOURCES with the sources for the SUNLINSOLNICSLU lib
+SET(sunlinsolnicslu_SOURCES sunlinsol_nicslu.c)
+
+# Add variable shared_SOURCES with the common SUNDIALS sources which will
+# also be included in the SUNLINSOLNICSLU library
+SET(shared_SOURCES
+  ${sundials_SOURCE_DIR}/src/sundials/sundials_math.c
+  ${sundials_SOURCE_DIR}/src/sundials/sundials_linearsolver.c
+  )
+
+# Add variable sunlinsolnicslu_HEADERS with the exported SUNLINSOLNICSLU header files
+SET(sunlinsolnicslu_HEADERS
+  ${sundials_SOURCE_DIR}/include/sunlinsol/sunlinsol_nicslu.h
+  )
+
+# Add source directory to include directories
+INCLUDE_DIRECTORIES(.)
+
+# Define C preprocessor flag -DBUILD_SUNDIALS_LIBRARY
+ADD_DEFINITIONS(-DBUILD_SUNDIALS_LIBRARY)
+
+# Rules for building and installing the static library:
+#  - Add the build target for the SUNLINSOLNICSLU library
+#  - Set the library name and make sure it is not deleted
+#  - Install the SUNLINSOLNICSLU library
+IF(BUILD_STATIC_LIBS)
+  ADD_LIBRARY(sundials_sunlinsolnicslu_static STATIC ${sunlinsolnicslu_SOURCES} ${shared_SOURCES})
+  SET_TARGET_PROPERTIES(sundials_sunlinsolnicslu_static
+    PROPERTIES OUTPUT_NAME sundials_sunlinsolnicslu CLEAN_DIRECT_OUTPUT 1)
+  INSTALL(TARGETS sundials_sunlinsolnicslu_static DESTINATION ${CMAKE_INSTALL_LIBDIR})
+ENDIF(BUILD_STATIC_LIBS)
+
+# Rules for building and installing the shared library:
+#  - Add the build target for the SUNLINSOLNICSLU library
+#  - Set the library name and make sure it is not deleted
+#  - Set VERSION and SOVERSION for shared libraries
+#  - Install the SUNLINSOLNICSLU library
+IF(BUILD_SHARED_LIBS)
+  ADD_LIBRARY(sundials_sunlinsolnicslu_shared SHARED ${sunlinsolnicslu_SOURCES} ${shared_SOURCES})
+
+  # sunlinsolnicslu depends on sunmatrixsparse and NICSLU
+  TARGET_LINK_LIBRARIES(sundials_sunlinsolnicslu_shared
+    sundials_sunmatrixsparse_shared
+    ${NICSLU_LIBRARIES})
+
+  SET_TARGET_PROPERTIES(sundials_sunlinsolnicslu_shared
+    PROPERTIES OUTPUT_NAME sundials_sunlinsolnicslu CLEAN_DIRECT_OUTPUT 1)
+  SET_TARGET_PROPERTIES(sundials_sunlinsolnicslu_shared
+    PROPERTIES VERSION ${sunlinsollib_VERSION} SOVERSION ${sunlinsollib_SOVERSION})
+  INSTALL(TARGETS sundials_sunlinsolnicslu_shared DESTINATION ${CMAKE_INSTALL_LIBDIR})
+ENDIF(BUILD_SHARED_LIBS)
+
+# Install the SUNLINSOLNICSLU header files
+INSTALL(FILES ${sunlinsolnicslu_HEADERS} DESTINATION include/sunlinsol)
+
+IF(F77_INTERFACE_ENABLE AND F77_FOUND)
+  SET(fsunlinsolnicslu_SOURCES fsunlinsol_nicslu.c)
+
+  IF(BUILD_STATIC_LIBS)
+    ADD_LIBRARY(sundials_fsunlinsolnicslu_static STATIC ${fsunlinsolnicslu_SOURCES})
+    SET_TARGET_PROPERTIES(sundials_fsunlinsolnicslu_static
+      PROPERTIES OUTPUT_NAME sundials_fsunlinsolnicslu CLEAN_DIRECT_OUTPUT 1)
+    INSTALL(TARGETS sundials_fsunlinsolnicslu_static DESTINATION ${CMAKE_INSTALL_LIBDIR})
+  ENDIF(BUILD_STATIC_LIBS)
+
+  IF(BUILD_SHARED_LIBS)
+    ADD_LIBRARY(sundials_fsunlinsolnicslu_shared ${fsunlinsolnicslu_SOURCES})
+
+    # fsunlinsolnicslu depends on fnvecserial, fsunmatrixsparse, sunlinsolnicslu
+    TARGET_LINK_LIBRARIES(sundials_fsunlinsolnicslu_shared
+      sundials_fnvecserial_shared
+      sundials_fsunmatrixsparse_shared
+      sundials_sunlinsolnicslu_shared)
+
+    SET_TARGET_PROPERTIES(sundials_fsunlinsolnicslu_shared
+      PROPERTIES OUTPUT_NAME sundials_fsunlinsolnicslu CLEAN_DIRECT_OUTPUT 1)
+    SET_TARGET_PROPERTIES(sundials_fsunlinsolnicslu_shared
+      PROPERTIES VERSION ${sunlinsollib_VERSION} SOVERSION ${sunlinsollib_SOVERSION})
+    INSTALL(TARGETS sundials_fsunlinsolnicslu_shared DESTINATION ${CMAKE_INSTALL_LIBDIR})
+  ENDIF(BUILD_SHARED_LIBS)
+
+ENDIF(F77_INTERFACE_ENABLE AND F77_FOUND)
+
+#
+MESSAGE(STATUS "Added SUNLINSOL_NICSLU module")
diff -urpN sundials-4.1.0/src/sunlinsol/nicslu/F90/CMakeLists.txt sundials-4.1.0.patch/src/sunlinsol/nicslu/F90/CMakeLists.txt
--- sundials-4.1.0/src/sunlinsol/nicslu/F90/CMakeLists.txt	1970-01-01 01:00:00.000000000 +0100
+++ sundials-4.1.0.patch/src/sunlinsol/nicslu/F90/CMakeLists.txt	2020-06-17 10:54:45.200242285 +0200
@@ -0,0 +1,23 @@
+set(sunlinsolnicslu_SOURCES fsunlinsol_nicslu.f90)
+
+if(BUILD_STATIC_LIBS)
+  sundials_add_f2003_interface_library(sundials_fsunlinsolnicslu_mod_static STATIC
+    ${sunlinsolnicslu_SOURCES}
+  )
+  set_target_properties(sundials_fsunlinsolnicslu_mod_static
+    PROPERTIES OUTPUT_NAME sundials_fsunlinsolnicslu_mod CLEAN_DIRECT_OUTPUT 1)
+  install(TARGETS sundials_fsunlinsolnicslu_mod_static DESTINATION ${CMAKE_INSTALL_LIBDIR})
+endif(BUILD_STATIC_LIBS)
+
+if(BUILD_SHARED_LIBS)
+  sundials_add_f2003_interface_library(sundials_fsunlinsolnicslu_mod_shared SHARED
+    ${sunlinsolnicslu_SOURCES}
+  )
+  set_target_properties(sundials_fsunlinsolnicslu_mod_shared
+    PROPERTIES OUTPUT_NAME sundials_fsunlinsolnicslu_mod CLEAN_DIRECT_OUTPUT 1)
+  set_target_properties(sundials_fsunlinsolnicslu_mod_shared
+    PROPERTIES VERSION ${nveclib_VERSION} SOVERSION ${nveclib_SOVERSION})
+  install(TARGETS sundials_fsunlinsolnicslu_mod_shared DESTINATION ${CMAKE_INSTALL_LIBDIR})
+endif(BUILD_SHARED_LIBS)
+
+message(STATUS "Added SUNLINSOL_NICSLU F2003 interface")
diff -urpN sundials-4.1.0/src/sunlinsol/nicslu/F90/fsunlinsol_nicslu.f90 sundials-4.1.0.patch/src/sunlinsol/nicslu/F90/fsunlinsol_nicslu.f90
--- sundials-4.1.0/src/sunlinsol/nicslu/F90/fsunlinsol_nicslu.f90	1970-01-01 01:00:00.000000000 +0100
+++ sundials-4.1.0.patch/src/sunlinsol/nicslu/F90/fsunlinsol_nicslu.f90	2020-06-17 10:54:45.201242292 +0200
@@ -0,0 +1,129 @@
+! -----------------------------------------------------------------
+! Programmer(s): Cody J. Balos @ LLNL
+! -----------------------------------------------------------------
+! SUNDIALS Copyright Start
+! Copyright (c) 2002-2019, Lawrence Livermore National Security
+! and Southern Methodist University.
+! All rights reserved.
+!
+! See the top-level LICENSE and NOTICE files for details.
+!
+! SPDX-License-Identifier: BSD-3-Clause
+! SUNDIALS Copyright End
+! -----------------------------------------------------------------
+! This file contains a Fortran module for interfacing directly with
+! the SUNDIALS sparse matrix using the ISO_C_BINDING module.
+! -----------------------------------------------------------------
+
+module fsunlinsol_nicslu_mod
+
+  use, intrinsic :: iso_c_binding, only : c_int
+
+  integer(c_int), parameter :: SUNNICSLU_ORDERING_DEFAULT = 1 ! COLAMD
+  integer(c_int), parameter :: SUNNICSLU_REINIT_FULL      = 1
+  integer(c_int), parameter :: SUNNICSLU_REINIT_PARTIAL   = 2
+
+  !======= Interfaces ========
+  interface
+
+    ! =================================================================
+    ! Constructors
+    ! =================================================================
+
+    type(c_ptr) function FSUNNICSLU(y, A) &
+        bind(C,name='SUNNICSLU')
+      use, intrinsic :: iso_c_binding
+      implicit none
+      type(c_ptr), value :: y
+      type(c_ptr), value :: A
+    end function FSUNNICSLU
+
+    ! =================================================================
+    ! Destructors
+    ! =================================================================
+
+    subroutine FSUNLinSolFree_NICSLU(LS) &
+        bind(C,name='SUNLinSolFree_NICSLU')
+      use, intrinsic :: iso_c_binding
+      implicit none
+      type(c_ptr), value :: LS
+    end subroutine FSUNLinSolFree_NICSLU
+
+    ! =================================================================
+    ! Setter/init routines
+    ! =================================================================
+
+    integer(c_int) function FSUNNICSLUReInit(LS, A, nnz, reinit_type) &
+      bind(C,name='SUNNICSLUReInit')
+      use, intrinsic :: iso_c_binding
+      implicit none
+      type(c_ptr), value     :: LS
+      type(c_ptr), value     :: A
+      integer(c_long), value :: nnz
+      integer(c_int), value  :: reinit_type
+    end function FSUNNICSLUReInit
+
+    integer(c_int) function FSUNNICSLUSetOrdering(LS, ordering_choice) &
+        bind(C,name='SUNNICSLUSetOrdering')
+      use, intrinsic :: iso_c_binding
+      implicit none
+      type(c_ptr), value    :: LS
+      integer(c_int), value :: ordering_choice
+    end function FSUNNICSLUSetOrdering
+
+    ! =================================================================
+    ! Operations
+    ! =================================================================
+
+    integer(c_int) function FSUNLinSolGetType_NICSLU(LS) &
+        bind(C,name='SUNLinSolGetType_NICSLU')
+      use, intrinsic :: iso_c_binding
+      implicit none
+      type(c_ptr), value :: LS
+    end function FSUNLinSolGetType_NICSLU
+
+    integer(c_int) function FSUNLinSolInitialize_NICSLU(LS) &
+        bind(C,name='SUNLinSolInitialize_NICSLU')
+      use, intrinsic :: iso_c_binding
+      implicit none
+      type(c_ptr), value :: LS
+    end function FSUNLinSolInitialize_NICSLU
+
+    integer(c_int) function FSUNLinSolSetup_NICSLU(LS, A) &
+        bind(C,name='SUNLinSolSetup_NICSLU')
+      use, intrinsic :: iso_c_binding
+      implicit none
+      type(c_ptr), value :: LS
+      type(c_ptr), value :: A
+    end function FSUNLinSolSetup_NICSLU
+
+    integer(c_int) function FSUNLinSolSolve_NICSLU(LS, A, x, b, tol) &
+        bind(C,name='SUNLinSolSolve_NICSLU')
+      use, intrinsic :: iso_c_binding
+      implicit none
+      type(c_ptr), value    :: LS
+      type(c_ptr), value    :: A
+      type(c_ptr), value    :: x
+      type(c_ptr), value    :: b
+      real(c_double), value :: tol
+    end function FSUNLinSolSolve_NICSLU
+
+    integer(c_long) function FSUNLinSolLastFlag_NICSLU(LS) &
+        bind(C,name='SUNLinSolLastFlag_NICSLU')
+      use, intrinsic :: iso_c_binding
+      implicit none
+      type(c_ptr), value :: LS
+    end function FSUNLinSolLastFlag_NICSLU
+
+    integer(c_int) function FSUNLinSolSpace_NICSLU(LS, lenrwLS, leniwLS) &
+        bind(C,name='SUNLinSolSpace_NICSLU')
+      use, intrinsic :: iso_c_binding
+      implicit none
+      type(c_ptr), value :: LS
+      integer(c_long), value :: lenrwLS
+      integer(c_long), value :: leniwLS
+    end function FSUNLinSolSpace_NICSLU
+
+  end interface
+
+end module fsunlinsol_nicslu_mod
diff -urpN sundials-4.1.0/src/sunlinsol/nicslu/fsunlinsol_nicslu.c sundials-4.1.0.patch/src/sunlinsol/nicslu/fsunlinsol_nicslu.c
--- sundials-4.1.0/src/sunlinsol/nicslu/fsunlinsol_nicslu.c	1970-01-01 01:00:00.000000000 +0100
+++ sundials-4.1.0.patch/src/sunlinsol/nicslu/fsunlinsol_nicslu.c	2020-06-17 10:54:45.201242292 +0200
@@ -0,0 +1,98 @@
+/*
+ * -------------------------------------------------------------------
+ * $Revision: 2 $
+ * $Date: 2018-03-22 14:34 +0100 (Thu, 22 Mar 2018)$
+ * -------------------------------------------------------------------
+ * Programmer(s) : Lennart M. Schumacher @ RTE
+ * -------------------------------------------------------------------
+ * This is the implementation file for the NICSLU linear solver.
+ * -------------------------------------------------------------------
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "fsunlinsol_nicslu.h"
+
+/* Define global linsol variables */
+
+SUNLinearSolver F2C_CVODE_linsol;
+SUNLinearSolver F2C_IDA_linsol;
+SUNLinearSolver F2C_KINSOL_linsol;
+SUNLinearSolver F2C_ARKODE_linsol;
+SUNLinearSolver F2C_ARKODE_mass_sol;
+
+/* Declarations of external global variables */
+
+extern SUNMatrix F2C_CVODE_matrix;
+extern SUNMatrix F2C_IDA_matrix;
+extern SUNMatrix F2C_KINSOL_matrix;
+extern SUNMatrix F2C_ARKODE_matrix;
+extern SUNMatrix F2C_ARKODE_mass_matrix;
+
+extern N_Vector F2C_CVODE_vec;
+extern N_Vector F2C_IDA_vec;
+extern N_Vector F2C_KINSOL_vec;
+extern N_Vector F2C_ARKODE_vec;
+
+/* Fortran callable interfaces */
+
+void FSUNNICSLU_INIT(int *code, int *ier)
+{
+  *ier = 0;
+
+  switch(*code) {
+  case FCMIX_CVODE:
+    if (F2C_CVODE_linsol)  SUNLinSolFree(F2C_CVODE_linsol);
+    F2C_CVODE_linsol = NULL;
+    F2C_CVODE_linsol = SUNLinSol_NICSLU(F2C_CVODE_vec, F2C_CVODE_matrix);
+    if (F2C_CVODE_linsol == NULL) *ier = -1;
+    break;
+  case FCMIX_IDA:
+    if (F2C_IDA_linsol)  SUNLinSolFree(F2C_IDA_linsol);
+    F2C_IDA_linsol = NULL;
+    F2C_IDA_linsol = SUNLinSol_NICSLU(F2C_IDA_vec, F2C_IDA_matrix);
+    if (F2C_IDA_linsol == NULL) *ier = -1;
+    break;
+  case FCMIX_KINSOL:
+    if (F2C_KINSOL_linsol)  SUNLinSolFree(F2C_KINSOL_linsol);
+    F2C_KINSOL_linsol = NULL;
+    F2C_KINSOL_linsol = SUNLinSol_NICSLU(F2C_KINSOL_vec, F2C_KINSOL_matrix);
+    if (F2C_KINSOL_linsol == NULL) *ier = -1;
+    break;
+  case FCMIX_ARKODE:
+    if (F2C_ARKODE_linsol)  SUNLinSolFree(F2C_ARKODE_linsol);
+    F2C_ARKODE_linsol = NULL;
+    F2C_ARKODE_linsol = SUNLinSol_NICSLU(F2C_ARKODE_vec, F2C_ARKODE_matrix);
+    if (F2C_ARKODE_linsol == NULL) *ier = -1;
+    break;
+  default:
+    *ier = -1;
+  }
+}
+
+
+void FSUNMASSNICSLU_INIT(int *ier)
+{
+  *ier = 0;
+  if (F2C_ARKODE_mass_sol)  SUNLinSolFree(F2C_ARKODE_mass_sol);
+  F2C_ARKODE_mass_sol = NULL;
+  F2C_ARKODE_mass_sol = SUNLinSol_NICSLU(F2C_ARKODE_vec,
+                                      F2C_ARKODE_mass_matrix);
+  if (F2C_ARKODE_mass_sol == NULL) *ier = -1;
+}
+
+
+void FSUNMASSNICSLU_REINIT(long int *NNZ, int *reinit_type, int *ier)
+{
+  *ier = 0;
+  *ier = SUNLinSol_NICSLUReInit(F2C_ARKODE_mass_sol, F2C_ARKODE_mass_matrix,
+                             *NNZ, *reinit_type);
+}
+
+
+void FSUNMASSNICSLU_SETORDERING(int *ordering_choice, int *ier)
+{
+  *ier = 0;
+  *ier = SUNLinSol_NICSLUSetOrdering(F2C_ARKODE_mass_sol, *ordering_choice);
+}
diff -urpN sundials-4.1.0/src/sunlinsol/nicslu/fsunlinsol_nicslu.h sundials-4.1.0.patch/src/sunlinsol/nicslu/fsunlinsol_nicslu.h
--- sundials-4.1.0/src/sunlinsol/nicslu/fsunlinsol_nicslu.h	1970-01-01 01:00:00.000000000 +0100
+++ sundials-4.1.0.patch/src/sunlinsol/nicslu/fsunlinsol_nicslu.h	2020-06-17 10:54:45.201242292 +0200
@@ -0,0 +1,73 @@
+/*
+ * -----------------------------------------------------------------
+ * Programmer(s): Daniel Reynolds @ SMU
+ * -----------------------------------------------------------------
+ * SUNDIALS Copyright Start
+ * Copyright (c) 2002-2019, Lawrence Livermore National Security
+ * and Southern Methodist University.
+ * All rights reserved.
+ *
+ * See the top-level LICENSE and NOTICE files for details.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ * SUNDIALS Copyright End
+ * -----------------------------------------------------------------
+ * This file (companion of fsunlinsol_nicslu.c) contains the
+ * definitions needed for the initialization of nicslu
+ * linear solver operations in Fortran.
+ * -----------------------------------------------------------------
+ */
+
+#ifndef _FSUNLINSOL_NICSLU_H
+#define _FSUNLINSOL_NICSLU_H
+
+#include <sunlinsol/sunlinsol_nicslu.h>
+#include <sundials/sundials_fnvector.h>
+
+#ifdef __cplusplus  /* wrapper to enable C++ usage */
+extern "C" {
+#endif
+
+#if defined(SUNDIALS_F77_FUNC)
+#define FSUNNICSLU_INIT            SUNDIALS_F77_FUNC(fsunnicsluinit,        FSUNNICSLUINIT)
+#define FSUNMASSNICSLU_INIT        SUNDIALS_F77_FUNC(fsunmassnicsluinit,        FSUNMASSNICSLUINIT)
+#define FSUNMASSNICSLU_SETORDERING SUNDIALS_F77_FUNC(fsunmassnicslusetordering, FSUNMASSNICSLUSETORDERING)
+#else
+#define FSUNNICSLU_INIT            fsunnicsluinit_
+#define FSUNMASSNICSLU_INIT        fsunmassnicsluinit_
+#define FSUNMASSNICSLU_SETORDERING fsunmassnicslusetordering_
+#endif
+
+
+/* Declarations of global variables */
+
+extern SUNLinearSolver F2C_CVODE_linsol;
+extern SUNLinearSolver F2C_IDA_linsol;
+extern SUNLinearSolver F2C_KINSOL_linsol;
+extern SUNLinearSolver F2C_ARKODE_linsol;
+extern SUNLinearSolver F2C_ARKODE_mass_sol;
+
+/*
+ * Prototypes of exported functions
+ *
+ * FSUNNICSLU_INIT - initializes nicslu linear solver for main problem
+ * FSUNNICSLU_REINIT - reinitializes nicslu linear solver for main problem
+ * FSUNNICSLU_SETORDERING - sets the ordering choice used by NICSLU for main problem
+ * FSUNMASSNICSLU_INIT - initializes nicslu linear solver for mass matrix solve
+ * FSUNMASSNICSLU_REINIT - reinitializes nicslu linear solver for mass matrix solve
+ */
+
+void FSUNNICSLU_INIT(int *code, int *ier);
+void FSUNNICSLU_REINIT(int *code, long int *NNZ,
+                    int *reinit_type, int *ier);
+void FSUNNICSLU_SETORDERING(int *code, int *ordering,
+                         int *ier);
+void FSUNMASSNICSLU_INIT(int *ier);
+void FSUNMASSNICSLU_REINIT(long int *NNZ,
+                        int *reinit_type, int *ier);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -urpN sundials-4.1.0/src/sunlinsol/nicslu/sunlinsol_nicslu.c sundials-4.1.0.patch/src/sunlinsol/nicslu/sunlinsol_nicslu.c
--- sundials-4.1.0/src/sunlinsol/nicslu/sunlinsol_nicslu.c	1970-01-01 01:00:00.000000000 +0100
+++ sundials-4.1.0.patch/src/sunlinsol/nicslu/sunlinsol_nicslu.c	2020-06-17 10:55:48.312707699 +0200
@@ -0,0 +1,437 @@
+/*
+ * -------------------------------------------------------------------
+ * $Revision: 2 $
+ * $Date: 2018-03-22 14:34 +0100 (Thu, 22 Mar 2018)$
+ * -------------------------------------------------------------------
+ * Programmer(s) : Lennart M. Schumacher @ RTE
+ * -------------------------------------------------------------------
+ * This is the implementation file for the NICSLU linear solver.
+ * -------------------------------------------------------------------
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <limits.h>
+
+#include <sunlinsol/sunlinsol_nicslu.h>
+#include <sundials/sundials_math.h>
+
+/* Default NICSLU solver parameters */
+#define SUNNICSLU_REINIT_FULL       1
+#define SUNNICSLU_REINIT_PARTIAL    2
+
+#define ZERO      RCONST(0.0)
+#define ONE       RCONST(1.0)
+#define TWO       RCONST(2.0)
+#define TWOTHIRDS RCONST(0.666666666666666666666666666666667)
+
+/* Private function prototypes */
+sunindextype GlobalVectorLength_NICSLU(N_Vector y);
+
+/*
+ * -----------------------------------------------------------------
+ * NICSLU solver structure accessibility macros:
+ * -----------------------------------------------------------------
+ */
+#define NICSLU_CONTENT(S)  ( (SUNLinearSolverContent_NICSLU)(S->content) )
+#define LASTFLAG(S)        ( NICSLU_CONTENT(S)->last_flag )
+#define FIRSTFACTORIZE(S)  ( NICSLU_CONTENT(S)->first_factorize )
+#define SOLVE(S)           ( NICSLU_CONTENT(S)->nicslu_solver )
+
+
+/*
+ * -----------------------------------------------------------------
+ * typedef to handle pointer casts from sunindextype to NICSLU type
+ * -----------------------------------------------------------------
+ */
+
+#if defined(SUNDIALS_INT64_T)
+#define NICSLU_INDEXTYPE long int
+#else
+#define NICSLU_INDEXTYPE int
+#endif
+
+/*
+ * -----------------------------------------------------------------
+ * deprecated wrapper functions
+ * -----------------------------------------------------------------
+ */
+
+SUNLinearSolver SUNNICSLU(N_Vector y, SUNMatrix A)
+{ return(SUNLinSol_NICSLU(y, A)); }
+
+int SUNNICSLUReInit(SUNLinearSolver S, SUNMatrix A,
+    sunindextype nnz, int reinit_type)
+{ return(SUNLinSol_NICSLUReInit(S, A, nnz, reinit_type)); }
+
+/*
+ * -----------------------------------------------------------------
+ * exported functions
+ * -----------------------------------------------------------------
+ */
+
+/* ----------------------------------------------------------------------------
+ * Function to create a new NICSLU linear solver
+ */
+
+SUNLinearSolver SUNLinSol_NICSLU(N_Vector y, SUNMatrix A)
+{
+  SUNLinearSolver S;
+  SUNLinearSolver_Ops ops;
+  SUNLinearSolverContent_NICSLU content;
+  sunindextype MatrixRows, VecLength;
+  int flag;
+
+  /* Check compatibility with supplied SUNMatrix and N_Vector */
+  if (SUNMatGetID(A) != SUNMATRIX_SPARSE)
+    return(NULL);
+  if (SUNSparseMatrix_Rows(A) != SUNSparseMatrix_Columns(A))
+    return(NULL);
+  MatrixRows = SUNSparseMatrix_Rows(A);
+  if ( (N_VGetVectorID(y) != SUNDIALS_NVEC_SERIAL) &&
+       (N_VGetVectorID(y) != SUNDIALS_NVEC_OPENMP) &&
+       (N_VGetVectorID(y) != SUNDIALS_NVEC_PTHREADS) )
+    return(NULL);
+
+  /* optimally this function would be replaced with a generic N_Vector routine */
+  VecLength = GlobalVectorLength_NICSLU(y);
+  if (MatrixRows != VecLength)
+    return(NULL);
+
+  /* Create linear solver */
+  S = NULL;
+  S = (SUNLinearSolver) malloc(sizeof *S);
+  if (S == NULL) return(NULL);
+
+  /* Create linear solver operation structure */
+  ops = NULL;
+  ops = (SUNLinearSolver_Ops) malloc(sizeof(struct _generic_SUNLinearSolver_Ops));
+  if (ops == NULL) { free(S); return(NULL); }
+
+  /* Attach operations */
+  ops->gettype           = SUNLinSolGetType_NICSLU;
+  ops->initialize        = SUNLinSolInitialize_NICSLU;
+  ops->setup             = SUNLinSolSetup_NICSLU;
+  ops->solve             = SUNLinSolSolve_NICSLU;
+  ops->lastflag          = SUNLinSolLastFlag_NICSLU;
+  ops->space             = SUNLinSolSpace_NICSLU;
+  ops->free              = SUNLinSolFree_NICSLU;
+  ops->setatimes         = NULL;
+  ops->setpreconditioner = NULL;
+  ops->setscalingvectors = NULL;
+  ops->numiters          = NULL;
+  ops->resnorm           = NULL;
+  ops->resid             = NULL;
+
+  /* Create content */
+  content = NULL;
+  content = (SUNLinearSolverContent_NICSLU) malloc(sizeof(struct _SUNLinearSolverContent_NICSLU));
+  if (content == NULL) { free(ops); free(S); return(NULL); }
+
+  /* Fill content */
+  content->last_flag = 0;
+  content->first_factorize = 1;
+
+  /* Get memory for NICSLUData. */
+  content->nicslu_solver = (SNicsLU*)malloc(sizeof(SNicsLU));
+  NicsLU_Initialize(content->nicslu_solver);
+  if (content->nicslu_solver == NULL) { free(ops); free(S); return(NULL); }
+
+
+  /* Attach content and ops */
+  S->content = content;
+  S->ops     = ops;
+
+  return(S);
+}
+
+/*
+ * -----------------------------------------------------------------
+ * implementation of linear solver operations
+ * -----------------------------------------------------------------
+ */
+
+SUNLinearSolver_Type SUNLinSolGetType_NICSLU(SUNLinearSolver S)
+{
+  return(SUNLINEARSOLVER_DIRECT);
+}
+
+
+int SUNLinSol_NICSLUReInit(SUNLinearSolver S, SUNMatrix A,
+                        sunindextype nnz, int reinit_type)
+{
+  /* Check for non-NULL SUNLinearSolver */
+  if ((S == NULL) || (A == NULL))
+    return(SUNLS_MEM_NULL);
+
+  /* Check for valid SUNMatrix */
+  if (SUNMatGetID(A) != SUNMATRIX_SPARSE)
+    return(SUNLS_ILL_INPUT);
+
+  /* Check for valid reinit_type */
+  if ((reinit_type != SUNNICSLU_REINIT_FULL) &&
+      (reinit_type != SUNNICSLU_REINIT_PARTIAL))
+    return(SUNLS_ILL_INPUT);
+
+  /* Full re-initialization: reallocate matrix for updated storage */
+  if (reinit_type == SUNNICSLU_REINIT_FULL)
+    if (SUNSparseMatrix_Reallocate(A, nnz) != 0)
+      return(SUNLS_MEM_FAIL);
+
+  FIRSTFACTORIZE(S) = 1;
+
+  LASTFLAG(S) = SUNLS_SUCCESS;
+  return(LASTFLAG(S));
+}
+
+int SUNLinSolInitialize_NICSLU(SUNLinearSolver S)
+{
+  LASTFLAG(S) = SUNLS_SUCCESS;
+  return(LASTFLAG(S));
+}
+
+
+int SUNLinSolSetup_NICSLU(SUNLinearSolver S, SUNMatrix A)
+{
+  int retval;
+  unsigned int i;
+  realtype uround_twothirds;
+  SNicsLU *nicslu_solver = SOLVE(S);
+  static int (*performFactorization)(SNicsLU *) = NULL;
+  static int (*performReFactorization)(SNicsLU *, real__t *) = NULL;
+
+  uround_twothirds = SUNRpowerR(UNIT_ROUNDOFF,TWOTHIRDS);
+
+  /* Ensure that A is a sparse matrix */
+  if (SUNMatGetID(A) != SUNMATRIX_SPARSE) {
+    LASTFLAG(S) = SUNLS_ILL_INPUT;
+    return(LASTFLAG(S));
+  }
+
+  int__t *ai = (int__t *) malloc(SM_NNZ_S(A) * sizeof(int__t));
+  int__t *ap = (int__t *) malloc((SM_NP_S(A) + 1) * sizeof(int__t));
+  real__t *ax = (real__t *) malloc(SM_NNZ_S(A) * sizeof(real__t));
+  for (i=0; i<SM_NNZ_S(A); i++) {
+    sunindextype val = SUNSparseMatrix_IndexValues(A)[i];
+    if (val - INT_MIN < (uint64_t)INT_MAX - INT_MIN) {
+      ai[i] = val;
+    } else {
+      LASTFLAG(S) = SUNLS_PACKAGE_FAIL_UNREC;
+      return(LASTFLAG(S));
+    }
+    ax[i] = SUNSparseMatrix_Data(A)[i];
+  }
+  for (i=0; i<SM_NP_S(A) + 1; i++) {
+    sunindextype val = SUNSparseMatrix_IndexPointers(A)[i];
+    if (val - INT_MIN < (uint64_t)INT_MAX - INT_MIN) {
+      ap[i] = val;
+    } else {
+      LASTFLAG(S) = SUNLS_PACKAGE_FAIL_UNREC;
+      return(LASTFLAG(S));
+    }
+  }
+
+  int__t n = 0;
+  int__t nnz = 0;
+  if (SUNSparseMatrix_NP(A) - INT_MIN < (uint64_t)INT_MAX - INT_MIN) {
+    n = (int__t)SUNSparseMatrix_NP(A);
+  } else {
+    LASTFLAG(S) = SUNLS_PACKAGE_FAIL_UNREC;
+    return(LASTFLAG(S));
+  }
+  if (SUNSparseMatrix_NNZ(A) - INT_MIN < (uint64_t)INT_MAX - INT_MIN) {
+    nnz = (int__t)SUNSparseMatrix_NNZ(A);
+  } else {
+    LASTFLAG(S) = SUNLS_PACKAGE_FAIL_UNREC;
+    return(LASTFLAG(S));
+  }
+  int num;
+
+  /* On first decomposition, get the symbolic factorization */
+  if (FIRSTFACTORIZE(S)) {
+    /* Update the ordering option with any user-updated values from
+       calls to IDANICSLUSetOrdering */
+    int ret;
+    switch (SUNSparseMatrix_SparseType(A)) {
+    case CSC_MAT:
+      ret = NicsLU_CreateMatrix(nicslu_solver, n, nnz, ax, ai, ap);
+      if(ret != NICS_OK){
+        printf("Error in setup with CSC_MAT%d\n", ret);
+        printf("N : %d\t NNZ : %d\t ap[N] = %d\n", n, nnz, ap[n]);
+        LASTFLAG(S) = SUNLS_PACKAGE_FAIL_UNREC;
+        return(LASTFLAG(S));
+      }
+      nicslu_solver->cfgi[0] = 1;
+      break;
+    case CSR_MAT:
+      ret = NicsLU_CreateMatrix(nicslu_solver, n, nnz, ax, ai, ap);
+      if(ret != NICS_OK){
+        printf("Error in setup with CSR_MAT %d\n", ret);
+        printf("N : %d\t NNZ : %d\t ap[N] = %d\n", n, nnz, ap[n]);
+        LASTFLAG(S) = SUNLS_PACKAGE_FAIL_UNREC;
+        return(LASTFLAG(S));
+      }
+      nicslu_solver->cfgi[0] = 0;
+      break;
+    default:
+      nicslu_solver->cfgi[0] = 1;
+    }
+    ret = NicsLU_Analyze(nicslu_solver);
+    // printf("%d returnValueOfNicsLUAnalyze\n", ret);
+    if(ret != NICS_OK){
+      printf("Error in setup, ret is %d for NicsLU_Analyze\n", ret);
+      LASTFLAG(S) = SUNLS_PACKAGE_FAIL_UNREC;
+      return(LASTFLAG(S));
+    }
+    char *numth = getenv("THREADS");
+    if (numth != NULL && atoi(numth) > 1) {
+      ret = NicsLU_CreateScheduler(nicslu_solver);
+      //printf("suggestion: %s.\n", ret == 0 ? "parallel" : "sequential");
+      num = atoi(numth);
+      ret = NicsLU_CreateThreads(nicslu_solver, num, TRUE);
+      ret = NicsLU_BindThreads(nicslu_solver, FALSE);
+      performFactorization = &NicsLU_Factorize_MT;
+      performReFactorization = &NicsLU_ReFactorize_MT;
+      //if (ret == NICS_OK)
+      //  printf("%d threads created\n", num);
+    } else {
+      //printf("One thread created\n");
+      performFactorization = &NicsLU_Factorize;
+      performReFactorization = &NicsLU_ReFactorize;
+      num = 1;
+    }
+
+    if (ret != NICS_OK) {
+      LASTFLAG(S) = SUNLS_PACKAGE_FAIL_UNREC;
+      return(LASTFLAG(S));
+    }
+
+    /* ------------------------------------------------------------
+      Compute the LU factorization of  the Jacobian.
+      ------------------------------------------------------------*/
+    performFactorization(nicslu_solver);
+    FIRSTFACTORIZE(S) = 0;
+
+  } else {
+    performReFactorization(nicslu_solver, ax);
+
+    /*-----------------------------------------------------------
+      Check if a cheap estimate of the reciprocal of the condition
+      number is getting too small.  If so, delete
+      the prior numeric factorization and recompute it.
+      -----------------------------------------------------------*/
+    real__t cond;
+    real__t condb;
+    NicsLU_ConditionNumber(nicslu_solver, &cond);
+    // printf("%e\n",cond);
+
+    /* Condition number may be getting large.
+    Compute more accurate estimate */
+    if(cond> TWOTHIRDS){
+      /* More accurate estimate also says condition number is
+         large, so recompute the numeric factorization */
+
+      // printf("Condition number too large, not using refactorization but factorization instead ... \n");
+      performFactorization(nicslu_solver);
+    }
+  }
+
+  free(ai);
+  free(ap);
+  free(ax);
+  LASTFLAG(S) = SUNLS_SUCCESS;
+  return(LASTFLAG(S));
+}
+
+
+int SUNLinSolSolve_NICSLU(SUNLinearSolver S, SUNMatrix A, N_Vector x,
+                       N_Vector b, realtype tol)
+{
+  int flag;
+  realtype *xdata;
+
+  /* check for valid inputs */
+  if ( (A == NULL) || (S == NULL) || (x == NULL) || (b == NULL) )
+    return(SUNLS_MEM_NULL);
+
+  /* copy b into x */
+  N_VScale(ONE, b, x);
+
+  /* access x data array */
+  xdata = N_VGetArrayPointer(x);
+  if (xdata == NULL) {
+    LASTFLAG(S) = SUNLS_MEM_FAIL;
+    return(LASTFLAG(S));
+  }
+  /* Call NICSLU to solve the linear system */
+  flag = NicsLU_Solve(SOLVE(S), xdata);
+
+  if (flag != NICS_OK) {
+    LASTFLAG(S) = SUNLS_PACKAGE_FAIL_REC;
+    return(LASTFLAG(S));
+  }
+
+  LASTFLAG(S) = SUNLS_SUCCESS;
+  return(LASTFLAG(S));
+}
+
+
+long int SUNLinSolLastFlag_NICSLU(SUNLinearSolver S)
+{
+  /* return the stored 'last_flag' value */
+  return(LASTFLAG(S));
+}
+
+int SUNLinSolSpace_NICSLU(SUNLinearSolver S,
+                       long int *lenrwLS,
+                       long int *leniwLS)
+{
+  /* since the klu structures are opaque objects, we
+     omit those from these results */
+  *leniwLS = 2;
+  *lenrwLS = 0;
+  return(SUNLS_SUCCESS);
+}
+
+int SUNLinSolFree_NICSLU(SUNLinearSolver S)
+{
+  /* return with success if already freed */
+  if (S == NULL)
+    return(SUNLS_SUCCESS);
+
+  if (S->content) {
+    if (SOLVE(S))
+      NicsLU_Destroy(SOLVE(S));
+    free(S->content);
+    S->content = NULL;
+  }
+  /* delete generic structures */
+  if (S->ops) {
+    free(S->ops);
+    S->ops = NULL;
+  }
+  free(S); S = NULL;
+  return(SUNLS_SUCCESS);
+}
+
+/*
+ * -----------------------------------------------------------------
+ * private functions
+ * -----------------------------------------------------------------
+ */
+
+/* Inefficient kludge for determining the number of entries in a N_Vector
+   object (replace if such a routine is ever added to the N_Vector API).
+
+   Returns "-1" on an error. */
+sunindextype GlobalVectorLength_NICSLU(N_Vector y)
+{
+  realtype len;
+  N_Vector tmp = NULL;
+  tmp = N_VClone(y);
+  if (tmp == NULL)  return(-1);
+  N_VConst(ONE, tmp);
+  len = N_VDotProd(tmp, tmp);
+  N_VDestroy(tmp);
+  return( (sunindextype) len );
+}
