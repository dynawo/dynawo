diff --git a/CMakeLists.txt b/CMakeLists.txt
index b0d1540..c0aac14 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -9,7 +9,7 @@ cmake_minimum_required(VERSION 3.12 FATAL_ERROR)
 project(powsybl-iidm4cpp)
 
 set(IIDM_VERSION_MAJOR 1)
-set(IIDM_VERSION_MINOR 6)
+set(IIDM_VERSION_MINOR 10)
 set(IIDM_VERSION_PATCH 0)
 set(IIDM_VERSION ${IIDM_VERSION_MAJOR}.${IIDM_VERSION_MINOR}.${IIDM_VERSION_PATCH})
 set(IIDM_SOVERSION ${IIDM_VERSION_MAJOR})
diff --git a/extensions/entsoe/src/MergedXnodeXmlSerializer.cpp b/extensions/entsoe/src/MergedXnodeXmlSerializer.cpp
index 68f4717..9c7047d 100644
--- a/extensions/entsoe/src/MergedXnodeXmlSerializer.cpp
+++ b/extensions/entsoe/src/MergedXnodeXmlSerializer.cpp
@@ -36,6 +36,10 @@ MergedXnodeXmlSerializer::MergedXnodeXmlSerializer() :
             .put(converter::xml::IidmXmlVersion::V1_4(), {"1.0", "1.1"})
             .put(converter::xml::IidmXmlVersion::V1_5(), {"1.0", "1.1"})
             .put(converter::xml::IidmXmlVersion::V1_6(), {"1.0", "1.1"})
+            .put(converter::xml::IidmXmlVersion::V1_7(), {"1.0", "1.1"})
+            .put(converter::xml::IidmXmlVersion::V1_8(), {"1.0", "1.1"})
+            .put(converter::xml::IidmXmlVersion::V1_9(), {"1.0", "1.1"})
+            .put(converter::xml::IidmXmlVersion::V1_10(), {"1.0", "1.1"})
             .build(),
         stdcxx::MapBuilder<std::string, std::string>()
             .put("1.0", "http://www.itesla_project.eu/schema/iidm/ext/merged_xnode/1_0")
diff --git a/extensions/iidm/src/BranchObservability.cpp b/extensions/iidm/src/BranchObservability.cpp
index 37a2602..1855cf1 100644
--- a/extensions/iidm/src/BranchObservability.cpp
+++ b/extensions/iidm/src/BranchObservability.cpp
@@ -34,35 +34,35 @@ const std::string& BranchObservability::getName() const {
 }
 
 stdcxx::CReference<ObservabilityQuality> BranchObservability::getQualityP1() const {
-    return stdcxx::cref(m_qualityP1);
+    return stdcxx::cref<ObservabilityQuality>(m_qualityP1);
 }
 
 stdcxx::Reference<ObservabilityQuality> BranchObservability::getQualityP1() {
-    return stdcxx::ref(m_qualityP1);
+    return stdcxx::ref<ObservabilityQuality>(m_qualityP1);
 }
 
 stdcxx::CReference<ObservabilityQuality> BranchObservability::getQualityP2() const {
-    return stdcxx::cref(m_qualityP2);
+    return stdcxx::cref<ObservabilityQuality>(m_qualityP2);
 }
 
 stdcxx::Reference<ObservabilityQuality> BranchObservability::getQualityP2() {
-    return stdcxx::ref(m_qualityP2);
+    return stdcxx::ref<ObservabilityQuality>(m_qualityP2);
 }
 
 stdcxx::CReference<ObservabilityQuality> BranchObservability::getQualityQ1() const {
-    return stdcxx::cref(m_qualityQ1);
+    return stdcxx::cref<ObservabilityQuality>(m_qualityQ1);
 }
 
 stdcxx::Reference<ObservabilityQuality> BranchObservability::getQualityQ1() {
-    return stdcxx::ref(m_qualityQ1);
+    return stdcxx::ref<ObservabilityQuality>(m_qualityQ1);
 }
 
 stdcxx::CReference<ObservabilityQuality> BranchObservability::getQualityQ2() const {
-    return stdcxx::cref(m_qualityQ2);
+    return stdcxx::cref<ObservabilityQuality>(m_qualityQ2);
 }
 
 stdcxx::Reference<ObservabilityQuality> BranchObservability::getQualityQ2() {
-    return stdcxx::ref(m_qualityQ2);
+    return stdcxx::ref<ObservabilityQuality>(m_qualityQ2);
 }
 
 const std::type_index& BranchObservability::getType() const {
diff --git a/include/powsybl/iidm/Battery.hpp b/include/powsybl/iidm/Battery.hpp
index 2678064..0d4c5d8 100644
--- a/include/powsybl/iidm/Battery.hpp
+++ b/include/powsybl/iidm/Battery.hpp
@@ -21,7 +21,7 @@ public:  // Identifiable
 
 public:
     Battery(VariantManagerHolder& network, const std::string& id, const std::string& name, bool fictitious,
-        double p0, double q0, double minP, double maxP);
+        double targetP, double targetQ, double minP, double maxP);
 
     ~Battery() noexcept override = default;
 
@@ -29,17 +29,17 @@ public:
 
     double getMinP() const;
 
-    double getP0() const;
+    double getTargetP() const;
 
-    double getQ0() const;
+    double getTargetQ() const;
 
     Battery& setMaxP(double maxP);
 
     Battery& setMinP(double minP);
 
-    Battery& setP0(double p0);
+    Battery& setTargetP(double targetP);
 
-    Battery& setQ0(double q0);
+    Battery& setTargetQ(double targetQ);
 
 protected: // MultiVariantObject
     void allocateVariantArrayElement(const std::set<unsigned long>& indexes, unsigned long sourceIndex) override;
@@ -52,9 +52,9 @@ private: // Identifiable
     const std::string& getTypeDescription() const override;
 
 private:
-    std::vector<double> m_p0;
+    std::vector<double> m_targetP;
 
-    std::vector<double> m_q0;
+    std::vector<double> m_targetQ;
 
     double m_minP;
 
diff --git a/include/powsybl/iidm/BatteryAdder.hpp b/include/powsybl/iidm/BatteryAdder.hpp
index 489c208..78006f2 100644
--- a/include/powsybl/iidm/BatteryAdder.hpp
+++ b/include/powsybl/iidm/BatteryAdder.hpp
@@ -29,9 +29,9 @@ public:
 
     BatteryAdder& setMinP(double minP);
 
-    BatteryAdder& setP0(double p0);
+    BatteryAdder& setTargetP(double targetP);
 
-    BatteryAdder& setQ0(double q0);
+    BatteryAdder& setTargetQ(double targetQ);
 
 private: // IdentifiableAdder
     const std::string& getTypeDescription() const override;
@@ -42,9 +42,9 @@ private:
     friend class VoltageLevel;
 
 private:
-    double m_p0 = stdcxx::nan();
+    double m_targetP = stdcxx::nan();
 
-    double m_q0 = stdcxx::nan();
+    double m_targetQ = stdcxx::nan();
 
     double m_minP = stdcxx::nan();
 
diff --git a/include/powsybl/iidm/Bus.hpp b/include/powsybl/iidm/Bus.hpp
index 5d3f8d4..265e966 100644
--- a/include/powsybl/iidm/Bus.hpp
+++ b/include/powsybl/iidm/Bus.hpp
@@ -128,6 +128,15 @@ public:
 
     virtual void visitConnectedOrConnectableEquipments(TopologyVisitor& visitor) = 0;
 
+public:
+    double getFictitiousP0() const;
+
+    double getFictitiousQ0() const;
+
+    Bus& setFictitiousP0(double p0);
+
+    Bus& setFictitiousQ0(double q0);
+
 protected:
     Bus(const std::string& id, const std::string& name, bool fictitious);
 
@@ -148,6 +157,11 @@ private:
     friend class ConnectedComponentsManager;
 
     friend class SynchronousComponentsManager;
+
+private:
+    double m_fictitiousP0;
+
+    double m_fictitiousQ0;
 };
 
 }  // namespace iidm
diff --git a/include/powsybl/iidm/converter/Constants.hpp b/include/powsybl/iidm/converter/Constants.hpp
index 0b13361..93109d3 100644
--- a/include/powsybl/iidm/converter/Constants.hpp
+++ b/include/powsybl/iidm/converter/Constants.hpp
@@ -46,6 +46,12 @@ static const char* const BUS1 = "bus1";
 static const char* const BUS2 = "bus2";
 static const char* const BUS_BREAKER_TOPOLOGY = "busBreakerTopology";
 static const char* const BUSBAR_SECTION = "busbarSection";
+static const char* const C0P = "c0p";
+static const char* const C1P = "c1p";
+static const char* const C2P = "c2p";
+static const char* const C0Q = "c0q";
+static const char* const C1Q = "c1q";
+static const char* const C2Q = "c2q";
 static const char* const CASE_DATE = "caseDate";
 static const char* const CONNECTABLE_BUS = "connectableBus";
 static const char* const CONNECTABLE_BUS1 = "connectableBus1";
@@ -61,9 +67,13 @@ static const char* const CURRENT_LIMITS3 = "currentLimits3";
 static const char* const CURRENT_SECTION_COUNT = "currentSectionCount";
 static const char* const DANGLING_LINE = "danglingLine";
 static const char* const ENERGY_SOURCE = "energySource";
+static const char* const EXPONENTIAL_MODEL = "exponentialModel";
 static const char* const EXTENSION = "extension";
 static const char* const FICTITIOUS = "fictitious";
 static const char* const FICTITIOUS_ = "fictitious_";
+static const char* const FICTITIOUS_INJECTION = "inj";
+static const char* const FICTITIOUS_P0 = "fictitiousP0";
+static const char* const FICTITIOUS_Q0 = "fictitiousQ0";
 static const char* const FORECAST_DISTANCE = "forecastDistance";
 static const char* const G = "g";
 static const char* const G_PER_SECTION = "gPerSection";
@@ -101,6 +111,7 @@ static const char* const MAXIMUM_SECTION_COUNT = "maximumSectionCount";
 static const char* const MIN_MAX_REACTIVE_LIMITS = "minMaxReactiveLimits";
 static const char* const MIN_P = "minP";
 static const char* const MIN_Q = "minQ";
+static const char* const MINIMUM_VALIDATION_LEVEL = "minimumValidationLevel";
 static const char* const NAME = "name";
 static const char* const NAME_ = "name_";
 static const char* const NETWORK = "network";
@@ -111,6 +122,8 @@ static const char* const NODE1 = "node1";
 static const char* const NODE2 = "node2";
 static const char* const NODES = "nodes";
 static const char* const NOMINAL_V = "nominalV";
+static const char* const NP = "np";
+static const char* const NQ = "nq";
 static const char* const OPEN = "open";
 static const char* const P = "p";
 static const char* const P0 = "p0";
@@ -158,6 +171,7 @@ static const char* const SHUNT_NON_LINEAR_MODEL = "shuntNonLinearModel";
 static const char* const SIDE = "side";
 static const char* const SOURCE_FORMAT = "sourceFormat";
 static const char* const STATIC_VAR_COMPENSATOR = "staticVarCompensator";
+static const char* const STEADY_STATE_HYPOTHESIS = "STEADY_STATE_HYPOTHESIS";
 static const char* const STEP = "step";
 static const char* const SUBSTATION = "substation";
 static const char* const SWITCH = "switch";
@@ -192,6 +206,7 @@ static const char* const X2 = "x2";
 static const char* const X3 = "x3";
 static const char* const XNODE_P_ = "xnodeP_";
 static const char* const XNODE_Q_ = "xnodeQ_";
+static const char* const ZIP_MODEL = "zipModel";
 
 std::string toString(const char* attribute, stdcxx::optional<int> index);
 
diff --git a/include/powsybl/iidm/converter/xml/IidmXmlVersion.hpp b/include/powsybl/iidm/converter/xml/IidmXmlVersion.hpp
index 742607f..96fa9b2 100644
--- a/include/powsybl/iidm/converter/xml/IidmXmlVersion.hpp
+++ b/include/powsybl/iidm/converter/xml/IidmXmlVersion.hpp
@@ -62,6 +62,26 @@ public:
      */
     static const IidmXmlVersion& V1_6();
 
+    /**
+     * IIDM V1.7 (http://www.powsybl.org)
+     */
+    static const IidmXmlVersion& V1_7();
+
+    /**
+     * IIDM V1.8 (http://www.powsybl.org)
+     */
+    static const IidmXmlVersion& V1_8();
+
+    /**
+     * IIDM V1.9 (http://www.powsybl.org)
+     */
+    static const IidmXmlVersion& V1_9();
+
+    /**
+     * IIDM V1.10 (http://www.powsybl.org)
+     */
+    static const IidmXmlVersion& V1_10();
+
 public:
     /**
      * Return the list of all supported XIIDM versions
diff --git a/include/powsybl/iidm/Load.hpp b/include/powsybl/iidm/Load.hpp
index cc85d4a..c71e793 100644
--- a/include/powsybl/iidm/Load.hpp
+++ b/include/powsybl/iidm/Load.hpp
@@ -8,9 +8,11 @@
 #ifndef POWSYBL_IIDM_LOAD_HPP
 #define POWSYBL_IIDM_LOAD_HPP
 
+#include <memory>
 #include <vector>
 
 #include <powsybl/iidm/Injection.hpp>
+#include <powsybl/iidm/LoadModel.hpp>
 #include <powsybl/iidm/LoadType.hpp>
 
 namespace powsybl {
@@ -29,12 +31,26 @@ public:
 
     const LoadType& getLoadType() const;
 
+    template <typename T, typename = typename std::enable_if<std::is_base_of<LoadModel, T>::value>::type>
+    const T& getModel() const;
+
+    template <typename T, typename = typename std::enable_if<std::is_base_of<LoadModel, T>::value>::type>
+    T& getModel();
+
+    const LoadModel& getModel() const;
+
+    LoadModel& getModel();
+
+    const LoadModelType& getModelType() const;
+
     double getP0() const;
 
     double getQ0() const;
 
     Load& setLoadType(const LoadType& loadType);
 
+    Load& setModel(std::unique_ptr<LoadModel>&& model);
+
     Load& setP0(double p0);
 
     Load& setQ0(double q0);
@@ -52,6 +68,8 @@ private: // Identifiable
 private:
     LoadType m_loadType;
 
+    std::unique_ptr<LoadModel> m_model;
+
     std::vector<double> m_p0;
 
     std::vector<double> m_q0;
@@ -61,4 +79,6 @@ private:
 
 }  // namespace powsybl
 
+#include <powsybl/iidm/Load.hxx>
+
 #endif  // POWSYBL_IIDM_LOAD_HPP
diff --git a/include/powsybl/iidm/Load.hxx b/include/powsybl/iidm/Load.hxx
new file mode 100644
index 0000000..74e5703
--- /dev/null
+++ b/include/powsybl/iidm/Load.hxx
@@ -0,0 +1,38 @@
+/**
+ * Copyright (c) 2023, RTE (http://www.rte-france.com)
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+#ifndef POWSYBL_IIDM_LOAD_HXX
+#define POWSYBL_IIDM_LOAD_HXX
+
+#include <powsybl/iidm/Load.hpp>
+#include <powsybl/iidm/ValidationException.hpp>
+
+namespace powsybl {
+
+namespace iidm {
+
+template <typename T, typename>
+const T& Load::getModel() const {
+    if (!m_model) {
+        throw ValidationException(*this, "load model is null");
+    }
+    if (stdcxx::isInstanceOf<T>(m_model)) {
+        return *dynamic_cast<const T*>(m_model.get());
+    }
+    throw ValidationException(*this, stdcxx::format("incorrect load model type %1%, expected %2%", stdcxx::demangle<T>(), stdcxx::demangle(*m_model)));
+}
+
+template <typename T, typename>
+T& Load::getModel() {
+    return const_cast<T&>(static_cast<const Load*>(this)->getModel<T>());
+}
+
+}  // namespace iidm
+
+}  // namespace powsybl
+
+#endif  // POWSYBL_IIDM_LOAD_HXX
diff --git a/include/powsybl/iidm/LoadExponentialModel.hpp b/include/powsybl/iidm/LoadExponentialModel.hpp
new file mode 100644
index 0000000..daeefb8
--- /dev/null
+++ b/include/powsybl/iidm/LoadExponentialModel.hpp
@@ -0,0 +1,47 @@
+/**
+ * Copyright (c) 2023, RTE (http://www.rte-france.com)
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+#ifndef POWSYBL_IIDM_LOADEXPONENTIALMODEL_HPP
+#define POWSYBL_IIDM_LOADEXPONENTIALMODEL_HPP
+
+#include <memory>
+
+#include <powsybl/iidm/LoadModel.hpp>
+
+namespace powsybl {
+
+namespace iidm {
+
+class Load;
+
+class LoadExponentialModel : public LoadModel {
+public:
+    LoadExponentialModel(double np, double nq);
+
+    ~LoadExponentialModel() noexcept override = default;
+
+    static std::unique_ptr<LoadModel> build(Load& load, double np, double nq);
+
+    double getNp() const;
+
+    double getNq() const;
+
+private:  // LoadModel
+
+    const LoadModelType& getType() const override;
+
+private:
+    double m_np;
+
+    double m_nq;
+};
+
+}  // namespace iidm
+
+}  // namespace powsybl
+
+#endif  // POWSYBL_IIDM_LOADEXPONENTIALMODEL_HPP
diff --git a/include/powsybl/iidm/LoadModel.hpp b/include/powsybl/iidm/LoadModel.hpp
new file mode 100644
index 0000000..e8e06ce
--- /dev/null
+++ b/include/powsybl/iidm/LoadModel.hpp
@@ -0,0 +1,35 @@
+/**
+ * Copyright (c) 2023, RTE (http://www.rte-france.com)
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+#ifndef POWSYBL_IIDM_LOADMODEL_HPP
+#define POWSYBL_IIDM_LOADMODEL_HPP
+
+#include <powsybl/iidm/LoadModelType.hpp>
+
+namespace powsybl {
+
+namespace iidm {
+
+class Load;
+
+class LoadModel {
+public:
+    LoadModel() = default;
+
+    virtual ~LoadModel() noexcept = default;
+
+private:
+    virtual const LoadModelType& getType() const = 0;
+
+    friend class Load;
+};
+
+}  // namespace iidm
+
+}  // namespace powsybl
+
+#endif  // POWSYBL_IIDM_LOADMODEL_HPP
diff --git a/include/powsybl/iidm/LoadModelType.hpp b/include/powsybl/iidm/LoadModelType.hpp
new file mode 100644
index 0000000..22438ee
--- /dev/null
+++ b/include/powsybl/iidm/LoadModelType.hpp
@@ -0,0 +1,25 @@
+/**
+ * Copyright (c) 2023, RTE (http://www.rte-france.com)
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+#ifndef POWSYBL_IIDM_LOADMODELTYPE_HPP
+#define POWSYBL_IIDM_LOADMODELTYPE_HPP
+
+namespace powsybl {
+
+namespace iidm {
+
+enum class LoadModelType : unsigned char {
+    NONE,
+    ZIP,
+    EXPONENTIAL
+};
+
+}  // namespace iidm
+
+}  // namespace powsybl
+
+#endif  // POWSYBL_IIDM_LOADMODELTYPE_HPP
diff --git a/include/powsybl/iidm/LoadZipModel.hpp b/include/powsybl/iidm/LoadZipModel.hpp
new file mode 100644
index 0000000..f8b98e5
--- /dev/null
+++ b/include/powsybl/iidm/LoadZipModel.hpp
@@ -0,0 +1,63 @@
+/**
+ * Copyright (c) 2023, RTE (http://www.rte-france.com)
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+#ifndef POWSYBL_IIDM_LOADZIPMODEL_HPP
+#define POWSYBL_IIDM_LOADZIPMODEL_HPP
+
+#include <memory>
+
+#include <powsybl/iidm/LoadModel.hpp>
+
+namespace powsybl {
+
+namespace iidm {
+
+class Load;
+
+class LoadZipModel : public LoadModel {
+public:
+    LoadZipModel(double c0p, double c1p, double c2p, double c0q, double c1q, double c2q);
+
+    ~LoadZipModel() noexcept override = default;
+
+    static std::unique_ptr<LoadModel> build(Load& load, double c0p, double c1p, double c2p, double c0q, double c1q, double c2q);
+
+    double getC0p() const;
+
+    double getC1p() const;
+
+    double getC2p() const;
+
+    double getC0q() const;
+
+    double getC1q() const;
+
+    double getC2q() const;
+
+private:  // LoadModel
+
+    const LoadModelType& getType() const override;
+
+private:
+    double m_c0p;
+
+    double m_c1p;
+
+    double m_c2p;
+
+    double m_c0q;
+
+    double m_c1q;
+
+    double m_c2q;
+};
+
+}  // namespace iidm
+
+}  // namespace powsybl
+
+#endif  // POWSYBL_IIDM_LOADZIPMODEL_HPP
diff --git a/include/powsybl/iidm/Network.hpp b/include/powsybl/iidm/Network.hpp
index c371a25..c64c65b 100644
--- a/include/powsybl/iidm/Network.hpp
+++ b/include/powsybl/iidm/Network.hpp
@@ -18,6 +18,7 @@
 #include <powsybl/iidm/VariantArray.hpp>
 #include <powsybl/iidm/VariantManager.hpp>
 #include <powsybl/iidm/VariantManagerHolder.hpp>
+#include <powsybl/iidm/converter/Constants.hpp>
 #include <powsybl/iidm/converter/ExportOptions.hpp>
 #include <powsybl/iidm/converter/ImportOptions.hpp>
 #include <powsybl/stdcxx/DateTime.hpp>
@@ -259,6 +260,8 @@ public:
 
     stdcxx::range<Load> getLoads();
 
+    const std::string& getMinimumValidationLevel() const;
+
     const ShuntCompensator& getShuntCompensator(const std::string& id) const;
 
     ShuntCompensator& getShuntCompensator(const std::string& id);
@@ -369,6 +372,8 @@ public:
 
     Network& setForecastDistance(int forecastDistance);
 
+    Network& setMinimumValidationLevel(const std::string& minimumValidationLevel);
+
 protected:  // MultiVariantObject
     void allocateVariantArrayElement(const std::set<unsigned long>& indexes, unsigned long sourceIndex) override;
 
@@ -414,6 +419,8 @@ private:
 
     std::string m_sourceFormat;
 
+    std::string m_minimumValidationLevel{converter::STEADY_STATE_HYPOTHESIS};
+
     NetworkIndex m_networkIndex;
 
     VariantManager m_variantManager;
diff --git a/include/powsybl/iidm/ValidationUtils.hpp b/include/powsybl/iidm/ValidationUtils.hpp
index c249dbb..fedd3de 100644
--- a/include/powsybl/iidm/ValidationUtils.hpp
+++ b/include/powsybl/iidm/ValidationUtils.hpp
@@ -42,8 +42,12 @@ double checkBmin(const Validable& validable, double bMin);
 
 double checkBPerSection(const Validable& validable, double bPerSection);
 
+double checkCoefficient(const Validable& validable, double coefficient);
+
 const HvdcLine::ConvertersMode& checkConvertersMode(const Validable& validable, const HvdcLine::ConvertersMode& converterMode);
 
+double checkExponent(const Validable& validable, double n);
+
 int checkForecastDistance(const Validable& validable, int forecastDistance);
 
 double checkG(const Validable& validable, double g);
diff --git a/include/powsybl/iidm/VoltageLevelViews.hpp b/include/powsybl/iidm/VoltageLevelViews.hpp
index e81d032..61e1df8 100644
--- a/include/powsybl/iidm/VoltageLevelViews.hpp
+++ b/include/powsybl/iidm/VoltageLevelViews.hpp
@@ -123,6 +123,10 @@ public:
 
     virtual stdcxx::range<BusbarSection> getBusbarSections() = 0;
 
+    virtual double getFictitiousP0(unsigned long node) const = 0;
+
+    virtual double getFictitiousQ0(unsigned long node) const = 0;
+
     virtual unsigned long getInternalConnectionCount() const = 0;
 
     virtual stdcxx::const_range<InternalConnection> getInternalConnections() const = 0;
@@ -177,6 +181,10 @@ public:
 
     virtual void removeSwitch(const std::string& switchId) = 0;
 
+    virtual NodeBreakerView& setFictitiousP0(unsigned long node, double p0) = 0;
+
+    virtual NodeBreakerView& setFictitiousQ0(unsigned long node, double q0) = 0;
+
     virtual void traverse(unsigned long node, const TopologyTraverser& traverser) const = 0;
 
     virtual void traverse(stdcxx::const_range<unsigned long>& nodes, const TopologyTraverser& traverser) const = 0;
diff --git a/include/powsybl/stdcxx/reference.hpp b/include/powsybl/stdcxx/reference.hpp
index ce81b0c..dde1c37 100644
--- a/include/powsybl/stdcxx/reference.hpp
+++ b/include/powsybl/stdcxx/reference.hpp
@@ -108,8 +108,8 @@ CReference<T> cref(const std::unique_ptr<T>& pointer) {
     return static_cast<bool>(pointer) ? CReference<T>(*pointer) : CReference<T>();
 }
 
-template <typename T, typename = typename std::enable_if<!std::is_abstract<T>::value>::type>
-CReference<T> cref(const stdcxx::optional<T>& optional) {
+template <typename T, typename U, typename = typename std::enable_if<!std::is_abstract<U>::value && std::is_same<T, U>::value>::type>
+CReference<T> cref(const stdcxx::optional<U>& optional) {
     return static_cast<bool>(optional) ? CReference<T>(*optional) : CReference<T>();
 }
 
@@ -138,8 +138,8 @@ Reference<T> ref(const std::unique_ptr<T>& pointer) {
     return static_cast<bool>(pointer) ? Reference<T>(*pointer) : Reference<T>();
 }
 
-template <typename T, typename = typename std::enable_if<!std::is_abstract<T>::value>::type>
-Reference<T> ref(stdcxx::optional<T>& optional) {
+template <typename T, typename U, typename = typename std::enable_if<!std::is_abstract<U>::value && std::is_same<T, U>::value>::type>
+Reference<T> ref(stdcxx::optional<U>& optional) {
     return static_cast<bool>(optional) ? Reference<T>(*optional) : Reference<T>();
 }
 
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 894ddde..f1a89ba 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -77,7 +77,9 @@ set(IIDM_SOURCES
     iidm/Load.cpp
     iidm/LoadAdder.cpp
     iidm/LoadingLimits.cpp
+    iidm/LoadExponentialModel.cpp
     iidm/LoadType.cpp
+    iidm/LoadZipModel.cpp
     iidm/MergedBus.cpp
     iidm/MinMaxReactiveLimits.cpp
     iidm/MinMaxReactiveLimitsAdder.cpp
@@ -175,6 +177,7 @@ set(IIDM_SOURCES
     iidm/converter/xml/NetworkXml.cpp
     iidm/converter/xml/NetworkXmlReaderContext.cpp
     iidm/converter/xml/NetworkXmlWriterContext.cpp
+    iidm/converter/xml/NodeBreakerViewFictitiousInjectionXml.cpp
     iidm/converter/xml/NodeBreakerViewInternalConnectionXml.cpp
     iidm/converter/xml/NodeBreakerViewSwitchXml.cpp
     iidm/converter/xml/PropertiesXml.cpp
diff --git a/src/iidm/Battery.cpp b/src/iidm/Battery.cpp
index 03dfb1f..d6dcdba 100644
--- a/src/iidm/Battery.cpp
+++ b/src/iidm/Battery.cpp
@@ -14,10 +14,10 @@ namespace powsybl {
 namespace iidm {
 
 Battery::Battery(VariantManagerHolder& network, const std::string& id, const std::string& name, bool fictitious,
-    double p0, double q0, double minP, double maxP) :
+    double targetP, double targetQ, double minP, double maxP) :
     Injection(id, name, fictitious),
-    m_p0(network.getVariantManager().getVariantArraySize(), checkP0(*this, p0)),
-    m_q0(network.getVariantManager().getVariantArraySize(), checkQ0(*this, q0)),
+    m_targetP(network.getVariantManager().getVariantArraySize(), checkP0(*this, targetP)),
+    m_targetQ(network.getVariantManager().getVariantArraySize(), checkQ0(*this, targetQ)),
     m_minP(checkMinP(*this, minP)),
     m_maxP(checkMaxP(*this, maxP)) {
     checkActivePowerLimits(*this, minP, maxP);
@@ -27,16 +27,16 @@ void Battery::allocateVariantArrayElement(const std::set<unsigned long>& indexes
     Injection::allocateVariantArrayElement(indexes, sourceIndex);
 
     for (auto index : indexes) {
-        m_p0[index] = m_p0[sourceIndex];
-        m_q0[index] = m_q0[sourceIndex];
+        m_targetP[index] = m_targetP[sourceIndex];
+        m_targetQ[index] = m_targetQ[sourceIndex];
     }
 }
 
 void Battery::extendVariantArraySize(unsigned long initVariantArraySize, unsigned long number, unsigned long sourceIndex) {
     Injection::extendVariantArraySize(initVariantArraySize, number, sourceIndex);
 
-    m_p0.resize(m_p0.size() + number, m_p0[sourceIndex]);
-    m_q0.resize(m_q0.size() + number, m_q0[sourceIndex]);
+    m_targetP.resize(m_targetP.size() + number, m_targetP[sourceIndex]);
+    m_targetQ.resize(m_targetQ.size() + number, m_targetQ[sourceIndex]);
 }
 
 double Battery::getMaxP() const {
@@ -47,12 +47,12 @@ double Battery::getMinP() const {
     return m_minP;
 }
 
-double Battery::getP0() const {
-    return m_p0.at(getNetwork().getVariantIndex());
+double Battery::getTargetP() const {
+    return m_targetP.at(getNetwork().getVariantIndex());
 }
 
-double Battery::getQ0() const {
-    return m_q0.at(getNetwork().getVariantIndex());
+double Battery::getTargetQ() const {
+    return m_targetQ.at(getNetwork().getVariantIndex());
 }
 
 const IdentifiableType& Battery::getType() const {
@@ -69,8 +69,8 @@ const std::string& Battery::getTypeDescription() const {
 void Battery::reduceVariantArraySize(unsigned long number) {
     Injection::reduceVariantArraySize(number);
 
-    m_p0.resize(m_p0.size() - number);
-    m_q0.resize(m_q0.size() - number);
+    m_targetP.resize(m_targetP.size() - number);
+    m_targetQ.resize(m_targetQ.size() - number);
 }
 
 Battery& Battery::setMaxP(double maxP) {
@@ -89,15 +89,15 @@ Battery& Battery::setMinP(double minP) {
     return *this;
 }
 
-Battery& Battery::setP0(double p0) {
-    checkP0(*this, p0);
-    m_p0[getNetwork().getVariantIndex()] = p0;
+Battery& Battery::setTargetP(double targetP) {
+    checkP0(*this, targetP);
+    m_targetP[getNetwork().getVariantIndex()] = targetP;
 
     return *this;
 }
 
-Battery& Battery::setQ0(double q0) {
-    m_q0[getNetwork().getVariantIndex()] = checkQ0(*this, q0);
+Battery& Battery::setTargetQ(double targetQ) {
+    m_targetQ[getNetwork().getVariantIndex()] = checkQ0(*this, targetQ);
 
     return *this;
 }
diff --git a/src/iidm/BatteryAdder.cpp b/src/iidm/BatteryAdder.cpp
index 20c7a74..9dc5ac1 100644
--- a/src/iidm/BatteryAdder.cpp
+++ b/src/iidm/BatteryAdder.cpp
@@ -23,13 +23,13 @@ BatteryAdder::BatteryAdder(VoltageLevel& voltageLevel) :
 }
 
 Battery& BatteryAdder::add() {
-    checkP0(*this, m_p0);
-    checkQ0(*this, m_q0);
+    checkP0(*this, m_targetP);
+    checkQ0(*this, m_targetQ);
     checkMinP(*this, m_minP);
     checkMaxP(*this, m_maxP);
     checkActivePowerLimits(*this, m_minP, m_maxP);
 
-    std::unique_ptr<Battery> ptrBattery = stdcxx::make_unique<Battery>(getNetwork(), checkAndGetUniqueId(), getName(), isFictitious(), m_p0, m_q0, m_minP, m_maxP);
+    std::unique_ptr<Battery> ptrBattery = stdcxx::make_unique<Battery>(getNetwork(), checkAndGetUniqueId(), getName(), isFictitious(), m_targetP, m_targetQ, m_minP, m_maxP);
     auto& battery = getNetwork().checkAndAdd<Battery>(std::move(ptrBattery));
 
     Terminal& terminal = battery.addTerminal(checkAndGetTerminal());
@@ -54,13 +54,13 @@ BatteryAdder& BatteryAdder::setMinP(double minP) {
     return *this;
 }
 
-BatteryAdder& BatteryAdder::setP0(double p0) {
-    m_p0 = p0;
+BatteryAdder& BatteryAdder::setTargetP(double targetP) {
+    m_targetP = targetP;
     return *this;
 }
 
-BatteryAdder& BatteryAdder::setQ0(double q0) {
-    m_q0 = q0;
+BatteryAdder& BatteryAdder::setTargetQ(double targetQ) {
+    m_targetQ = targetQ;
     return *this;
 }
 
diff --git a/src/iidm/Bus.cpp b/src/iidm/Bus.cpp
index 30b62cc..503d2c0 100644
--- a/src/iidm/Bus.cpp
+++ b/src/iidm/Bus.cpp
@@ -31,7 +31,9 @@ namespace powsybl {
 namespace iidm {
 
 Bus::Bus(const std::string& id, const std::string& name, bool fictitious) :
-    Identifiable(id, name, fictitious) {
+    Identifiable(id, name, fictitious),
+    m_fictitiousP0(stdcxx::nan()),
+    m_fictitiousQ0(stdcxx::nan()) {
 }
 
 template <typename T>
@@ -60,6 +62,14 @@ stdcxx::range<DanglingLine> Bus::getDanglingLines() {
     return getAll<DanglingLine>();
 }
 
+double Bus::getFictitiousP0() const {
+    return m_fictitiousP0;
+}
+
+double Bus::getFictitiousQ0() const {
+    return m_fictitiousQ0;
+}
+
 stdcxx::const_range<Generator> Bus::getGenerators() const {
     return getAll<Generator>();
 }
@@ -237,6 +247,16 @@ bool Bus::isInMainSynchronousComponent() const {
     return static_cast<bool>(sc) && (sc.get().getNum() == ComponentConstants::MAIN_NUM);
 }
 
+Bus& Bus::setFictitiousP0(double p0) {
+    m_fictitiousP0 = p0;
+    return *this;
+}
+
+Bus& Bus::setFictitiousQ0(double q0) {
+    m_fictitiousQ0 = q0;
+    return *this;
+}
+
 void Bus::visitConnectedEquipments(TopologyVisitor& visitor) {
     TopologyVisitor::visitEquipments(getConnectedTerminals(), visitor);
 }
diff --git a/src/iidm/converter/xml/BatteryXml.cpp b/src/iidm/converter/xml/BatteryXml.cpp
index e9cbd4b..29255b5 100644
--- a/src/iidm/converter/xml/BatteryXml.cpp
+++ b/src/iidm/converter/xml/BatteryXml.cpp
@@ -31,13 +31,15 @@ const char* BatteryXml::getRootElementName() const {
 }
 
 Battery& BatteryXml::readRootElementAttributes(BatteryAdder& adder, NetworkXmlReaderContext& context) const {
-    const auto& p0 = context.getReader().getAttributeValue<double>(P0);
-    const auto& q0 = context.getReader().getAttributeValue<double>(Q0);
+    const std::string& targetPName = context.getVersion() <= IidmXmlVersion::V1_7() ? P0 : TARGET_P;
+    const std::string& targetQName = context.getVersion() <= IidmXmlVersion::V1_7() ? Q0 : TARGET_Q;
+    const auto& targetP = context.getReader().getAttributeValue<double>(targetPName);
+    const auto& targetQ = context.getReader().getAttributeValue<double>(targetQName);
     const auto& minP = context.getReader().getAttributeValue<double>(MIN_P);
     const auto& maxP = context.getReader().getAttributeValue<double>(MAX_P);
     readNodeOrBus(adder, context);
-    Battery& battery = adder.setP0(p0)
-        .setQ0(q0)
+    Battery& battery = adder.setTargetP(targetP)
+        .setTargetQ(targetQ)
         .setMinP(minP)
         .setMaxP(maxP)
         .add();
@@ -57,8 +59,10 @@ void BatteryXml::readSubElements(Battery& battery, NetworkXmlReaderContext& cont
 }
 
 void BatteryXml::writeRootElementAttributes(const Battery& battery, const VoltageLevel& /*voltageLevel*/, NetworkXmlWriterContext& context) const {
-    context.getWriter().writeAttribute(P0, battery.getP0());
-    context.getWriter().writeAttribute(Q0, battery.getQ0());
+    const std::string& targetPName = context.getVersion() <= IidmXmlVersion::V1_7() ? P0 : TARGET_P;
+    const std::string& targetQName = context.getVersion() <= IidmXmlVersion::V1_7() ? Q0 : TARGET_Q;
+    context.getWriter().writeAttribute(targetPName, battery.getTargetP());
+    context.getWriter().writeAttribute(targetQName, battery.getTargetQ());
     context.getWriter().writeAttribute(MIN_P, battery.getMinP());
     context.getWriter().writeAttribute(MAX_P, battery.getMaxP());
     writeNodeOrBus(battery.getTerminal(), context);
diff --git a/src/iidm/converter/xml/BusXml.cpp b/src/iidm/converter/xml/BusXml.cpp
index d8381f4..5e75095 100644
--- a/src/iidm/converter/xml/BusXml.cpp
+++ b/src/iidm/converter/xml/BusXml.cpp
@@ -34,6 +34,11 @@ Bus& BusXml::readRootElementAttributes(BusAdder& adder, NetworkXmlReaderContext&
     Bus& b = adder.add();
     b.setV(v);
     b.setAngle(angle);
+    IidmXmlUtil::runFromMinimumVersion(IidmXmlVersion::V1_8(), context.getVersion(), [&context, &b]() {
+        const auto& fictP0 = context.getReader().getOptionalAttributeValue(FICTITIOUS_P0, stdcxx::nan());
+        const auto& fictQ0 = context.getReader().getOptionalAttributeValue(FICTITIOUS_Q0, stdcxx::nan());
+        b.setFictitiousP0(fictP0).setFictitiousQ0(fictQ0);
+    });
     return b;
 }
 
@@ -46,6 +51,10 @@ void BusXml::readSubElements(Bus& bus, NetworkXmlReaderContext& context) const {
 void BusXml::writeRootElementAttributes(const Bus& bus, const VoltageLevel& /*voltageLevel*/, NetworkXmlWriterContext& context) const {
     context.getWriter().writeOptionalAttribute(V, bus.getV());
     context.getWriter().writeOptionalAttribute(ANGLE, bus.getAngle());
+    IidmXmlUtil::runFromMinimumVersion(IidmXmlVersion::V1_8(), context.getVersion(), [&context, &bus]() {
+        context.getWriter().writeOptionalAttribute(FICTITIOUS_P0, bus.getFictitiousP0(), 0.0);
+        context.getWriter().writeOptionalAttribute(FICTITIOUS_Q0, bus.getFictitiousQ0(), 0.0);
+    });
 }
 
 }  // namespace xml
diff --git a/src/iidm/converter/xml/IidmXmlVersion.cpp b/src/iidm/converter/xml/IidmXmlVersion.cpp
index de78592..92768bf 100644
--- a/src/iidm/converter/xml/IidmXmlVersion.cpp
+++ b/src/iidm/converter/xml/IidmXmlVersion.cpp
@@ -67,14 +67,18 @@ const IidmXmlVersions& IidmXmlVersion::all() {
         std::cref(IidmXmlVersion::V1_3()),
         std::cref(IidmXmlVersion::V1_4()),
         std::cref(IidmXmlVersion::V1_5()),
-        std::cref(IidmXmlVersion::V1_6())
+        std::cref(IidmXmlVersion::V1_6()),
+        std::cref(IidmXmlVersion::V1_7()),
+        std::cref(IidmXmlVersion::V1_8()),
+        std::cref(IidmXmlVersion::V1_9()),
+        std::cref(IidmXmlVersion::V1_10())
     }};
 
     return s_versions;
 }
 
 const IidmXmlVersion& IidmXmlVersion::CURRENT_IIDM_XML_VERSION() {
-    return V1_6();
+    return V1_10();
 }
 
 const IidmXmlVersion& IidmXmlVersion::fromNamespaceURI(const std::string& namespaceURI) {
@@ -157,6 +161,26 @@ const IidmXmlVersion& IidmXmlVersion::V1_6() {
     return V1_6;
 }
 
+const IidmXmlVersion& IidmXmlVersion::V1_7() {
+    static IidmXmlVersion V1_7("powsybl.org", {{1, 7}});
+    return V1_7;
+}
+
+const IidmXmlVersion& IidmXmlVersion::V1_8() {
+    static IidmXmlVersion V1_8("powsybl.org", {{1, 8}});
+    return V1_8;
+}
+
+const IidmXmlVersion& IidmXmlVersion::V1_9() {
+    static IidmXmlVersion V1_9("powsybl.org", {{1, 9}});
+    return V1_9;
+}
+
+const IidmXmlVersion& IidmXmlVersion::V1_10() {
+    static IidmXmlVersion V1_10("powsybl.org", {{1, 10}});
+    return V1_10;
+}
+
 }  // namespace xml
 
 }  // namespace converter
diff --git a/src/iidm/converter/xml/LoadXml.cpp b/src/iidm/converter/xml/LoadXml.cpp
index c235a3e..ed59e8b 100644
--- a/src/iidm/converter/xml/LoadXml.cpp
+++ b/src/iidm/converter/xml/LoadXml.cpp
@@ -11,6 +11,8 @@
 
 #include <powsybl/iidm/Load.hpp>
 #include <powsybl/iidm/LoadAdder.hpp>
+#include <powsybl/iidm/LoadExponentialModel.hpp>
+#include <powsybl/iidm/LoadZipModel.hpp>
 #include <powsybl/iidm/VoltageLevel.hpp>
 #include <powsybl/iidm/converter/Constants.hpp>
 
@@ -51,7 +53,23 @@ Load& LoadXml::readRootElementAttributes(LoadAdder& loadAdder, NetworkXmlReaderC
 
 void LoadXml::readSubElements(Load& load, NetworkXmlReaderContext& context) const {
     context.getReader().readUntilEndElement(LOAD, [this, &load, &context]() {
-        AbstractConnectableXml::readSubElements(load, context);
+        if (context.getReader().getLocalName() == ZIP_MODEL) {
+            IidmXmlUtil::assertMinimumVersion(LOAD, ZIP_MODEL, ErrorMessage::NOT_SUPPORTED, IidmXmlVersion::V1_10(), context);
+            const auto& c0p = context.getReader().getAttributeValue<double>(C0P);
+            const auto& c1p = context.getReader().getAttributeValue<double>(C1P);
+            const auto& c2p = context.getReader().getAttributeValue<double>(C2P);
+            const auto& c0q = context.getReader().getAttributeValue<double>(C0Q);
+            const auto& c1q = context.getReader().getAttributeValue<double>(C1Q);
+            const auto& c2q = context.getReader().getAttributeValue<double>(C2Q);
+            load.setModel(LoadZipModel::build(load, c0p, c1p, c2p, c0q, c1q, c2q));
+        } else if (context.getReader().getLocalName() == EXPONENTIAL_MODEL) {
+            IidmXmlUtil::assertMinimumVersion(LOAD, EXPONENTIAL_MODEL, ErrorMessage::NOT_SUPPORTED, IidmXmlVersion::V1_10(), context);
+            const auto& np = context.getReader().getAttributeValue<double>(NP);
+            const auto& nq = context.getReader().getAttributeValue<double>(NQ);
+            load.setModel(LoadExponentialModel::build(load, np, nq));
+        } else {
+            AbstractConnectableXml::readSubElements(load, context);
+        }
     });
 }
 
@@ -63,6 +81,26 @@ void LoadXml::writeRootElementAttributes(const Load& load, const VoltageLevel& /
     writePQ(load.getTerminal(), context.getWriter());
 }
 
+void LoadXml::writeSubElements(const Load& load, const VoltageLevel& /*voltageLevel*/, NetworkXmlWriterContext& context) const {
+    IidmXmlUtil::runFromMinimumVersion(IidmXmlVersion::V1_10(), context.getVersion(), [&context, &load]() {
+        if (LoadModelType::ZIP == load.getModelType()) {
+            context.getWriter().writeStartElement(context.getVersion().getPrefix(), ZIP_MODEL);
+            context.getWriter().writeAttribute(C0P, load.getModel<LoadZipModel>().getC0p());
+            context.getWriter().writeAttribute(C1P, load.getModel<LoadZipModel>().getC1p());
+            context.getWriter().writeAttribute(C2P, load.getModel<LoadZipModel>().getC2p());
+            context.getWriter().writeAttribute(C0Q, load.getModel<LoadZipModel>().getC0q());
+            context.getWriter().writeAttribute(C1Q, load.getModel<LoadZipModel>().getC1q());
+            context.getWriter().writeAttribute(C2Q, load.getModel<LoadZipModel>().getC2q());
+            context.getWriter().writeEndElement();
+        } else if (LoadModelType::EXPONENTIAL == load.getModelType()) {
+            context.getWriter().writeStartElement(context.getVersion().getPrefix(), EXPONENTIAL_MODEL);
+            context.getWriter().writeAttribute(NP, load.getModel<LoadExponentialModel>().getNp());
+            context.getWriter().writeAttribute(NQ, load.getModel<LoadExponentialModel>().getNq());
+            context.getWriter().writeEndElement();
+        }
+    });
+}
+
 }  // namespace xml
 
 }  // namespace converter
diff --git a/src/iidm/converter/xml/LoadXml.hpp b/src/iidm/converter/xml/LoadXml.hpp
index c805851..fd19444 100644
--- a/src/iidm/converter/xml/LoadXml.hpp
+++ b/src/iidm/converter/xml/LoadXml.hpp
@@ -36,6 +36,8 @@ protected:  // AbstractIdentifiableXml
 
     void writeRootElementAttributes(const Load& load, const VoltageLevel& voltageLevel, NetworkXmlWriterContext& context) const override;
 
+    void writeSubElements(const Load& load, const VoltageLevel& voltageLevel, NetworkXmlWriterContext& context) const override;
+
 private:
     LoadXml() = default;
 
diff --git a/src/iidm/converter/xml/NetworkXml.cpp b/src/iidm/converter/xml/NetworkXml.cpp
index 8bacbd6..83d5d84 100644
--- a/src/iidm/converter/xml/NetworkXml.cpp
+++ b/src/iidm/converter/xml/NetworkXml.cpp
@@ -217,9 +217,12 @@ Network NetworkXml::read(const std::string& filename, std::istream& is, const Im
     const std::string& sourceFormat = reader.getAttributeValue(SOURCE_FORMAT);
     int forecastDistance = reader.getOptionalAttributeValue(FORECAST_DISTANCE, 0);
     const std::string& caseDateStr = reader.getAttributeValue(CASE_DATE);
+    std::string minimumValidationLevel{STEADY_STATE_HYPOTHESIS};
+    IidmXmlUtil::runFromMinimumVersion(IidmXmlVersion::V1_7(), version, [&minimumValidationLevel, &reader] { minimumValidationLevel = reader.getAttributeValue(MINIMUM_VALIDATION_LEVEL); });
 
     Network network(id, sourceFormat);
     network.setForecastDistance(forecastDistance);
+    network.setMinimumValidationLevel(minimumValidationLevel);
 
     try {
         network.setCaseDate(stdcxx::DateTime::parse(caseDateStr));
@@ -317,6 +320,7 @@ void NetworkXml::write(const std::string& filename, std::ostream& os, const Netw
     writer.writeAttribute(CASE_DATE, network.getCaseDate().toString());
     writer.writeAttribute(FORECAST_DISTANCE, network.getForecastDistance());
     writer.writeAttribute(SOURCE_FORMAT, network.getSourceFormat());
+    IidmXmlUtil::runFromMinimumVersion(IidmXmlVersion::V1_7(), version, [&writer, &network] { writer.writeAttribute(MINIMUM_VALIDATION_LEVEL, network.getMinimumValidationLevel()); });
 
     AliasesXml::write(network, NETWORK, context);
     PropertiesXml::write(network, context);
diff --git a/src/iidm/converter/xml/NodeBreakerViewFictitiousInjectionXml.cpp b/src/iidm/converter/xml/NodeBreakerViewFictitiousInjectionXml.cpp
new file mode 100644
index 0000000..f8590d5
--- /dev/null
+++ b/src/iidm/converter/xml/NodeBreakerViewFictitiousInjectionXml.cpp
@@ -0,0 +1,57 @@
+/**
+ * Copyright (c) 2019, RTE (http://www.rte-france.com)
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+#include "NodeBreakerViewFictitiousInjectionXml.hpp"
+
+#include <powsybl/iidm/VoltageLevel.hpp>
+#include <powsybl/iidm/converter/Constants.hpp>
+#include <powsybl/iidm/converter/xml/NetworkXmlReaderContext.hpp>
+#include <powsybl/iidm/converter/xml/NetworkXmlWriterContext.hpp>
+#include <powsybl/xml/XmlStreamReader.hpp>
+#include <powsybl/xml/XmlStreamWriter.hpp>
+
+namespace powsybl {
+
+namespace iidm {
+
+namespace converter {
+
+namespace xml {
+
+const NodeBreakerViewFictitiousInjectionXml& NodeBreakerViewFictitiousInjectionXml::getInstance() {
+    static NodeBreakerViewFictitiousInjectionXml s_instance;
+    return s_instance;
+}
+
+void NodeBreakerViewFictitiousInjectionXml::read(VoltageLevel& voltageLevel, const NetworkXmlReaderContext& context) const {
+    const auto& node = context.getReader().getAttributeValue<unsigned long>(NODE);
+    const auto& fictP0 = context.getReader().getOptionalAttributeValue(FICTITIOUS_P0, stdcxx::nan());
+    const auto& fictQ0 = context.getReader().getOptionalAttributeValue(FICTITIOUS_Q0, stdcxx::nan());
+    if (!std::isnan(fictP0)) {
+        voltageLevel.getNodeBreakerView().setFictitiousP0(node, fictP0);
+    }
+    if (!std::isnan(fictQ0)) {
+        voltageLevel.getNodeBreakerView().setFictitiousQ0(node, fictQ0);
+    }
+}
+
+void NodeBreakerViewFictitiousInjectionXml::write(unsigned long node, double fictP0, double fictQ0, NetworkXmlWriterContext& context) const {
+    context.getWriter().writeStartElement(context.getVersion().getPrefix(), FICTITIOUS_INJECTION);
+    context.getWriter().writeAttribute(NODE, node);
+    context.getWriter().writeOptionalAttribute(FICTITIOUS_P0, fictP0, 0.0);
+    context.getWriter().writeOptionalAttribute(FICTITIOUS_Q0, fictQ0, 0.0);
+    context.getWriter().writeEndElement();
+}
+
+}  // namespace xml
+
+}  // namespace converter
+
+}  // namespace iidm
+
+}  // namespace powsybl
+
diff --git a/src/iidm/converter/xml/NodeBreakerViewFictitiousInjectionXml.hpp b/src/iidm/converter/xml/NodeBreakerViewFictitiousInjectionXml.hpp
new file mode 100644
index 0000000..c856740
--- /dev/null
+++ b/src/iidm/converter/xml/NodeBreakerViewFictitiousInjectionXml.hpp
@@ -0,0 +1,48 @@
+/**
+ * Copyright (c) 2019, RTE (http://www.rte-france.com)
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+#ifndef POWSYBL_IIDM_CONVERTER_XML_NODEBREAKERVIEWFICTITIOUSINJECTIONXML_HPP
+#define POWSYBL_IIDM_CONVERTER_XML_NODEBREAKERVIEWFICTITIOUSINJECTIONXML_HPP
+
+namespace powsybl {
+
+namespace iidm {
+
+class VoltageLevel;
+
+namespace converter {
+
+namespace xml {
+
+class NetworkXmlReaderContext;
+class NetworkXmlWriterContext;
+
+class NodeBreakerViewFictitiousInjectionXml {
+public:
+    static const NodeBreakerViewFictitiousInjectionXml& getInstance();
+
+public:
+    void read(VoltageLevel& voltageLevel, const NetworkXmlReaderContext& context) const;
+
+    void write(unsigned long node, double p0, double q0, NetworkXmlWriterContext& context) const;
+
+private:
+    NodeBreakerViewFictitiousInjectionXml() = default;
+
+    ~NodeBreakerViewFictitiousInjectionXml() noexcept = default;
+};
+
+}  // namespace xml
+
+}  // namespace converter
+
+}  // namespace iidm
+
+}  // namespace powsybl
+
+#endif  // POWSYBL_IIDM_CONVERTER_XML_NODEBREAKERVIEWFICTITIOUSINJECTIONXML_HPP
+
diff --git a/src/iidm/converter/xml/ShuntCompensatorXml.cpp b/src/iidm/converter/xml/ShuntCompensatorXml.cpp
index 06095d9..12bacb0 100644
--- a/src/iidm/converter/xml/ShuntCompensatorXml.cpp
+++ b/src/iidm/converter/xml/ShuntCompensatorXml.cpp
@@ -170,7 +170,8 @@ void ShuntCompensatorXml::writeRootElementAttributes(const ShuntCompensator& shu
     IidmXmlUtil::writeDoubleAttributeFromMinimumVersion(SHUNT, TARGET_V, shuntCompensator.getTargetV(), ErrorMessage::NOT_DEFAULT_NOT_SUPPORTED, IidmXmlVersion::V1_2(), context);
     IidmXmlUtil::writeDoubleAttributeFromMinimumVersion(SHUNT, TARGET_DEADBAND, shuntCompensator.getTargetDeadband(), ErrorMessage::NOT_DEFAULT_NOT_SUPPORTED, IidmXmlVersion::V1_2(), context);
     writeNodeOrBus(shuntCompensator.getTerminal(), context);
-    writePQ(shuntCompensator.getTerminal(), context.getWriter());
+    IidmXmlUtil::runFromMinimumVersion(IidmXmlVersion::V1_9(), context.getVersion(), [&context, &shuntCompensator]() { context.getWriter().writeOptionalAttribute(P, shuntCompensator.getTerminal().getP()); });
+    context.getWriter().writeOptionalAttribute(Q, shuntCompensator.getTerminal().getQ());
 }
 
 void ShuntCompensatorXml::writeSubElements(const ShuntCompensator& sc, const VoltageLevel& /*voltageLevel*/, NetworkXmlWriterContext& context) const {
diff --git a/src/iidm/converter/xml/VoltageLevelXml.cpp b/src/iidm/converter/xml/VoltageLevelXml.cpp
index 5957abf..ce9d7f7 100644
--- a/src/iidm/converter/xml/VoltageLevelXml.cpp
+++ b/src/iidm/converter/xml/VoltageLevelXml.cpp
@@ -31,6 +31,7 @@
 #include "GeneratorXml.hpp"
 #include "LccConverterStationXml.hpp"
 #include "LoadXml.hpp"
+#include "NodeBreakerViewFictitiousInjectionXml.hpp"
 #include "NodeBreakerViewInternalConnectionXml.hpp"
 #include "NodeBreakerViewSwitchXml.hpp"
 #include "ShuntCompensatorXml.hpp"
@@ -108,6 +109,9 @@ void VoltageLevelXml::readNodeBreakerTopology(VoltageLevel& voltageLevel, Networ
             NodeBreakerViewInternalConnectionXml::getInstance().read(voltageLevel, context);
         } else if (context.getReader().getLocalName() == BUS) {
             readCalculatedBus(voltageLevel, context);
+        } else if (context.getReader().getLocalName() == FICTITIOUS_INJECTION) {
+            IidmXmlUtil::assertMinimumVersion(VOLTAGE_LEVEL, FICTITIOUS_INJECTION, xml::ErrorMessage::NOT_SUPPORTED, xml::IidmXmlVersion::V1_8(), context);
+            NodeBreakerViewFictitiousInjectionXml::getInstance().read(voltageLevel, context);
         } else {
             throw AssertionError(stdcxx::format("Unexpected element %1%", context.getReader().getLocalName()));
         }
@@ -259,6 +263,16 @@ void VoltageLevelXml::writeNodeBreakerTopology(const VoltageLevel& voltageLevel,
         }
     });
 
+    IidmXmlUtil::runFromMinimumVersion(IidmXmlVersion::V1_8(), context.getVersion(), [&context, &voltageLevel]() {
+        for (const auto& node : voltageLevel.getNodeBreakerView().getNodes()) {
+            const auto fictP0 = voltageLevel.getNodeBreakerView().getFictitiousP0(node);
+            const auto fictQ0 = voltageLevel.getNodeBreakerView().getFictitiousQ0(node);
+            if (!std::isnan(fictP0) || !std::isnan(fictQ0)) {
+                NodeBreakerViewFictitiousInjectionXml::getInstance().write(node, fictP0, fictQ0, context);
+            }
+        }
+    });
+
     context.getWriter().writeEndElement();
 }
 
diff --git a/src/iidm/extensions/SlackTerminalXmlSerializer.cpp b/src/iidm/extensions/SlackTerminalXmlSerializer.cpp
index a132f81..ad227e8 100644
--- a/src/iidm/extensions/SlackTerminalXmlSerializer.cpp
+++ b/src/iidm/extensions/SlackTerminalXmlSerializer.cpp
@@ -34,6 +34,10 @@ SlackTerminalXmlSerializer::SlackTerminalXmlSerializer() :
               .put(converter::xml::IidmXmlVersion::V1_4(), {"1.1"})
               .put(converter::xml::IidmXmlVersion::V1_5(), {"1.2"})
               .put(converter::xml::IidmXmlVersion::V1_6(), {"1.2"})
+              .put(converter::xml::IidmXmlVersion::V1_7(), {"1.2"})
+              .put(converter::xml::IidmXmlVersion::V1_8(), {"1.2"})
+              .put(converter::xml::IidmXmlVersion::V1_9(), {"1.2"})
+              .put(converter::xml::IidmXmlVersion::V1_10(), {"1.2"})
               .build(),
           stdcxx::MapBuilder<std::string, std::string>()
               .put("1.0", "http://www.powsybl.org/schema/iidm/ext/slack_terminal/1_0")
@@ -56,7 +60,7 @@ Extension& SlackTerminalXmlSerializer::read(Extendable& extendable, converter::x
     }
     auto& voltageLevel = dynamic_cast<VoltageLevel&>(extendable);
     const std::string& id = context.getAnonymizer().deanonymizeString(context.getReader().getAttributeValue(converter::ID));
-    const std::string& side = context.getReader().getAttributeValue(converter::SIDE);
+    const std::string& side = context.getReader().getOptionalAttributeValue(converter::SIDE, "");
     Terminal& terminal = converter::xml::TerminalRefXml::readTerminalRef(voltageLevel.getNetwork(), id, side);
     extendable.newExtension<SlackTerminalAdder>().withTerminal(terminal).add();
     return extendable.getExtension<iidm::extensions::SlackTerminal>();
diff --git a/src/iidm/Load.cpp b/src/iidm/Load.cpp
index cc5cc00..8bd46c1 100644
--- a/src/iidm/Load.cpp
+++ b/src/iidm/Load.cpp
@@ -43,6 +43,19 @@ const LoadType& Load::getLoadType() const {
     return m_loadType;
 }
 
+const LoadModel& Load::getModel() const {
+    return *m_model;
+}
+
+LoadModel& Load::getModel() {
+    return *m_model;
+}
+
+const LoadModelType& Load::getModelType() const {
+    static LoadModelType s_type = LoadModelType::NONE;
+    return m_model ? m_model->getType() : s_type;
+}
+
 double Load::getP0() const {
     return m_p0.at(getNetwork().getVariantIndex());
 }
@@ -75,6 +88,12 @@ Load& Load::setLoadType(const LoadType& loadType) {
     return *this;
 }
 
+Load& Load::setModel(std::unique_ptr<LoadModel>&& model) {
+    m_model = std::move(model);
+
+    return *this;
+}
+
 Load& Load::setP0(double p0) {
     m_p0[getNetwork().getVariantIndex()] = checkP0(*this, p0);
 
diff --git a/src/iidm/LoadExponentialModel.cpp b/src/iidm/LoadExponentialModel.cpp
new file mode 100644
index 0000000..a57dd81
--- /dev/null
+++ b/src/iidm/LoadExponentialModel.cpp
@@ -0,0 +1,45 @@
+/**
+ * Copyright (c) 2023, RTE (http://www.rte-france.com)
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+#include <powsybl/iidm/LoadExponentialModel.hpp>
+
+#include <powsybl/iidm/Load.hpp>
+#include <powsybl/iidm/ValidationUtils.hpp>
+#include <powsybl/stdcxx/make_unique.hpp>
+
+namespace powsybl {
+
+namespace iidm {
+
+LoadExponentialModel::LoadExponentialModel(double np, double nq) :
+    m_np(np),
+    m_nq(nq) {
+}
+
+std::unique_ptr<LoadModel> LoadExponentialModel::build(Load& load, double np, double nq) {
+    checkExponent(load, np);
+    checkExponent(load, nq);
+
+    return stdcxx::make_unique<LoadExponentialModel>(np, nq);
+}
+
+double LoadExponentialModel::getNp() const {
+    return m_np;
+}
+
+double LoadExponentialModel::getNq() const {
+    return m_nq;
+}
+
+const LoadModelType& LoadExponentialModel::getType() const {
+    static LoadModelType s_type = LoadModelType::EXPONENTIAL;
+    return s_type;
+}
+
+}  // namespace iidm
+
+}  // namespace powsybl
diff --git a/src/iidm/LoadZipModel.cpp b/src/iidm/LoadZipModel.cpp
new file mode 100644
index 0000000..266b284
--- /dev/null
+++ b/src/iidm/LoadZipModel.cpp
@@ -0,0 +1,78 @@
+/**
+ * Copyright (c) 2023, RTE (http://www.rte-france.com)
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+#include <powsybl/iidm/LoadZipModel.hpp>
+
+#include <powsybl/iidm/Load.hpp>
+#include <powsybl/iidm/ValidationUtils.hpp>
+#include <powsybl/stdcxx/make_unique.hpp>
+
+#include <cstdlib>
+
+namespace powsybl {
+
+namespace iidm {
+
+LoadZipModel::LoadZipModel(double c0p, double c1p, double c2p, double c0q, double c1q, double c2q) :
+    m_c0p(c0p),
+    m_c1p(c1p),
+    m_c2p(c2p),
+    m_c0q(c0q),
+    m_c1q(c1q),
+    m_c2q(c2q) {
+}
+
+std::unique_ptr<LoadModel> LoadZipModel::build(Load& load, double c0p, double c1p, double c2p, double c0q, double c1q, double c2q) {
+    checkCoefficient(load, c0p);
+    checkCoefficient(load, c1p);
+    checkCoefficient(load, c2p);
+    checkCoefficient(load, c0q);
+    checkCoefficient(load, c1q);
+    checkCoefficient(load, c2q);
+
+    if (std::abs(c0p + c1p + c2p - 1.) > std::numeric_limits<double>::epsilon()) {
+        throw ValidationException(load, "Sum of c0p, c1p and c2p should be 1");
+    }
+    if (std::abs(c0q + c1q + c2q - 1.) > std::numeric_limits<double>::epsilon()) {
+        throw ValidationException(load, "Sum of c0q, c1q and c2q should be 1");
+    }
+
+    return stdcxx::make_unique<LoadZipModel>(c0p, c1p, c2p, c0q, c1q, c2q);
+}
+
+double LoadZipModel::getC0p() const {
+    return m_c0p;
+}
+
+double LoadZipModel::getC1p() const {
+    return m_c1p;
+}
+
+double LoadZipModel::getC2p() const {
+    return m_c2p;
+}
+
+double LoadZipModel::getC0q() const {
+    return m_c0q;
+}
+
+double LoadZipModel::getC1q() const {
+    return m_c1q;
+}
+
+double LoadZipModel::getC2q() const {
+    return m_c2q;
+}
+
+const LoadModelType& LoadZipModel::getType() const {
+    static LoadModelType s_type = LoadModelType::ZIP;
+    return s_type;
+}
+
+}  // namespace iidm
+
+}  // namespace powsybl
diff --git a/src/iidm/Network.cpp b/src/iidm/Network.cpp
index f5b2530..dd44ff1 100644
--- a/src/iidm/Network.cpp
+++ b/src/iidm/Network.cpp
@@ -88,6 +88,7 @@ Network::Network(Network&& network) noexcept :
     m_caseDate(std::move(network.m_caseDate)),
     m_forecastDistance(network.m_forecastDistance),
     m_sourceFormat(std::move(network.m_sourceFormat)),
+    m_minimumValidationLevel(std::move(network.m_minimumValidationLevel)),
     m_networkIndex(*this, std::move(network.m_networkIndex)),
     m_variantManager(*this, std::move(network.m_variantManager)),
     m_variants(*this, std::move(network.m_variants)),
@@ -440,6 +441,10 @@ stdcxx::range<Load> Network::getLoads() {
     return m_networkIndex.getAll<Load>();
 }
 
+const std::string& Network::getMinimumValidationLevel() const {
+    return m_minimumValidationLevel;
+}
+
 const Network& Network::getNetwork() const {
     return *this;
 }
@@ -699,6 +704,11 @@ Network& Network::setForecastDistance(int forecastDistance) {
     return *this;
 }
 
+Network& Network::setMinimumValidationLevel(const std::string& minimumValidationLevel) {
+    m_minimumValidationLevel = checkNotEmpty(*this, minimumValidationLevel, "Minimum validation level is empty");
+    return *this;
+}
+
 }  // namespace iidm
 
 }  // namespace powsybl
diff --git a/src/iidm/NodeBreakerVoltageLevel.cpp b/src/iidm/NodeBreakerVoltageLevel.cpp
index ce5aa9e..43628e9 100644
--- a/src/iidm/NodeBreakerVoltageLevel.cpp
+++ b/src/iidm/NodeBreakerVoltageLevel.cpp
@@ -239,6 +239,24 @@ stdcxx::optional<unsigned long> NodeBreakerVoltageLevel::getEdge(const std::stri
     throw PowsyblException(stdcxx::format("Switch '%1%' not found in the voltage level '%2%'", switchId, getId()));
 }
 
+double NodeBreakerVoltageLevel::getFictitiousP0(unsigned long node) const {
+    const auto& it = m_fictitiousP0ByNode.find(node);
+    if (it != m_fictitiousP0ByNode.end()) {
+        return it->second;
+    }
+
+    return stdcxx::nan();
+}
+
+double NodeBreakerVoltageLevel::getFictitiousQ0(unsigned long node) const {
+    const auto& it = m_fictitiousQ0ByNode.find(node);
+    if (it != m_fictitiousQ0ByNode.end()) {
+        return it->second;
+    }
+
+    return stdcxx::nan();
+}
+
 const node_breaker_voltage_level::Graph& NodeBreakerVoltageLevel::getGraph() const {
     return m_graph;
 }
@@ -397,6 +415,14 @@ void NodeBreakerVoltageLevel::removeTopology() {
     m_switches.clear();
 }
 
+void NodeBreakerVoltageLevel::setFictitiousP0(unsigned long node, double p0) {
+    m_fictitiousP0ByNode[node] = p0;
+}
+
+void NodeBreakerVoltageLevel::setFictitiousQ0(unsigned long node, double q0) {
+    m_fictitiousQ0ByNode[node] = q0;
+}
+
 bool NodeBreakerVoltageLevel::traverse(NodeTerminal& terminal, Terminal::TopologyTraverser& traverser) const {
     TerminalSet traversedTerminals;
     return traverse(terminal, traverser, traversedTerminals);
diff --git a/src/iidm/NodeBreakerVoltageLevel.hpp b/src/iidm/NodeBreakerVoltageLevel.hpp
index 93374a3..6bb788f 100644
--- a/src/iidm/NodeBreakerVoltageLevel.hpp
+++ b/src/iidm/NodeBreakerVoltageLevel.hpp
@@ -80,6 +80,10 @@ public:
 
     bool isConnected(const Terminal& terminal) const;
 
+    void setFictitiousP0(unsigned long node, double p0);
+
+    void setFictitiousQ0(unsigned long node, double q0);
+
 protected: // MultiVariantObject
     void allocateVariantArrayElement(const std::set<unsigned long>& indexes, unsigned long sourceIndex) override;
 
@@ -115,6 +119,10 @@ private:
 
     stdcxx::optional<unsigned long> getEdge(const std::string& switchId, bool throwException) const;
 
+    double getFictitiousP0(unsigned long node) const;
+
+    double getFictitiousQ0(unsigned long node) const;
+
     const node_breaker_voltage_level::Graph& getGraph() const;
 
     unsigned long getInternalConnectionCount() const;
@@ -151,6 +159,10 @@ private:
     friend class node_terminal::BusViewImpl;
 
 private:
+    std::map<unsigned long, double> m_fictitiousP0ByNode;
+
+    std::map<unsigned long, double> m_fictitiousQ0ByNode;
+
     node_breaker_voltage_level::Graph m_graph;
 
     std::map<std::string, unsigned long> m_switches;
diff --git a/src/iidm/NodeBreakerVoltageLevelViews.cpp b/src/iidm/NodeBreakerVoltageLevelViews.cpp
index f85f43a..c0c88e4 100644
--- a/src/iidm/NodeBreakerVoltageLevelViews.cpp
+++ b/src/iidm/NodeBreakerVoltageLevelViews.cpp
@@ -158,6 +158,14 @@ NodeBreakerViewImpl::NodeBreakerViewImpl(NodeBreakerVoltageLevel& voltageLevel) 
     m_voltageLevel(voltageLevel) {
 }
 
+double NodeBreakerViewImpl::getFictitiousP0(unsigned long node) const {
+    return m_voltageLevel.getFictitiousP0(node);
+}
+
+double NodeBreakerViewImpl::getFictitiousQ0(unsigned long node) const {
+    return m_voltageLevel.getFictitiousQ0(node);
+}
+
 stdcxx::CReference<BusbarSection> NodeBreakerViewImpl::getBusbarSection(const std::string& bbsId) const {
     return stdcxx::cref(m_voltageLevel.getConnectable<BusbarSection>(bbsId));
 }
@@ -315,6 +323,16 @@ void NodeBreakerViewImpl::removeSwitch(const std::string& switchId) {
     m_voltageLevel.removeSwitch(switchId);
 }
 
+voltage_level::NodeBreakerView& NodeBreakerViewImpl::setFictitiousP0(unsigned long node, double p0) {
+    m_voltageLevel.setFictitiousP0(node, p0);
+    return *this;
+}
+
+voltage_level::NodeBreakerView& NodeBreakerViewImpl::setFictitiousQ0(unsigned long node, double q0) {
+    m_voltageLevel.setFictitiousQ0(node, q0);
+    return *this;
+}
+
 void NodeBreakerViewImpl::traverse(unsigned long node, const TopologyTraverser& traverser) const {
     math::Traverser graphTraverser = [this, &traverser](unsigned long v1, unsigned long e, unsigned long v2) {
         return traverser(v1, m_voltageLevel.getGraph().getEdgeObject(e), v2);
diff --git a/src/iidm/NodeBreakerVoltageLevelViews.hpp b/src/iidm/NodeBreakerVoltageLevelViews.hpp
index b922483..1871d3f 100644
--- a/src/iidm/NodeBreakerVoltageLevelViews.hpp
+++ b/src/iidm/NodeBreakerVoltageLevelViews.hpp
@@ -18,6 +18,10 @@ namespace node_breaker_voltage_level {
 
 class NodeBreakerViewImpl : public voltage_level::NodeBreakerView {
 public: // NodeBreakerView
+    double getFictitiousP0(unsigned long node) const override;
+
+    double getFictitiousQ0(unsigned long node) const override;
+
     stdcxx::CReference<BusbarSection> getBusbarSection(const std::string& bbsId) const override;
 
     stdcxx::Reference<BusbarSection> getBusbarSection(const std::string& bbsId) override;
@@ -82,6 +86,10 @@ public: // NodeBreakerView
 
     void removeSwitch(const std::string& switchId) override;
 
+    voltage_level::NodeBreakerView& setFictitiousP0(unsigned long node, double p0) override;
+
+    voltage_level::NodeBreakerView& setFictitiousQ0(unsigned long node, double q0) override;
+
     void traverse(unsigned long node, const TopologyTraverser& traverser) const override;
 
     void traverse(stdcxx::const_range<unsigned long>& nodes, const TopologyTraverser& traverser) const override;
diff --git a/src/iidm/ValidationUtils.cpp b/src/iidm/ValidationUtils.cpp
index e727de3..1e0c2cd 100644
--- a/src/iidm/ValidationUtils.cpp
+++ b/src/iidm/ValidationUtils.cpp
@@ -88,6 +88,13 @@ double checkBPerSection(const Validable& validable, double bPerSection) {
     return bPerSection;
 }
 
+double checkCoefficient(const Validable& validable, double coefficient) {
+    if (std::isnan(coefficient) || coefficient < 0) {
+        throw ValidationException(validable, stdcxx::format("Invalid zip load model coefficient: %1%", coefficient));
+    }
+    return coefficient;
+}
+
 const HvdcLine::ConvertersMode& checkConvertersMode(const Validable& /*validable*/, const HvdcLine::ConvertersMode& converterMode) {
     switch (converterMode) {
         case HvdcLine::ConvertersMode::SIDE_1_RECTIFIER_SIDE_2_INVERTER:
@@ -100,6 +107,13 @@ const HvdcLine::ConvertersMode& checkConvertersMode(const Validable& /*validable
     return converterMode;
 }
 
+double checkExponent(const Validable& validable, double n) {
+    if (std::isnan(n) || n < 0) {
+        throw ValidationException(validable, stdcxx::format("Invalid load model exponential value: %1%", n));
+    }
+    return n;
+}
+
 int checkForecastDistance(const Validable& validable, int forecastDistance) {
     if (forecastDistance < 0) {
         throw ValidationException(validable, "Forecast distance is < 0");
diff --git a/src/network/BatteryNetworkFactory.cpp b/src/network/BatteryNetworkFactory.cpp
index f0006a0..68cd790 100644
--- a/src/network/BatteryNetworkFactory.cpp
+++ b/src/network/BatteryNetworkFactory.cpp
@@ -121,8 +121,8 @@ iidm::Network BatteryNetworkFactory::create() {
         .setId("BAT")
         .setBus(nbat.getId())
         .setConnectableBus(nbat.getId())
-        .setP0(9999.99)
-        .setQ0(9999.99)
+        .setTargetP(9999.99)
+        .setTargetQ(9999.99)
         .setMinP(-9999.99)
         .setMaxP(9999.99)
         .add();
@@ -136,8 +136,8 @@ iidm::Network BatteryNetworkFactory::create() {
         .setId("BAT2")
         .setBus(nbat.getId())
         .setConnectableBus(nbat.getId())
-        .setP0(100)
-        .setQ0(200)
+        .setTargetP(100)
+        .setTargetQ(200)
         .setMinP(-200)
         .setMaxP(200)
         .add();
diff --git a/src/xml/XmlStreamWriter.cpp b/src/xml/XmlStreamWriter.cpp
index 17e2b54..9f80944 100644
--- a/src/xml/XmlStreamWriter.cpp
+++ b/src/xml/XmlStreamWriter.cpp
@@ -82,10 +82,9 @@ void XmlStreamWriter::writeEmptyElement(const std::string& uri, const std::strin
 }
 
 void XmlStreamWriter::writeEndDocument() {
-    int written = xmlTextWriterEndDocument(m_writer.get());
-    if (written < 0) {
-        throw XmlStreamException("Failed to write end document");
-    }
+    // deleting the xmlTextWriter pointer automatically calls xmlTextWriterFlush() and write to stream
+    // m_writer is instanciated in writeStartElement, so it must be deleted here
+    m_writer.reset();
 }
 
 void XmlStreamWriter::writeEndElement() {
@@ -150,11 +149,9 @@ void XmlStreamWriter::writeStartDocument(const std::string& encoding, const std:
     auto writeCallback = [](void* context, const char* buffer, int len) {
         XmlStreamWriter& writer = *static_cast<XmlStreamWriter*>(context);
 
-        size_t beforeWrite = writer.m_stream.tellp();
         writer.m_stream.write(buffer, len);
-        size_t afterWrite = writer.m_stream.tellp();
 
-        return static_cast<int>(afterWrite - beforeWrite);
+        return len;
     };
 
     auto closeCallback = [](void* /*context*/) {
